<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java集合框架详解</title>
    <url>/post/3fb8877a.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><!-- 为什么需要ArrayList，ArrayList 解决了什么问题? -->

<p>在进入源码分析前，先让我们想一个问题：</p>
<p><em>ArrayList作为一个随机访问(RandomAccess)的类，其基本操作几乎与数组一致，但是对于任何一门计算机语言来说，数组基本都是内置的基础结构，那么既然有了数组，为什么还需要ArrayList这样的数据结构呢？</em></p>
<!-- 因为自动扩容 -->

<p>从ArrayList的注释的第一句话，我们就可以找到上面问题的答案，那就是 </p>
<blockquote>
<p>Resizable-array implementation of the List interface</p>
</blockquote>
<p><strong><em>Resizable-array 大小可调整 即自动扩容</em></strong> </p>
<p>数组作为一个基本的结构，其操作是非常简单的，但是其缺点也是非常明显的，那就是数组的大小是最开始就申请好的，一旦数据数目超过了数组大小，就会有数组越界风险。 那么对于一些我们无法提前知道数据个数的场景，比如用户购物车的场景，用户随时可以增加商品.</p>
<p>而ArrayList的自动扩容恰好弥补该缺陷，开发者无需考虑数组越界的风险，增加商品的时候直接add即可，由ArrayList来进行动态调整。</p>
<p>那么ArrayList又是如何进行resizable呢？这就需要进入源码的世界了</p>
<h1 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The<span class="built_in"> array </span>buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this<span class="built_in"> array </span>buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/%E6%95%B0%E7%BB%84.jpg" alt=""></p>
<p>ArrayList的内部依旧采用的数组(elementData存储元素)的数据结构，并且类型是Object，由于java中所有类都继承自Object，故而ArrayList实质可以存储所有类型。</p>
<h2 id="什么时候扩容？"><a href="#什么时候扩容？" class="headerlink" title="什么时候扩容？"></a>什么时候扩容？</h2><p>对于RandomAccess 随机访问的集合结构来说，最终要的接口无疑是 get，set，add 方法了。</p>
<p>首先来看get方法(如下code)：对于get/set来说，是无需关心扩容问题的，只要没有越界，那么这个数据就肯定存在，故而仅仅检查了越界问题就直接返回了数组中的Index位置的元素（或者设置数组index位置的元素）</p>
<details>
<summary>View Code</summary>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> E <span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> elementData(<span class="keyword">index</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> private <span class="type">void</span> range<span class="keyword">Check</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= size)</span><br><span class="line">         throw <span class="built_in">new</span> IndexOutOfBoundsException(outOfBoundsMsg(<span class="keyword">index</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">public</span> E <span class="keyword">set</span>(<span class="type">int</span> <span class="keyword">index</span>, E element) &#123;</span><br><span class="line">     range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">     E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line">     elementData[<span class="keyword">index</span>] = element;</span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</details>

<br/>
<br/>

<p><strong><em>add方法：</em></strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保容量足够</span></span><br><span class="line">    ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>); </span><br><span class="line">    elementData[<span class="built_in">size</span>++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前数空数组，则取size+1和默认值的最大值，否则取size+1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.<span class="built_in">max</span>(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果 当前需求的最小容量 比内部的数组长度大 则表示内部数组已经存放不了 此时便需要进行扩容处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，ArrayList在进行add操作的时候会先确保当前容量是否足够，如果不足变回调用grow方法进行扩容。</p>
<p><strong>结论：</strong><br>此时，便可以得出结论，当ArrayList在进行add操作的时候，如果所需要的数量大于当前ArrayList内部数组elementData的长度的时候，由于elementData已经存放不下，此时便需要进行扩容。</p>
<h2 id="怎么扩容？"><a href="#怎么扩容？" class="headerlink" title="怎么扩容？"></a>怎么扩容？</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void grow(int minCapacity) &#123;</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的 1.5倍</span></span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新容量比需求容量小，则新容量直接设置为需要的容量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量比 默认最大数值大 Integer.MAX_VALUE-8,则判断需要的是否超过MAX_ARRAY_SIZE，超过取最大，否则取MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 进行原数组复制，扩容。</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :<span class="type"></span></span><br><span class="line"><span class="type">        MAX_ARRAY_SIZE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/ArrayList%E6%89%A9%E5%AE%B9.jpg" alt=""></p>
<p><strong><em>示例：</em></strong><br><img src="../resource/java/ArrayList%E6%89%A9%E5%AE%B9%E7%A4%BA%E4%BE%8B.jpg" alt=""></p>
<p>总结：</p>
<ol>
<li>ArrayList的扩容是以原容量的1.5倍为基础。</li>
<li>扩容的过程中会进行越界检查。</li>
<li><strong><em>如果需求容量大于原容量的1.5倍，则会直接扩容到需求容量。</em></strong>所以当我们多次通过addAll进行新增元素（并且新增元素比较多的时候）的时候，是否可以调用ensureCapacity()方法手动扩容，以避免addAll的多次频繁扩容。</li>
</ol>
<h2 id="其他重要函数"><a href="#其他重要函数" class="headerlink" title="其他重要函数"></a>其他重要函数</h2><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><details>
<summary>view Code</summary>

<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     <span class="comment">//越界检查</span></span><br><span class="line">      rangeCheck(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">      modCount++; </span><br><span class="line">      <span class="comment">//设置值</span></span><br><span class="line">      E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line">      <span class="comment">//不需要移动的数组元素</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">         <span class="comment">//移动删除元素后面的所有元素</span></span><br><span class="line">          System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//设置为null，当数组为null的时候利于GC回收</span></span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>; </span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong> remove方法进行了越界检查，由于数组的特性，remove后需要将remove掉的位置之后的所有元素向前移动，以保证remove后ArrayList还是保持其基本操作不变。</p>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><details>
<summary>view Code</summary>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> indexOf(Object o) &#123;</span><br><span class="line">      <span class="comment">//空进行特殊处理</span></span><br><span class="line">       <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//其余部分均使用equals判断</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong> indexOf查找位置的方法，对于null进行了==号比较，对于普通元素都使用的equals方法进行比较</p>
<h3 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h3><details>
<summary>view Code</summary>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> new SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subList构造函数</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">                int offset, int fromIndex, int toIndex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="keyword">set</span>(int index, E e) &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明:</strong> 使用数组的时候，有时候我们会使用subList方法去构建一个子视图，通过subList方法，我们可以发现，子方法的所有操作都是针对于原ArrayList中的数组的，<strong><em>故而在子视图上进行的任何修改都会反映到原ArrayList对象中</em></strong></p>
<!-- 总结 -->
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>ArrayList的出现，为用户提供了一种自维护的数组数据结构，用户不需要再考虑越界，数组扩容，插入元素数组的元素移动等操作。</li>
<li>ArrayList内部依旧是通过数组的数据结构实现的。</li>
<li>ArrayList的自动扩容机制是通过数组复制实现的，扩容操作是在新增元素的时候进行容量检查，进行扩容</li>
<li>ArrayList的扩容默认容量是原容量的1.5倍，如果新增元素量大于1.5倍原容量，则会直接扩容到新增元素后需要的大小。</li>
<li>ArrayList的subList子视图方法，进行修改操作的时候是直接反映到原ArrayList中的。</li>
</ol>
<p>ArrayList具有随机读写的优点，对于特定位置的元素获取修改等操作可以有O(1)的复杂度，但是却在插入删除中间元素等操作的时候，需要进行大量元素移动的操作，效率低下O(n)。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合框架详解</title>
    <url>/post/82f1582a.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  作为java程序员，java集合在开发过程中使用的非常频繁，例如 ArrayList,HashMap，基本可以说在每一个项目中都会有。但是却又很少去了解其底层原理。所以准备对java集合框架源码进行探究，梳理集合框架数据结构和设计原理。 此次梳理希望能实现下面的目标：<br>      &emsp; 1. 温故而知新，对于java底层知识的回顾。<br>      &emsp; 2. 了解涉及思想，提升代码设计水平。<br>      &emsp; 3. 了解底层设计，能够以最恰当的方式使用java的集合 </p>
<h1 id="梳理线路"><a href="#梳理线路" class="headerlink" title="梳理线路"></a>梳理线路</h1><p><img src="../resource/java/java%E9%9B%86%E5%90%88.png" alt=""></p>
<h1 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h1><p><img src="../resource/java/javaCollection.jpeg" alt="图片源于百度"></p>
<center><font size=1>注明：图片源于百度</font></center>  
<br/>

<p>总结：</p>
<ol>
<li>6大顶层接口:Collection ,Iterator,Map,List,Set,Queue</li>
<li>5大抽象类 AbstractCollection,AbstractList,AbstractSet,AbstractMap,AbstractSeqentialList.</li>
<li>10个一级实现类</li>
<li>两个功能接口：Comparable,Comparator</li>
<li>两大工具类: Collections,Arrays</li>
</ol>
<h1 id="基础接口-类概览"><a href="#基础接口-类概览" class="headerlink" title="基础接口/类概览"></a>基础接口/类概览</h1><p><img src="../resource/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%8E%A5%E5%8F%A3%E6%A2%B3%E7%90%86.png" alt=""></p>
<h1 id="重要接口说明"><a href="#重要接口说明" class="headerlink" title="重要接口说明"></a>重要接口说明</h1><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><details>
<summary>View Code</summary>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    E next();</span><br><span class="line">   <span class="built_in"> default </span>void <span class="builtin-name">remove</span>() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明</strong></p>
<ol>
<li>iterator接口定义迭代器的基本操作,主要方法 hasNext(),next().</li>
</ol>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>除了Map接口，其他的接口都继承自Collection接口，并且由于java多态的特性，Interface i1 = new Immplements() 。 此时该对象i1调用的方法必须是接口中所有的，故而对于Collection接口就必须要有个了解。</p>
<details>
<summary>View Code</summary>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean contains(Object o);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    boolean <span class="builtin-name">add</span>(E e);</span><br><span class="line">    boolean <span class="builtin-name">remove</span>(Object o);</span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line">   <span class="built_in"> default </span>boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line">    void clear();</span><br><span class="line">    boolean equals(Object o);</span><br><span class="line">    int hashCode();</span><br><span class="line">    @Override</span><br><span class="line">   <span class="built_in"> default </span>Spliterator&lt;E&gt; spliterator() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>Stream&lt;E&gt; stream() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>Stream&lt;E&gt; parallelStream() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明：</strong></p>
<ol>
<li>作为集合顶层接口的Collection 定义了对于一个集合最普遍的操作，增，删，判空，转数组，判断包含等等基本操作。</li>
<li>集合继承了Iterable接口，包含了 iterator方法，对于集合来说，需要可遍历集合中所有元素</li>
</ol>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><details>
<summary>View Code</summary>

<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">interface</span> <span class="type">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean containsKey(<span class="type">Object</span> key);</span><br><span class="line">    boolean containsValue(<span class="type">Object</span> value);</span><br><span class="line">    V get(<span class="type">Object</span> key);</span><br><span class="line">    V put(K key, V value);</span><br><span class="line">    V remove(<span class="type">Object</span> key);</span><br><span class="line">    <span class="built_in">void</span> putAll(<span class="type">Map</span>&lt;? extends K, ? extends V&gt; m);</span><br><span class="line">    <span class="built_in">void</span> clear();</span><br><span class="line">    <span class="type">Set</span>&lt;K&gt; keySet();</span><br><span class="line">    <span class="type">Collection</span>&lt;V&gt; values();</span><br><span class="line">    <span class="type">Set</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">    <span class="keyword">interface</span> <span class="type">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        V setValue(V value);</span><br><span class="line">        boolean equals(<span class="type">Object</span> o);</span><br><span class="line">        <span class="built_in">int</span> hashCode();</span><br><span class="line">        public <span class="keyword">static</span> &lt;K extends <span class="type">Comparable</span>&lt;? super K&gt;, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K,V&gt;&gt; comparingByKey() <span class="meta">&#123;...&#125;</span></span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V extends <span class="type">Comparable</span>&lt;? super V&gt;&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K,V&gt;&gt; comparingByValue() &#123; ... &#125;</span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; comparingByKey(<span class="type">Comparator</span>&lt;? super K&gt; cmp) <span class="meta">&#123;...&#125;</span></span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; comparingByValue(<span class="type">Comparator</span>&lt;? super V&gt; cmp) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    boolean equals(<span class="type">Object</span> o);</span><br><span class="line">    <span class="built_in">int</span> hashCode();</span><br><span class="line">    default V getOrDefault(<span class="type">Object</span> key, V defaultValue) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="built_in">void</span> forEach(<span class="type">BiConsumer</span>&lt;? super K, ? super V&gt; action) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="built_in">void</span> replaceAll(<span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; function) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V putIfAbsent(K key, V value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default boolean remove(<span class="type">Object</span> key, <span class="type">Object</span> value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default boolean replace(K key, V oldValue, V newValue) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V replace(K key, V value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V computeIfAbsent(K key,</span><br><span class="line">            <span class="type">Function</span>&lt;? super K, ? extends V&gt; mappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V computeIfPresent(K key,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V compute(K key,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V merge(K key, V value,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super V, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明:</strong></p>
<ol>
<li>通用集合都是单值，Map是 kv 双值，故而Map的接口与Collection的接口会有很大的区别，这也是其他集合接口均集成Collection而Map不继承的原因</li>
<li>Map的基础操作依赖于Entry，外层是对于Entry的Set集合视图。</li>
<li>Map接口定义Map类型的基本增加，删除，判断，清空，大小等方法</li>
</ol>
<h2 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable&amp;Comparator"></a>Comparable&amp;Comparator</h2><details>
<summary>View Code</summary>

<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">interface</span> <span class="type">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> compareTo(T var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">interface</span> <span class="type">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> compare(T o1, T o2);</span><br><span class="line"></span><br><span class="line">    boolean equals(<span class="type">Object</span> obj);</span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; reversed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Collections</span>.reverseOrder(this);</span><br><span class="line">    &#125;</span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparing(<span class="type">Comparator</span>&lt;? super T&gt; other) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default &lt;U&gt; <span class="type">Comparator</span>&lt;T&gt; thenComparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor,</span><br><span class="line">            <span class="type">Comparator</span>&lt;? super U&gt; keyComparator)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default &lt;U extends <span class="type">Comparable</span>&lt;? super U&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; thenComparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">    <span class="meta">&#123;... &#125;</span></span><br><span class="line"><span class="meta">    default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) &#123;...&#125;</span></span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparingLong(<span class="type">ToLongFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparingDouble(<span class="type">ToDoubleFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T extends <span class="type">Comparable</span>&lt;? super T&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; reverseOrder() <span class="meta">&#123;...&#125;</span></span><br><span class="line">    @<span class="type">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    public <span class="keyword">static</span> &lt;T extends <span class="type">Comparable</span>&lt;? super T&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; naturalOrder() <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; nullsFirst(<span class="type">Comparator</span>&lt;? super T&gt; comparator) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; nullsLast(<span class="type">Comparator</span>&lt;? super T&gt; comparator) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T, U&gt; <span class="type">Comparator</span>&lt;T&gt; comparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor,</span><br><span class="line">            <span class="type">Comparator</span>&lt;? super U&gt; keyComparator)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T, U extends <span class="type">Comparable</span>&lt;? super U&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; comparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingInt(<span class="type">ToIntFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingLong(<span class="type">ToLongFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span>&lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingDouble(<span class="type">ToDoubleFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong></p>
<ol>
<li>Comparable与Comparator都是用作定义可排序和排序方式的接口，主要区别Comparable是内比较，用作当前对象和其他对象比较，COmparator是外比较，用于两个对象进行比较。</li>
</ol>
<h2 id="Collections-amp-Arrays"><a href="#Collections-amp-Arrays" class="headerlink" title="Collections&amp;Arrays"></a>Collections&amp;Arrays</h2><p>Collections：主要包含了集合的各种通用方法，例如，排序，拷贝，乱序，反序，查找，替换等等。Arrays类，主要是数组的基本操作，包含了各种排序搜索填充等基本操作</p>
<h2 id="equals-amp-hashCode"><a href="#equals-amp-hashCode" class="headerlink" title="equals &amp; hashCode"></a>equals &amp; hashCode</h2><p>HaseCode 和 equals方法是两个基础方法，其定义在Object.java类中，这两个方法定义了java中判断两个对象是否相等的方法。 </p>
<p>为什么会有equals方法呢，java中== 比较的是对象的内存地址，也就是说判断两个对象是否是统一个对象(<a href="https://blog.csdn.net/AlbenXie/article/details/88921344" target="_blank" rel="noopener">此处存在一个面试题，就是String的不同创建方式的==比较。涉及String常量词的概念</a>)，但是很多时候，比较统一对象是否是同一个对象并不是我们所需要的。所以便出现了equals方法，可以自定义两个对象是否相同。 </p>
<p><strong><em>注意：由于hashMap的比较中即使用了equals也是用到了hashCode所以对于一个对象，如果重写了equals一定要重写hashCode，以免在散列表等等场景下出现异常的情况</em></strong></p>
<p>Object规范规定：</p>
<ol>
<li>在统一个java执行程序中，如果一个对象的equals方法没有发生变更，那么无论调动多少次hashCode方法，始终返回同一个值</li>
<li>如果两个对象的equals()相同，那么两个对象的hashCode()必须返回相同的值</li>
<li>如果两个对象equals不同，那么并不要求一定不能返回两个相同的hashCode。但是不equal的两个值产生不同的hashCode可以有效的提升散列表的性能（此处参见hashMap的源码分析）。</li>
</ol>
<p>equals相等，hashCode必须相同。 equals不同，hashCode可以相同，但是建议不同。应为相同的hashCode多了之后，可能会让hashMap退化成链表结构。</p>
<details>
<summary>原文注释</summary>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>a<span class="markdown"> hash code value for </span>the<span class="markdown"> object. This method is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>supported for </span>the<span class="markdown"> benefit of hash tables </span>such<span class="markdown"> as those provided by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>&#123;@link java.util.HashMap&#125;.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>The general contract of &#123;@code hashCode&#125; is:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Whenever it is invoked on </span>the<span class="markdown"> same object </span>more<span class="markdown"> than once during</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span></span>an<span class="markdown"> execution of </span>a<span class="markdown"> Java application, </span>the<span class="markdown"> &#123;@code hashCode&#125; method</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>must consistently return </span>the<span class="markdown"> same integer, provided no information</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>used in &#123;@code equals&#125; comparisons on </span>the<span class="markdown"> object is modified.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>This integer need not remain consistent from one execution of </span>an</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>application to another execution of </span>the<span class="markdown"> same application.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>If two objects </span>are<span class="markdown"> equal according to </span>the<span class="markdown"> &#123;@code equals(Object)&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>method, then calling </span>the<span class="markdown"> &#123;@code hashCode&#125; method on each of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span></span>the<span class="markdown"> two objects must produce </span>the<span class="markdown"> same integer result.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>It is <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>not<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span> required that if two objects </span>are<span class="markdown"> unequal</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>according to </span>the<span class="markdown"> &#123;@link java.lang.Object#equals(java.lang.Object)&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>method, then calling </span>the<span class="markdown"> &#123;@code hashCode&#125; method on each of </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>two objects must produce distinct integer results.  However, </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>programmer </span>should<span class="markdown"> be aware that producing distinct integer results</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>for unequal objects may improve </span>the<span class="markdown"> performance of hash tables.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>As much as is reasonably practical, </span>the<span class="markdown"> hashCode method defined by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>class &#123;@code Object&#125; does return distinct integers for distinct</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>objects. (This is typically implemented by converting </span>the<span class="markdown"> internal</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>address of </span>the<span class="markdown"> object into </span>an<span class="markdown"> integer, </span>but<span class="markdown"> this implementation</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>technique is not required by </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Java&amp;trade; programming language.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return  </span>a<span class="markdown"> hash code value for this object.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see     java.lang.Object#equals(java.lang.Object)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see     java.lang.System#identityHashCode</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public native <span class="built_in">int</span> hashCode();</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>资源清单</title>
    <url>/post/71d60cd0.html</url>
    <content><![CDATA[<h1 id="建站："><a href="#建站：" class="headerlink" title="建站："></a>建站：</h1><ul>
<li>主站点:      <a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li>
<li>next主题:    <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></li>
<li>标签云:      <a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md</a></li>
<li>文件唯一id节点:<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a></li>
</ul>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ul>
<li>ppt教程:<a href="https://www.bilibili.com/video/av54211804?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av54211804?p=1</a></li>
</ul>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>ppt</tag>
        <tag>收藏夹</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
</search>
