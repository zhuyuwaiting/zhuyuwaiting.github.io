<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>volatile详解</title>
    <url>/post/f3607baf.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>volatile关键字可以说是java虚拟机提供的一种最轻量级的同步机制，但是volatile的语义又经常被错误的理解，导致出现预期外的错误，也因此volatile也经常是面试必问的问题，了解volatile变量的语义就显得非常重要。</p>
<h1 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h1><ol>
<li>保证了变量对所有线程的可见性，即当一条线程修改了这个变量的值之后，新值对于对于其他线程来说是可以立即知道的。（实现可见性）</li>
<li>禁止指令重排序功能，（实现有序性）</li>
<li>volatile是不保证变量的原子性的，原子性需要变量自行保证。</li>
</ol>
<h1 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a>volatile 的实现原理</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>Java代码：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> = new <span class="type">Singleton</span>();//<span class="keyword">instance</span>是volatile变量</span></span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x01a3de1d</span>: movb $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi);</span><br><span class="line"><span class="number">0x01a3de24</span>: lock  addl $<span class="number">0x0</span>,(%esp);</span><br></pre></td></tr></table></figure>

<p>lock 其实是内存屏障，我们之前在  <a href="/post/ab0f6be5.html" title="&lt;b&gt;java并发理论&lt;&#x2F;b&gt;"><b>java并发理论</b></a>  中有说过内存模型通过缓存一致协议和store buffers 以及invalid queue 来进行一致性的控制，由于store buffer 引入了 内存屏障。</p>
<p>此处的lock便是便是利用系统的内存屏障，将处理器中的缓存数据写回到主内存中，并且通知其他本地内存或者缓存失效。</p>
<p>对于java内存模型来说，这种操作相当于对缓存中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作。</p>
<p>对于可见性这条来说，有些任务修改变量对于所有线程可见就以为这是线程安全的，这种说法是错误的，因为<strong>volatile不保证变量的原子性</strong>。 如果一个的操作不是原子的，例如 i++这种，即使用volatile修饰，多线程操作也会出现问题。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        Thread[] thread = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;thread.length;i++)&#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        incrase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)  </span><br><span class="line">            thread[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;thread.length;i++)&#123;</span><br><span class="line">            thread[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子，并发正确的话 其实结果应该是100000，但是实际结果往往小于100000，本质原因是因为i++并不是一个原子的操作，虽然写回到内存中的操作是原子的，但是i++包含了读取，计算 ，写回三个步骤。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><ol>
<li>禁止指令重排序</li>
<li>happen-before原则。</li>
</ol>
<h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>为了性能的优化JMM会在不改变正确语义的情况下，对volatile指令进行重新排序。</p>
<p>JMM 可以通过在特定位置生成内存屏障指令来禁止指令重排序如下：<br><img src="../resource/java/volatile%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C1.jpg" alt=""></p>
<p><img src="../resource/java/volatile%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C2.jpg" alt=""></p>
<h3 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h3><p>在 <a href="/post/ab0f6be5.html" title="&lt;b&gt;java并发理论&lt;&#x2F;b&gt;"><b>java并发理论</b></a> 中，我们说过happen-before的八大原则，其中就包括了volatile的原则：</p>
<p><strong>对一个volatile变量的写，先于对后面对这个变量的读操作</strong></p>
<p>其实现也是通过内存屏障的方式进行的实现。</p>
<h1 id="volatile-应用场景"><a href="#volatile-应用场景" class="headerlink" title="volatile 应用场景"></a>volatile 应用场景</h1><p>要使 volatile 变量提供理想的线程安全，必须具备如下条件：</p>
<ol>
<li>对变量的写，不依赖与当前值</li>
<li>该变量没有包含在其他变量的不变式中。</li>
</ol>
<h2 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    flag = <span class="literal">true</span>;   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123;   </span><br><span class="line">        <span class="comment">// do stuff  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通常来说，这种状态标记的转换，只有一种转换，即false-true，volatile保证了线程可见。不普适false-true-false的多重转换</strong></p>
<h2 id="独立观察"><a href="#独立观察" class="headerlink" title="独立观察"></a>独立观察</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> UserManager &#123;  </span><br><span class="line">    <span class="built_in">public</span> <span class="keyword">volatile</span> String lastUser; //发布的信息  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">public</span> <span class="type">boolean</span> authenticate(String <span class="keyword">user</span>, String <span class="keyword">password</span>) &#123;  </span><br><span class="line">        <span class="type">boolean</span> <span class="keyword">valid</span> = passwordIsValid(<span class="keyword">user</span>, <span class="keyword">password</span>);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">valid</span>) &#123;  </span><br><span class="line">            <span class="keyword">User</span> u = <span class="built_in">new</span> <span class="keyword">User</span>();  </span><br><span class="line">            activeUsers.<span class="keyword">add</span>(u);  </span><br><span class="line">            lastUser = <span class="keyword">user</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">valid</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来记录上一次登陆有用的信息。利用volatile的可见性。</p>
<h2 id="单例模式的优化-双重检查锁"><a href="#单例模式的优化-双重检查锁" class="headerlink" title="单例模式的优化(双重检查锁)"></a>单例模式的优化(双重检查锁)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instace;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;   </span><br><span class="line"><span class="comment">//第一次null检查     </span></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;            </span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;    <span class="comment">//1     </span></span><br><span class="line">        <span class="comment">//第二次null检查       </span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;            <span class="comment">//2  </span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();<span class="comment">//3  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;           </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> instance;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.jianshu.com/p/ccfe24b63d87" target="_blank" rel="noopener">https://www.jianshu.com/p/ccfe24b63d87</a><br><a href="https://www.cnblogs.com/ouyxy/p/7242563.html" target="_blank" rel="noopener">https://www.cnblogs.com/ouyxy/p/7242563.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread详解</title>
    <url>/post/85e75abb.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Thread类用于操作java线程的基础类，本文通过源码来对Thread类的功能以及方法进行分析了解</p>
<h1 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h1><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>            priority;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     daemon = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> Runnable <span class="keyword">target</span>;</span><br><span class="line"><span class="keyword">private</span> ThreadGroup group;</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>name:</strong> 线程名称.用于标识一个线程。创建线程的时候最好能够指定名称，在出现问题的时候有助于排查</p>
<p><strong>priority:</strong> 线程优先级。java线程的调度是抢占式调度，优先级字段让系统能够优先给与时间片执行</p>
<p><strong>daemon:</strong> 是否是后台线程，jvm退出的条件执行了exit()方法或者是所有的非后台线程都退出了。</p>
<p><strong>target:</strong> 需要执行的目标方法。</p>
<p><strong>group:</strong> 线程的分组</p>
<p><strong>threadLocal：</strong> 线程本地变量保存地方。</p>
<p><strong>threadStatus:</strong> 线程状态。<br><img src="../resource/java/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt=""></p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable <span class="keyword">target</span>, String name)</span> </span>&#123;</span><br><span class="line">    init(group, <span class="keyword">target</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> init(ThreadGroup g, Runnable <span class="keyword">target</span>, String name,</span><br><span class="line">                    <span class="keyword">long</span> stackSize) &#123;</span><br><span class="line">    init(g, <span class="keyword">target</span>, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的构造方法都是调用的该方法，无非是参数不同，是否有值的问题。线程的基本参数有3个，<br>threadGroup  target name 分别表示线程组，执行目标，和线程名称</p>
<p>stackSize 可以忽略，其内部注释如下:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    * The requested stack size <span class="keyword">for</span> this thread, <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">the</span> creator did</span><br><span class="line">    * <span class="keyword">not</span> specify a stack size.  It <span class="keyword">is</span> up <span class="keyword">to</span> <span class="keyword">the</span> VM <span class="keyword">to</span> do whatever <span class="keyword">it</span></span><br><span class="line">    * likes <span class="keyword">with</span> this <span class="built_in">number</span>; <span class="keyword">some</span> VMs will ignore <span class="keyword">it</span>.</span><br><span class="line">    */</span><br><span class="line">private long stackSize;</span><br></pre></td></tr></table></figure>

<p>target的使用是对于实现Runnabel接口方式的创建的线程执行的方法。</p>
<h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><h2 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">target</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">target</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处可以印证之前的线程创建方法：</p>
<ol>
<li>继承Thread  重写run方法。 重写run方法后执行的就是run中定义的内容</li>
<li>实现Runnable </li>
</ol>
<h2 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronized加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有NEW状态的线程可以执行    </span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前线程加入到group中。</span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行native方法</span></span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// native方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>run方法只是定义了线程执行的步骤，start方法才是真正启动线程，并且通过native方法启动</strong></p>
<h2 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public<span class="keyword"> final</span> void stop() &#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">   <span class="built_in"> if </span>(security != null) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">       <span class="built_in"> if </span>(this != Thread.currentThread()) &#123;</span><br><span class="line">            security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // A zero status value corresponds to <span class="string">"NEW"</span>, it can't change to</span><br><span class="line">    //<span class="built_in"> not-NEW </span>because we hold the lock.</span><br><span class="line">   <span class="built_in"> if </span>(threadStatus != 0) &#123;</span><br><span class="line">        resume(); // Wake up thread<span class="built_in"> if </span>it was suspended; no-op otherwise</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The VM can handle all thread states</span><br><span class="line">    stop0(new ThreadDeath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stop方法已经被取消了，根据注释中的解释：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">This method is inherently unsafe.  Stopping <span class="keyword">a</span> thread <span class="keyword">with</span>,Thread.<span class="built_in">stop</span> causes <span class="keyword">it</span> <span class="built_in">to</span> unlock all <span class="keyword">of</span> <span class="keyword">the</span> monitors that <span class="keyword">it</span>,has locked (<span class="keyword">as</span> <span class="keyword">a</span> natural consequence <span class="keyword">of</span> <span class="keyword">the</span> unchecked&lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up <span class="keyword">the</span> stack).  If <span class="keyword">any</span> <span class="keyword">of</span> <span class="keyword">the</span> objects previously protected <span class="keyword">by</span> these monitors were <span class="keyword">in</span> <span class="keyword">an</span> inconsistent state, <span class="keyword">the</span> damaged objects become visible <span class="built_in">to</span> other threads, potentially resulting <span class="keyword">in</span> arbitrary behavior.</span><br><span class="line"></span><br><span class="line">Many uses <span class="keyword">of</span> &lt;code&gt;<span class="built_in">stop</span>&lt;/code&gt; should be replaced <span class="keyword">by</span> code that simply  modifies some <span class="built_in">variable</span> <span class="built_in">to</span> indicate that <span class="keyword">the</span> target thread should <span class="built_in">stop</span> running.</span><br></pre></td></tr></table></figure>

<p>stop方法由于会释放之前monitor加锁的变量，导致这些变量可以对其他线程可见，导致结果不可预测。</p>
<p>如果需要停止线程应该使用变量的方式来进行。</p>
<h2 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon()"></a>setDaemon()</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置为守护线程。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//The thread does not lose ownership of any monitors.</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> sleep(<span class="keyword">long</span> <span class="built_in">millis</span>) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sleep(<span class="keyword">long</span> <span class="built_in">millis</span>, <span class="built_in">int</span> nanos)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; <span class="built_in">millis</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">millis</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="built_in">millis</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep 休眠指定时间。交出CPU，让CPU执行其他任务。</p>
<p><strong>注意:sleep 不会释放当前线程持有的锁。</strong></p>
<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait()/notify()/notifyAll()"></a>wait()/notify()/notifyAll()</h2><p>实际上 wait notify notifyAll并不是 Thread的方法，但是其是线程操作的基本方法，并且wait方法经常拿来和sleep方法比较，所以此处也说下这三个方法</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个方法都看不到源码，其均是native的方法</p>
<p>我们来看看wait 的注释：</p>
<details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>Causes </span>the<span class="markdown"> current thread to wait until either another thread invokes </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@link java.lang.Object#notify()&#125; method or </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@link java.lang.Object#notifyAll()&#125; method for this object, or </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>specified amount of time has elapsed.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>The current thread must own this object's monitor.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>This method causes </span>the<span class="markdown"> current thread (call it <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span>) to</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>place itself in </span>the<span class="markdown"> wait set for this object and then to relinquish</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>any and all synchronization claims on this object. Thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>becomes disabled for thread scheduling purposes and lies dormant</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>until one of four things happens:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Some other thread invokes </span>the<span class="markdown"> &#123;@code notify&#125; method for this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>object and thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span> happens to be arbitrarily chosen as</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span></span>the<span class="markdown"> thread to be awakened.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Some other thread invokes </span>the<span class="markdown"> &#123;@code notifyAll&#125; method for this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>object.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Some other thread &#123;@linkplain Thread#interrupt() interrupts&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span>.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>The specified amount of real time has elapsed, </span>more<span class="markdown"> or less.  If</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@code timeout&#125; is zero, however, then real time is not taken into</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>consideration and </span>the<span class="markdown"> thread </span>simply<span class="markdown"> waits until notified.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>The thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span> is then removed from </span>the<span class="markdown"> wait set for this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>object and re-enabled for thread scheduling. It then competes in </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>usual manner with other threads for </span>the<span class="markdown"> right to synchronize on </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>object; once it has gained control of </span>the<span class="markdown"> object, all its</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>synchronization claims on </span>the<span class="markdown"> object </span>are<span class="markdown"> restored to </span>the<span class="markdown"> status quo</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>ante - that is, to </span>the<span class="markdown"> situation as of </span>the<span class="markdown"> time that </span>the<span class="markdown"> &#123;@code wait&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>method was invoked. Thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span> then returns from </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>invocation of </span>the<span class="markdown"> &#123;@code wait&#125; method. Thus, on return from </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@code wait&#125; method, </span>the<span class="markdown"> synchronization state of </span>the<span class="markdown"> object and of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>thread &#123;@code T&#125; is exactly as it was when </span>the<span class="markdown"> &#123;@code wait&#125; method</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>was invoked.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>A thread can also wake up without being notified, interrupted, or</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>timing out, </span>a<span class="markdown"> </span>so<span class="markdown">-called <span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span></span>spurious wakeup<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>.  While this </span>will<span class="markdown"> rarely</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>occur in practice, applications must guard against it by testing for</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span></span>the<span class="markdown"> condition that </span>should<span class="markdown"> have caused </span>the<span class="markdown"> thread to be awakened, and</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>continuing to wait if </span>the<span class="markdown"> condition is not satisfied.  In other words,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>waits </span>should<span class="markdown"> always occur in loops, </span>like<span class="markdown"> this one:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *     </span>synchronized (obj) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *         </span>while (&amp;lt;condition does not hold&amp;gt;)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>obj.wait(timeout);</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *         </span>... // Perform action appropriate to condition</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *     </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>(For </span>more<span class="markdown"> information on this topic, see Section 3.2.3 in Doug Lea's</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>"Concurrent Programming in Java (Second Edition)" (Addison-Wesley,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>2000), or Item 50 in Joshua Bloch's "Effective Java Programming</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>Language Guide" (Addison-Wesley, 2001).</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>If </span>the<span class="markdown"> current thread is &#123;@linkplain java.lang.Thread#interrupt()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>interrupted&#125; by any thread before or while it is waiting, then </span>an</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@code InterruptedException&#125; is thrown.  This exception is not</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>thrown until </span>the<span class="markdown"> lock status of this object has been restored as</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>described above.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>Note that </span>the<span class="markdown"> &#123;@code wait&#125; method, as it places </span>the<span class="markdown"> current thread</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>into </span>the<span class="markdown"> wait set for this object, unlocks only this object; any</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>other objects on which </span>the<span class="markdown"> current thread may be synchronized remain</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>locked while </span>the<span class="markdown"> thread waits.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>This method </span>should<span class="markdown"> only be called by </span>a<span class="markdown"> thread that is </span>the<span class="markdown"> owner</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>of this object's monitor. See </span>the<span class="markdown"> &#123;@code notify&#125; method for </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>description of </span>the<span class="markdown"> ways in which </span>a<span class="markdown"> thread can become </span>the<span class="markdown"> owner of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span></span>a<span class="markdown"> monitor.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@param      timeout   </span>the<span class="markdown"> maximum time to wait in milliseconds.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@throws  IllegalArgumentException      if </span>the<span class="markdown"> value of timeout is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *               </span>negative.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@throws  IllegalMonitorStateException  if </span>the<span class="markdown"> current thread is not</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *               </span></span>the<span class="markdown"> owner of </span>the<span class="markdown"> object's monitor.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@throws  InterruptedException if any thread interrupted </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>current thread before or while </span>the<span class="markdown"> current thread</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>was waiting for </span>a<span class="markdown"> notification.  The <span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span></span>interrupted</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>status<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> of </span>the<span class="markdown"> current thread is cleared when</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>this exception is thrown.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@see        java.lang.Object#notify()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@see        java.lang.Object#notifyAll()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">   public <span class="keyword">final</span> native <span class="keyword">void</span> wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>

</details>


<p>可以发现：</p>
<ol>
<li>wait是使当前线程休眠，但是当前线程必须有对象的monitor.这个很容易理解，因为 wait是在对象上的，lock.wait()，所以要执行，线程必须先有这个对象的monitor才可以</li>
<li>线程休眠放入等待集合wait set中，并且释放持有的锁，除非被 notify notifyAll interrupt唤醒或者超时</li>
<li><strong>虚假唤醒(spurious wakeup)问题，所以在使用wait的时候建议在循环中使用</strong></li>
<li>如果被interrupt，则会抛出InterruptedException异常。</li>
</ol>
<h3 id="什么是虚假唤醒"><a href="#什么是虚假唤醒" class="headerlink" title="什么是虚假唤醒"></a>什么是虚假唤醒</h3><p>虚假唤醒的问题，要追溯到linux 底层函数</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Spurious wakeup describes a complication <span class="keyword">in</span> <span class="keyword">the</span> use <span class="keyword">of</span> condition variables <span class="keyword">as</span> provided <span class="keyword">by</span> certain multithreading APIs such <span class="keyword">as</span> POSIX Threads <span class="keyword">and</span> <span class="keyword">the</span> Windows API.</span><br><span class="line"></span><br><span class="line">Even <span class="keyword">after</span> a condition variable appears <span class="keyword">to</span> have been signaled <span class="keyword">from</span> a waiting thread's point <span class="keyword">of</span> view, <span class="keyword">the</span> condition <span class="keyword">that</span> was awaited may still be <span class="literal">false</span>. One <span class="keyword">of</span> <span class="keyword">the</span> reasons <span class="keyword">for</span> this <span class="keyword">is</span> a spurious wakeup; <span class="keyword">that</span> <span class="keyword">is</span>, a thread might be awoken <span class="keyword">from</span> <span class="keyword">its</span> waiting state even though no thread signaled <span class="keyword">the</span> condition variable. For correctness <span class="keyword">it</span> <span class="keyword">is</span> necessary, <span class="keyword">then</span>, <span class="keyword">to</span> verify <span class="keyword">that</span> <span class="keyword">the</span> condition <span class="keyword">is</span> indeed <span class="literal">true</span> <span class="keyword">after</span> <span class="keyword">the</span> thread has finished waiting. Because spurious wakeup can happen repeatedly, this <span class="keyword">is</span> achieved <span class="keyword">by</span> waiting inside a loop <span class="keyword">that</span> terminates when <span class="keyword">the</span> condition <span class="keyword">is</span> <span class="literal">true</span>, <span class="keyword">for</span> example:</span><br></pre></td></tr></table></figure>
<p>向POSIX Threads 和Windows API 中 条件变量判断的时候发生的。<br>一个线程可能即使没有接收到唤醒信号也有可能被唤醒，所以在使用await的时候需要在循环中。</p>
<p>虚假唤醒的原因：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">This means that <span class="keyword">when</span> you <span class="keyword">wait</span> <span class="keyword">on</span> a condition <span class="keyword">variable</span>, the <span class="keyword">wait</span> may (occasionally) <span class="keyword">return</span> <span class="keyword">when</span> no thread specifically broadcast <span class="keyword">or</span> signaled that condition <span class="keyword">variable</span>. Spurious wakeups may sound strange, but <span class="keyword">on</span> some multiprocessor systems, making condition wakeup completely predictable might substantially slow <span class="keyword">all</span> condition <span class="keyword">variable</span> operations. The race conditions that cause spurious wakeups should be considered rare</span><br></pre></td></tr></table></figure>


<p>因为在多处理系统中，如果条件唤醒完全可预测，那么会拖累所有的条件变量操作，拖累性能。并且虚假唤醒的情况是比较函件的所以不进行解决。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="built_in">join</span>() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">join</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">join</span>(<span class="keyword">long</span> <span class="built_in">millis</span>)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = <span class="built_in">millis</span> - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join的作用是等待当前线程结束。利用wait方法，主线程通过调用子线程的wait方法，来阻塞主线程，知道子线程退出实发monitor</p>
<h2 id="suspend-resume（）"><a href="#suspend-resume（）" class="headerlink" title="suspend() / resume（）"></a>suspend() / resume（）</h2><p>两个方法已经废弃：<br>原因：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">This <span class="function"><span class="keyword">method</span> <span class="title">has</span> <span class="title">been</span> <span class="title">deprecated</span>, <span class="title">as</span> <span class="title">it</span> <span class="title">is</span> <span class="title">inherently</span> <span class="title">deadlock</span>-<span class="title">prone</span></span></span><br></pre></td></tr></table></figure>
<p>容易应发死锁</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<h2 id="interrupt-interrupted-isInterrupted"><a href="#interrupt-interrupted-isInterrupted" class="headerlink" title="interrupt/interrupted/isInterrupted"></a>interrupt/interrupted/isInterrupted</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">false</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<p>interrupt用于中断一个线程。</p>
<ol>
<li>interrupt不能中断自己</li>
<li>interrupt可以中断被 wait sleep join 阻塞的线程，被中断的线程会抛出InterruptedException异常。</li>
<li>interrupt可以中断IO InterruptibleChannel  阻塞</li>
<li>interrupt可以中断java.nio.channels.Selector阻塞，会唤醒Selector</li>
</ol>
<p>interrupted 获取当前线程是否被中断，并且会清除中断状态，意味着如果连续调用两次，则后面一次肯定会发挥false.</p>
<p>isInterrupted()与interrupted()的区别是 interrupted不会清除中断状态。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>Thread 包含三个主要元素，name threadGroup target</li>
<li>run是线程要执行的函数，start为启动线程</li>
<li>stop/suspend/resume因为并发问题，已经废弃，不要在使用</li>
<li>setDeamon可以设置是否是守护线程</li>
<li>sleep休眠，但不会释放monitor锁</li>
<li>wait释放monitor锁，notify方法唤醒，会有虚假唤醒的问题，开发的时候需要注意</li>
<li>join等待线程结束</li>
<li>yield() 通知CPU放弃当前执行，是否执行其他取决于CPU调度</li>
<li>中断可以中断wait,sleep,join的线程，isInterrupted 和 interrupted的区别是是否清除中断标志。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程概念</title>
    <url>/post/31afbc55.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>并发在面试中基本可以说是必问的一个点，而线程又是并发得以实现的一个重要的点，线程无疑非常的重要，那么本章就来看看线程的基础知识。</p>
<h1 id="线程、进程、协程"><a href="#线程、进程、协程" class="headerlink" title="线程、进程、协程"></a>线程、进程、协程</h1><p>谈到线程，基本都会谈到进程，那么线程进程有都是些什么呢，都有哪些区别，什么又是协程呢？</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p>线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</strong></p>
<p>线程是比进程更轻量的执行单位，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度。</p>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ol>
<li>使用内核线程实现 1:1</li>
<li>使用用户线程实现 1:n</li>
<li>使用用户线程加轻量级进程实现 n:m</li>
</ol>
<p><strong><em>内核线程</em></strong></p>
<p>内核线程（KLT kernel-level thread）是由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器来对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核.</p>
<p><strong><em>轻量级进程(LWP):</em></strong></p>
<p>轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作.首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（UserMode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的</p>
<p>内核线程实现：<br><img src="../resource/java/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.jpg" alt=""></p>
<p>linux 采用的是内核线程的实现方式</p>
<p><strong><em>用户线程:</em></strong></p>
<p>广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程（User Thread，UT）的一种，而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</p>
<p>用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的</p>
<p>用户线程的实现方式</p>
<p><img src="../resource/java/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B.jpg" alt=""></p>
<p>混合线程实现方式：<br><img src="../resource/java/%E6%B7%B7%E5%90%88%E7%BA%BF%E7%A8%8B.jpg" alt=""></p>
<h3 id="java-线程的实现"><a href="#java-线程的实现" class="headerlink" title="java 线程的实现"></a>java 线程的实现</h3><p>JDK1.3开始，主流java虚拟机线程模型都是基于操作系统原生线程模型来实现的，也就是采用的是 1:1的内核线程模型。</p>
<p>例如 HotSpot ，他的每一个java线程都是直接映射到一个操作系统原生线程来实现的，   中间没有额外的间接结构，所以调度全权交由操作系统来决定，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</p>
<h3 id="java-线程的调度"><a href="#java-线程的调度" class="headerlink" title="java 线程的调度"></a>java 线程的调度</h3><ol>
<li>协同式线程调度</li>
<li>抢占式线程调度</li>
</ol>
<p><strong><em>协同式线程调度：</em></strong>线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去</p>
<p><strong><em>抢占式线程调度：</em></strong>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定</p>
<p><strong>Java使用的线程调度方式就是抢占式调度</strong></p>
<h3 id="线程的状态："><a href="#线程的状态：" class="headerlink" title="线程的状态："></a>线程的状态：</h3><p><img src="../resource/java/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt=""></p>
<h3 id="java线程的创建"><a href="#java线程的创建" class="headerlink" title="java线程的创建"></a>java线程的创建</h3><ol>
<li>继承自Thread</li>
<li>实现Runnable</li>
<li>使用Callable和Future</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">"hellow_world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过Runnable创建的线程!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"通过Callable创建的线程!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Callable&lt;String&gt; callable = new MyThread();</span></span><br><span class="line"><span class="comment">//FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(callable);</span></span><br><span class="line"><span class="comment">//new Thread(ft,"threadName").start();</span></span><br></pre></td></tr></table></figure>


<h2 id="协程-纤程-fiber-light-thread"><a href="#协程-纤程-fiber-light-thread" class="headerlink" title="协程(纤程) fiber light-thread"></a>协程(纤程) fiber light-thread</h2><h3 id="为什么需要协程"><a href="#为什么需要协程" class="headerlink" title="为什么需要协程"></a>为什么需要协程</h3><p>前面我们说了，java线程是1：1的内核线程的实现方式，调度方式也是抢占式调度。</p>
<p>但是操作系统的线程实现方式是为了通用性，其需要支持所有类型的并发操作。故而其线程的切换需要进行线程上下文的切换操作，对于一些IO密集型操作，其线程上下文的切换开销也是比较大的，因为线程切换需要响应系统中断，进行保存和恢复现场。</p>
<p>也就出现了协程（coroutine）.</p>
<h3 id="java的实现"><a href="#java的实现" class="headerlink" title="java的实现"></a>java的实现</h3><p>java对于协程的实现方式是 纤程(Fiber)，或者是 light weight thread。</p>
<p>light weight thread 的实现方式是在底层1:1内核线程的基础上，进行封装了轻量级线程的方式来实现，</p>
<p><img src="../resource/java/lightWeightThread.jpg" alt=""></p>
<p>黄色的部分表示的就是新的并发方式 light weight thread。 多个light weight thread 可以共用一个内核级线程</p>
<p>light weight thread 由两部分构成 </p>
<ol>
<li>Continuation  执行过程</li>
<li>Scheduler     调度器</li>
</ol>
<p>执行过程负责维护现场，调度器负责编排所有要执行的代码的执行顺序。<br>其示例如下图:</p>
<p><img src="../resource/java/Fiber%E7%A4%BA%E4%BE%8B.jpeg" alt=""></p>
<h3 id="协程为什么开销小"><a href="#协程为什么开销小" class="headerlink" title="协程为什么开销小"></a>协程为什么开销小</h3><p>要解释这个问题，我们首先要解释什么场景适合使用协程：</p>
<ol>
<li>协程将保存、恢复现场，和调度的工作从操作系统手中拿过来，那么对于一些IO密级性场景，就可以通过简单的先进先出的调度，使用完全无锁调度，调度开销变会减少。</li>
<li>协程更加的轻量，64位Linux上HotSpot的线程栈容量默认是1MB，而一个协程的栈通常在几百个字节到几KB之间。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>java目前都是基于1：1的内核线程实现抢占式调度的线程，该线程的上下文切换，调度等均交由操作系统来进行，而线程阻塞唤醒的调度，很消耗时间。于是便出现了fiber 纤程，在调度以及栈大小上进行优化，目前fibers项目是 project Loom 。 该特性预计会加入的到JVM的原生支持，并且JDK对外的api接口都会进行适配，希望JDK13的时候有望见到。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>&lt;深入理解java虚拟机&gt;</p>
</blockquote>
<blockquote>
<p><a href="https://www.youtube.com/watch?spm=ata.13261165.0.0.7e8d73b6UFWQzK&v=lIq-x_iI-kc" target="_blank" rel="noopener">light weight thread相关介绍</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发理论</title>
    <url>/post/ab0f6be5.html</url>
    <content><![CDATA[<h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p>当我们去网上搜索并发的时候，总是能看到并行，并发并行这两个概念似乎总是不分家。那么我们来看看并发并行都有些什么区别：</p>
<blockquote>
<p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.</p>
</blockquote>
<blockquote>
<p>When an application is capable of executing two tasks virtually at same time, we call it concurrent application.Though here tasks run looks like simultaneously, but essentially they MAY not</p>
</blockquote>
<blockquote>
<p>Parallelism does not require two tasks to exist. It literally physically run parts of tasks OR multiple tasks, at the same time using multi-core infrastructure of CPU, by assigning one core to each task or sub-task.<br>Parallelism requires hardware with multiple processing units, essentially. In single core CPU, you may get concurrency but NOT parallelism.</p>
</blockquote>
<p>百度是这样描述并发的<br>:在操作系统中，并发是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
<p>并行:<br>在操作系统中是指，一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生)</p>
<p>通过上面的描述，其实是可以有一些感觉建立的：</p>
<ol>
<li>并发是对于单cpu上多任务的场景来描述的，并发利用不同的CPU时间片，逻辑上是同时执行多项任务，事实的可能是多任务穿插在不同时间片上顺序执行</li>
<li>并行是有多个cpu核心，不同的任务可以在同一刻同时执行。</li>
<li>实际上对于多核cpu来说，现在的多线程也都是并行执行的。</li>
</ol>
<p><img src="../resource/java/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C.jpg" alt=""></p>
<h1 id="三大特性："><a href="#三大特性：" class="headerlink" title="三大特性："></a>三大特性：</h1><ol>
<li>原子性</li>
<li>可见性</li>
<li>顺序行</li>
</ol>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性指的是一个或者多个操作在CPU执行过程中不被中断的特性。即要不全部执行完成，要不不执行。</p>
<p>a++操作：</p>
<ol>
<li>加载a</li>
<li>+1</li>
<li>结果写入内存，赋值a</li>
</ol>
<p>a=0,如果两个线程同时执行 a++。 我们期望输出2，但是实际上<br><img src="../resource/java/%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98.jpg" alt=""><br>可能得到的结果是 1。 这便是原子性问题</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性指的是当一个线程修改了共享变量后，其他线程能够立即得到修改的值。</p>
<p>线程 1，2 共享同一个变量a, 如果1修改了2看不见，便会导致a变量值的不可预测性。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性指的是程序执行的顺序按照代码的先后顺序执行。</p>
<p>一般来说，处理器为了提高程序的的运行效率，可能会对输入代码进行优化，它不保证程序中各个操作语句的执行先后数据同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行结果的一致性。</p>
<p>如果处理器指令经过重排，单线程下指令重排会保证结果一致性，但是多线程情况下指令重排由于共享变量的存在，可能导致不可预测的结果。</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>了解完并发的基本概念，以及三大特性，我们来看看内存模型，为什么要了解系统的内存模型呢，因为并发的操作，在单核系统上实际上是多个任务穿插执行，多核系统上可能是多个cpu核心同时并行执行多任务。那么了解系统的内存模型，了解cpu，内存的交互就显得至关重要。</p>
<p>我们知道经典的冯洛伊曼体系结构如下：<br><img src="../resource/java/%E5%86%AF%E6%B4%9B%E4%BC%8A%E6%9B%BC%E4%BD%93%E7%B3%BB.png" alt=""></p>
<p>但是又由于存储器(主存)与处理器（CPU）之前的运算速度相差巨大（指数级）,故而，为了解决主存带来的耗时问题，引入了高速缓存。结构如下所示：<br><img src="../resource/java/systemMomery.jpg" alt=""></p>
<h2 id="总线锁定"><a href="#总线锁定" class="headerlink" title="总线锁定"></a>总线锁定</h2><p>现代计算机一般都是多CPU，那么多CPU核心对于主内存中同一个区域的访问就会存在冲突的问题，也就引发了原子性，可见性，一致性等多个问题，那么是如何解决的呢？</p>
<p><strong><em>总线锁:</em></strong>就是使用处理器提供的一个LOCK#信号，当一个处理器总线上输出此信号时，其它处理器的请求将被阻塞住，那么该处理器可以独占共享内存。如此多CPU的操作就变成了单cpu操作，也就没有并发问题了。</p>
<h2 id="缓存锁定和缓存一致性"><a href="#缓存锁定和缓存一致性" class="headerlink" title="缓存锁定和缓存一致性"></a>缓存锁定和缓存一致性</h2><p>由于，我们只需要保证对某个内存地址的操作是原子的即可，但是总线锁把CPU和内存之间的通信锁住了，这使得在锁定期间，其他处理器也不能操作其他内存地址的数据，所以总线锁的开销比较大。目前，处理器在某些场合下使用缓存锁来代替总线索进行优化。</p>
<p><strong><em>缓存锁</em></strong>就是指内存区域如果被缓存在处理器的缓存行中，并且在LOCK#操作期间，那么当它执行操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，其他处理器回写已被锁定的缓存行的数据时，就会使缓存无效。</p>
<h3 id="缓存一致性-MESI"><a href="#缓存一致性-MESI" class="headerlink" title="缓存一致性 MESI"></a>缓存一致性 MESI</h3><p>MESI协议(Modified,Exclusive,Share,Invlid) 用四种标志来区分缓存数据的状态，以此来决定CPU何时把缓存的数据写入到内存，何时从缓存读取数据，何时从内存读取数据。</p>
<p><strong>Modified(修改状态)</strong>:<br>当前缓存数据是有效的,数据还未同步到内存中去,通知其他缓存设置为Invlid</p>
<p><strong>Exclusive(独占状态)</strong>:<br>当前缓存有效，并且只在当前缓存有，数据与内存一致</p>
<p><strong>Share(共享状态)</strong>:<br>所有缓存公有，数据与内存一直</p>
<p><strong>Invalid(无效状态)</strong>:<br>当前缓存无效。</p>
<p>只有当缓存段处于E或M状态时，处理器才能去写它，也就是说只有这两种状态下，处理器是独占这个缓存段的。当处理器想写某个缓存段时，如果它没有独占权，它必须先发送一条“我要独占权”的请求给总线，这会通知其他处理器，把它们拥有的同一缓存段的拷贝失效（如果它们有的话）。只有在获得独占权后，处理器才能开始修改数据——并且此时，这个处理器知道，这个缓存段只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。反之，如果有其他处理器想读取这个缓存段（我们马上能知道，因为我们一直在窥探总线），独占或已修改的缓存段必须先回到“共享”状态。如果是已修改的缓存段，那么还要先把内容回写到内存中。</p>
<p><img src="../resource/java/%E7%8B%AC%E5%8D%A0%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<p>如上图所示，可以发现，在CPU1失效缓存到CPU0可以修改之间，CPU0只能处于等待状态，这就比较浪费性能了。</p>
<p><strong><em>Store Bufferes和Invalidate Queues</em></strong></p>
<p>基于缓存一致性模型，提出了Store Bufferes 存储缓存的概念。</p>
<p><strong>Store Bufferes 缓存存储</strong>，当处理器需要把修改写入缓存时，然后在写入内存这个过程时，我们处理器不需要等待了。只需要把指数据写入Store Bufferes，然后发生Invalidate消息给其它CPU，然后本CPU就可以去执行其它指令了，等到我们都收所有回复确认Invalidate Acknowledge消息，在把Store Bufferes消息写回缓存修改状态为（M），如果有其它CPU来读，就会刷新到内存，状态变为S。Store Bufferes 的作用是让 CPU 需要写的时候仅仅将其操作交给 Store Buffere，然后继续执行下去，Store Bufferes 在某个时刻就会完成一系列的同步行为。</p>
<p>Store Bufferes 存储缓存 解放了CPU的等待时间，但是如果CPU同时处理的事情比较多，需要失效的缓存数据比较多，那么久会非常占用空间，于是设计出了Invalidate Queues</p>
<p><strong>Invalidate Queues 失效队列：</strong>当别的CPU收到Invalidate消息时，把这个操作加入无效队列，然后快速返回Invalidate Acknowledge消息，让发起者做后续操作，然后Invalidate并不是马上处理，而只是加入了队列，也就是说其实不是立刻让本CPU的缓存数据失效，而是等CPU处理无效队列里的无效消息时。</p>
<p>Store Bufferes和Invalidate Queues 分别从解放本次CPU等待时间，异步话对侧失效操作两个方面对缓存一致性模型进行了优化，也就成为了下面的结构：</p>
<p><img src="../resource/java/%E7%BC%93%E5%AD%98%E9%98%9F%E5%88%97%E5%92%8C%E5%A4%B1%E6%95%88%E9%98%9F%E5%88%97.jpg" alt=""></p>
<p><strong><em>可见性问题：</em></strong></p>
<p>由于Store Buffers和Invalidate Queues的引入，导致CPU的操作变成了最终一致性，而这种最终一致性。而这种最终一致性，会导致在多核处理中，对于有依赖关系的变量修改就变的不可见了：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> foo(<span class="built_in">void</span>)&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> bar(<span class="built_in">void</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU0运行foo，CPU1运行bar。假设序列如下 ：假设cpu1之前运行过其他指令，有a的缓存，无b的缓存</p>
<ol>
<li>CPU0 要修改a ，写入Store Buffer 通知总线要独占，CPU1收到，放入Invalidate queue ,返回确认，CPU0把Store Buffer 内容写入缓存0。</li>
<li>CPU0 要修改b， cpu独占b，直接写入。改为M</li>
<li>CPU1 读取b，此时CPU0监听到，修改为S 回写内存，b==0循环结束</li>
<li>CPU1读取缓存，由于已经有缓存了，但是其缓存队列 Invalidate queue中在等待执行，其顺序没法保证，如果已经失效，能读取到 a=1 如果还没失效，那就是之前缓存中的值。</li>
</ol>
<p>也就失去了修改的可见性。</p>
<p>为了解决这个问题，底层增加了一个内存屏障（memory barrier）的指令：</p>
<p>Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，应用所有已经在存储缓存（store buffer）中的保存的指令。<br>Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先应用所有已经在失效队列中的失效操作的指令</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> foo(<span class="built_in">void</span>)&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_wmb()</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> bar(<span class="built_in">void</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    smp_rmb()</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，之前不走中的4中的问题就不在存在了，因为其a在写入之后，立刻就会执行刷新到缓存，assert(a==1)执行前，会先吧失效队列中的指令执行完毕</p>
<h2 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h2><p>系统内存模型，通过总线锁，缓存锁和缓存一致性协议来保证并发的可靠，那么java内存模型又是怎么做的呢</p>
<p><strong>由于java是跨平台的语言，所以java需要解决不同平台不同操作系统的内存访问的差异，以让java程序在各个平台下都能达到一致的访问效果。故而java需要定义一套模型，让java的并发内存访问操作不会产生歧义。</strong></p>
<p>而java内存模型就是这样的产物。java内存模型主要定义了各种变量的访问规则。其规定所有变量都必须存储在主内存(此处表示虚拟机内存的一部分）中每条线程有自己的工作内存，保存该线程使用变量的工作副本。线程对变量的所有操作都必须在工作内存中完成。如下图所示：</p>
<p><img src="../resource/java/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt=""></p>
<p>当一个线程进行更新的时候会通过线程间通信，让另一个线程从主内存中获取数据:<br><img src="../resource/java/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.jpg" alt=""></p>
<p>我们知道JMM java内存，对于是对于内存模型的抽象话管理，基础的操作都是操作系统调用去完成，故而原子性等特性都遵从于操作系统的指令级原子性，或者有更多的封装。</p>
<p>但是由于编译优化，指令级重排序等问题，会保证程序执行的顺序最终一致，对于单线程来说，没有问题，但是多线程会造成可见性，顺序性问题。</p>
<h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p><strong>java 定义了8种原子性操作</strong></p>
<ol>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。<br>并且 read&amp;load 成对出现， store&amp;write成对出现，以及一些列规则来保证基本的读取和写入的原子性。</li>
</ol>
<h3 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h3><p>java中通过定义了 volatile 关键字，来保证变量新值能立即刷新到主内存中，以及每次使用都从主内存中刷新来保证。</p>
<p>也通过 锁 synchronized 和 final 关键字 来实现。</p>
<h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>java通过定义了happen-before原则来保证有序性。通过该原则我们数据是否存在竞争，线程是否安全。</p>
<ol>
<li><strong>程序次序原则</strong>：在一个线程内，按照控制流，书写在前面的要先于后面的</li>
<li><strong>管程锁定原则</strong>：一个unlock操作先于后面对同一个锁的lock</li>
<li><strong>volatile原则</strong>：对一个volatile变量的写先于后面对这个变量的读</li>
<li><strong>线程启动原则</strong>：Thread的start()先于这个线程的所有操作</li>
<li><strong>线程终止原则</strong>：线程中所有操作都先于线程终止操作   </li>
<li><strong>线程终端原则</strong>：interrupt调用先于被中断代码检测到中断时间</li>
<li><strong>对象终结原则</strong>：对象的初始化完成先于finalize（）的开始</li>
<li><strong>传递性</strong>： a先于b  b先于c 则a先于c</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>本文首先了解了并发和并行的基本概念，然后分别通过系统内存模型，和java内存模型了解了系统内存已经java内存对于并发三大特性的处理。</p>
<p>内存模型 通过总线锁 缓存锁 缓存一致性协议 内存屏障来保障并发的可靠性</p>
<p>java内存模型通过 基础原子性操作  volatile 锁  happen-before原则来保证并发的可靠性</p>
<br/>
<br/>
<br/>
<br/>


<blockquote>
<p><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf" target="_blank" rel="noopener">http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf</a><br><a href="https://blog.51cto.com/14220760/2370118?source=dra" target="_blank" rel="noopener">https://blog.51cto.com/14220760/2370118?source=dra</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发综述</title>
    <url>/post/ebfd7e71.html</url>
    <content><![CDATA[<p><img src="../resource/java/%E5%B9%B6%E5%8F%91.png" alt=""></p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码分析</title>
    <url>/post/e74dcc0a.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>分析完成了ArrayList和HashMap两个最常用的结构，我们来看看去重集合HashSet的实现方式和源码。</p>
<h1 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a>HashSet源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">HashMap</span>&lt;E,<span class="keyword">Object</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> PRESENT = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;(Math.<span class="built_in">max</span>((<span class="built_in">int</span>) (c.<span class="built_in">size</span>()/<span class="number">.75</span>f) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 HashSet是在内部维护了一个HashMap的对象，而HashMap的数据结构我们之前就有所了解：</p>
<p><img src="../resource/java/HashMap%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数:"></a>重要函数:</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">put</span>(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong>add方法主要利用了HashMap的key不重复的特性</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">remove</span>(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong>remove也是直接调用hashmap的remove方法</p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong>iterator主要复用了HashMap的keySet的遍历方法。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>HashMap源码分析完毕之后，HashSet可以说非常简单，因为HashSet的实现是复用了HashMap的基本特性来实现的，从这里也可以看出来 HashMap对于javaer是多么的重要。 LinkedHashMap 继承自 HashMap实现排序用于lru算法，HashSet利用与HashMap的组合，实现去重集合。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap源码分析</title>
    <url>/post/19c86886.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TreeMap从字面上来说就跟树脱不了干系，既然TreeMap支持排序，那么基本就是二叉树的扩展。接下来就来看看TreeMap的使用，以及内部基础结构。</p>
<h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1    1</span></span><br><span class="line"><span class="comment">        2    1</span></span><br><span class="line"><span class="comment">        3    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">map</span>.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(key +<span class="string">"    "</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; map2 = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> compare(<span class="keyword">String</span> o1, <span class="keyword">String</span> o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(o2) -<span class="keyword">new</span> Integer(o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3    1</span></span><br><span class="line"><span class="comment">        2    1</span></span><br><span class="line"><span class="comment">        1    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    map2.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(key +<span class="string">"    "</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由实例可以知道，TreeMap是有序的hash表结构，并且支持自定义比较器Comparator进行自定义排序方式。</p>
<h1 id="TreeMap源码分析"><a href="#TreeMap源码分析" class="headerlink" title="TreeMap源码分析"></a>TreeMap源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? super K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> transient <span class="built_in">Entry</span>&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> transient <span class="built_in">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="keyword">class</span> <span class="built_in">Entry</span>&lt;K,V&gt; implements Map.<span class="built_in">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V <span class="keyword">value</span>;</span><br><span class="line">    <span class="built_in">Entry</span>&lt;K,V&gt; left;</span><br><span class="line">    <span class="built_in">Entry</span>&lt;K,V&gt; right;</span><br><span class="line">    <span class="built_in">Entry</span>&lt;K,V&gt; parent;</span><br><span class="line">    boolean color = BLACK;</span><br><span class="line">    <span class="built_in">Entry</span>(K key, V <span class="keyword">value</span>, <span class="built_in">Entry</span>&lt;K,V&gt; parent) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，可以看出来TreeMap的结构是一颗二叉树，root表示根节点，有左子树left,右子树right，父节点parent。熟悉数据结构则可以明白color=BLACK 表示这颗树是一颗红黑树。</p>
<p><img src="../resource/java/TreeMapTree.jpg" alt=""></p>
<p>红黑树的基础知识可以通过 <a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底了解红黑树</a> 进行了解</p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">//设置根节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//此处进行类型检查</span></span><br><span class="line">        compare(<span class="built_in">key</span>, <span class="built_in">key</span>); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(<span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">//cpr 不等于null，使用cpr定义的比较器</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(<span class="built_in">key</span>, t.<span class="built_in">key</span>);</span><br><span class="line">            <span class="comment">//小于放在左子树 ，否则放在右子树</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有定义比较器，则使用默认的比较器 此处进行null检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="built_in">key</span>;</span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="comment">// 循环遍历 小于放在左子树 大于放在又子树</span></span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.<span class="built_in">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到需要放的位置 设置几点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(<span class="built_in">key</span>, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">// 放置完成后进行红黑树的调整。 红黑树调整此处不做介绍。可以去看数据结构的红黑树的介绍</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>TreeMap进行插入数据节点的时候，会进行类型检查和空指针检查</li>
<li>如果未定义比较方法，会使用默认的比较方法</li>
<li>与而插入插入一直，如果小于则查找左子树，如果大于则查找右子树</li>
<li>节点插入树中后会进行红黑树的平衡调整。</li>
</ol>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">       <span class="comment">//使用自定义的比较器获取值</span></span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(<span class="built_in">key</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认比较器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="built_in">key</span>;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">//遍历 二叉树查找过程，小于当前节点找左子树，大于当前节点找右子树</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> cmp = k.compareTo(p.<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义比较器比较</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntryUsingComparator(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        K k = (K) <span class="built_in">key</span>;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历 二叉树查找过程，小于当前节点找左子树，大于当前节点找右子树</span></span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> cmp = cpr.compare(k, p.<span class="built_in">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>说明:</strong> 获取key对应的元素相对来说比较简单，就是二叉查找树的查找过程，如果小于当前节点则找左子树，大于当前节点找右子树。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V remove(Object key) &#123;</span><br><span class="line">    <span class="comment">// 找到当前节点</span></span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="built_in">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="literal">void</span> deleteEntry(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class="line">    <span class="comment">// point to successor.</span></span><br><span class="line">    <span class="comment">//左右子节点都为null 则找后继节点与p交换</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="built_in">null</span> &amp;&amp; p.right != <span class="built_in">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有子树，则子树需要与父节点关联</span></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="built_in">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="built_in">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除掉p，链接p的parent 和子树</span></span><br><span class="line">        <span class="comment">// Link replacement to parent</span></span><br><span class="line">        replacement.<span class="keyword">parent</span> = p.<span class="keyword">parent</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="keyword">parent</span> == <span class="built_in">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.left)</span><br><span class="line">            p.<span class="keyword">parent</span>.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.<span class="keyword">parent</span>.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.<span class="keyword">parent</span> = <span class="built_in">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">        <span class="comment">// 红黑树调整</span></span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.<span class="keyword">parent</span> == <span class="built_in">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">        root = <span class="built_in">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="keyword">parent</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.left)</span><br><span class="line">                p.<span class="keyword">parent</span>.left = <span class="built_in">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.right)</span><br><span class="line">                p.<span class="keyword">parent</span>.right = <span class="built_in">null</span>;</span><br><span class="line">            p.<span class="keyword">parent</span> = <span class="built_in">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the successor of the specified Entry, or null if no such.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 找二叉查找树t后继节点</span></span><br><span class="line">static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="built_in">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">    <span class="comment">//找右子树的最小值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="built_in">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="built_in">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.<span class="keyword">parent</span>;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="comment">// 如果t右子树是空并且其是父节点右节点，找这颗右子树的根节点。</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="built_in">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.<span class="keyword">parent</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>删除的操作较为复杂，由于删除操作会进行树的修正，和红黑树的平衡调整，均为红黑树的基本操作，可以通过数据结构红黑树章节来了解。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>红黑树的使用起来比较简单，内部实现说简单也简单，复杂也复杂，主要复杂的点在红黑树的数据结构维护上，排除红黑树的维护操作，TreeMap的结构相对来说比较简单，其主要是利用二叉查找树的特性，通过比较函数来维护一颗二叉查找树，通过二叉查找树来进行排序。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap源码分析</title>
    <url>/post/75655826.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>LinkedHashMap是一种可以有序访问的hash表，其可以按照<strong>插入顺序</strong>或者<strong>访问顺序</strong> 进行排序输出。具体如下，LinkedHashMap按照顺序放入了key为1，2，3的数据，然后遍历输出。插入顺序输出1，2，3.访问顺序会将按照访问次序倒排输出，最近访问的放在最后。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1    1</span></span><br><span class="line"><span class="comment">        2    1</span></span><br><span class="line"><span class="comment">        3    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">map</span>.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(key +<span class="string">"    "</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; map2 = <span class="keyword">new</span> LinkedHashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;(<span class="number">16</span>,<span class="number">0.75</span>,<span class="literal">true</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">get</span>(<span class="string">"2"</span>);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1    1</span></span><br><span class="line"><span class="comment">        3    1</span></span><br><span class="line"><span class="comment">        2    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">map</span>.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(key +<span class="string">"    "</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>那么这种结构有什么作用呢？最近使用的放到最后，我们可以很容易的想到一个东西就是LRU,最近最少使用淘汰算法.LinkedListHashMap的按照访问顺序排序的特点刚好符合LRU所需。那么就可以使用LinkedHashMap来实现一个本地的LRU算法。</p>
<h1 id="LinkedHashMap源码分析"><a href="#LinkedHashMap源码分析" class="headerlink" title="LinkedHashMap源码分析"></a>LinkedHashMap源码分析</h1><h2 id="数据结构是一起的基础"><a href="#数据结构是一起的基础" class="headerlink" title="数据结构是一起的基础"></a>数据结构是一起的基础</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap&lt;K</span>,<span class="title">V&gt;</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap&lt;K</span>,<span class="title">V&gt;</span></span></span><br><span class="line"><span class="class">    <span class="title">implements</span> <span class="title">Map&lt;K</span>,<span class="title">V&gt;</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; before, after;</span><br><span class="line">    <span class="type">Entry</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> value, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，LinkedHashMap继承自HashMap,基本机构相同，只是Node节点进行了扩展，增加了before,after指针构建一个双向链表。</p>
<p><img src="../resource/java/LinkedHashMap.jpg" alt=""></p>
<p>其在hashMap的结构基础上增加了用于排序使用的双向链表。故而其基本结构为 数组+链表+红黑树+双向链表</p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><p>不知你是否注意过，在我们进行hashMap源码分析的时候，在putVal,replace，merge等方法的时候，经常出现两个方法 afterNodeAccess和afterNodeInsertion方法，在remove的时候调用了afterNodeRemoval方法，而这三个方法便是实现LinkedHashMap顺序的基础。<br><img src="../resource/java/hashMapAfterAccess.jpg" alt=""></p>
<h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess"></a>afterNodeAccess</h3><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    //只有按照访问顺序排序的时候才更新顺序</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (<span class="attr">last</span> = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; <span class="attr">p</span> =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="attr">b</span> = p.before, <span class="attr">a</span> = p.after;</span><br><span class="line">        //将e的后续设置为<span class="literal">null</span></span><br><span class="line">        p.<span class="attr">after</span> = <span class="literal">null</span>;</span><br><span class="line">        //下面的ifelse相当于解除e的前后关系</span><br><span class="line">        //如果前序节点为<span class="literal">null</span>则设置其为首节点</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">b</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">head</span> = a;</span><br><span class="line">        //否则e的前序节点的后续设置为e原本的后续</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.<span class="attr">after</span> = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.<span class="attr">before</span> = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="attr">last</span> = b;</span><br><span class="line">        //last为<span class="literal">null</span>的话 设置last为p 否则吧原最后节点设置为p</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">last</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">head</span> = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.<span class="attr">before</span> = last;</span><br><span class="line">            last.<span class="attr">after</span> = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">tail</span> = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/AccessChange.jpg" alt=""></p>
<h3 id="afterNodeRemoval"><a href="#afterNodeRemoval" class="headerlink" title="afterNodeRemoval"></a>afterNodeRemoval</h3><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; <span class="attr">p</span> =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="attr">b</span> = p.before, <span class="attr">a</span> = p.after;</span><br><span class="line">    //删除e的前后指针</span><br><span class="line">    p.<span class="attr">before</span> = p.<span class="attr">after</span> = <span class="literal">null</span>;</span><br><span class="line">    //重新设置指向e的指正</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">b</span> == <span class="literal">null</span>)</span><br><span class="line">        <span class="attr">head</span> = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.<span class="attr">after</span> = a;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">a</span> == <span class="literal">null</span>)</span><br><span class="line">        <span class="attr">tail</span> = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.<span class="attr">before</span> = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion"></a>afterNodeInsertion</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly <span class="built_in">remove</span> eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; <span class="built_in">first</span>;</span><br><span class="line">    //removeEldestEntry 默认<span class="literal">false</span> </span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (<span class="built_in">first</span> = head) != null &amp;&amp; removeEldestEntry(<span class="built_in">first</span>)) &#123;</span><br><span class="line">        K <span class="built_in">key</span> = <span class="built_in">first</span>.<span class="built_in">key</span>;</span><br><span class="line">        removeNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, null, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>该函数为LRU提供了基础函数支持，hashMap在put的时候会调用afterNodeInsertion，如果removeEldestEntry返回true，则在put的时候会删除最老的节点。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>如果是按照访问顺序则get获取之后需要调用afterNodeAccess进行顺序更新。</p>
<h3 id="newNode-amp-LinkedNodeLast"><a href="#newNode-amp-LinkedNodeLast" class="headerlink" title="newNode&amp;LinkedNodeLast"></a>newNode&amp;LinkedNodeLast</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Node&lt;K,V&gt; <span class="keyword">new</span><span class="constructor">Node(<span class="params">int</span> <span class="params">hash</span>, K <span class="params">key</span>, V <span class="params">value</span>, Node&lt;K,V&gt; <span class="params">e</span>)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    link<span class="constructor">NodeLast(<span class="params">p</span>)</span>;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> void link<span class="constructor">NodeLast(LinkedHashMap.Entry&lt;K,V&gt; <span class="params">p</span>)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last<span class="operator"> == </span>null)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>LinkedHashMap重写了hashMap的newNode方法，在创建新的节点的时候，会将节点的before和after指针与tail节点关联上。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>LinkedHashMap 集成自HashMap，基础操作与HashMap相同，LinkedHashMap的实现得益于HashMap在基础操作中的埋点。也就是：afterNodeAccess，afterNodeInsertion和afterNodeRemoval方法。最简单的LUR只需要继承自LinkedListHashMap，重写removeEldestEntry即可。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/post/9749aebd.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>实话说，HashMap作为集合中比较经典的一个类，其在面试中经常会被问到：例如</p>
<ol>
<li>说说HashMap的原理(o(╥﹏╥)o真nm笼统)</li>
<li>HashMap是怎么扩容的呢？</li>
<li>传统HashMap(jdk1.7)的hashMap有什么缺点，如何对其进行优化呢(红黑树)？</li>
<li>那么又了解在实际情况下会进化到红黑树的比例吗？</li>
<li>HashMap是线程安全的吗？不是应该用啥呢….巴拉巴拉 能接一串问题。</li>
</ol>
<p>瞬间就有了继续下去的动力了，💰💰💰💰</p>
<h2 id="为啥需要HashMap呢？"><a href="#为啥需要HashMap呢？" class="headerlink" title="为啥需要HashMap呢？"></a>为啥需要HashMap呢？</h2><p>前面分析了线性表的两种典型结构，ArrayList随机访问线性表，LinkedList顺序访问线性表。但是其都一个缺陷，就是如果需要获取一个对象（比如找叫小波的给我两块钱），那么我就需要遍历这个线性表，先找到这个张三，然后在从他兜里偷两块钱，其时间复杂度无疑是O(n)的</p>
<p>这种情况就需要哈希表出马了，所谓的哈希表，就是k-v结构，例子中k就是小波的名字，v就是小波，那么我找小波就可以通过这种kv结构在O(1)d时间下获取到小波了。性能无疑是非常优越的。</p>
<h2 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h2><p>所谓的哈希表，就是将一个对象，通过一个函数计算出来了这个对象应该在数组中元素的位置那么我们就可以通过数组在O(1)时间复杂度内获取这个对象。而这个函数就是所谓的哈希函数，这个数组和哈希函数整体构成了哈希表的基础组成。</p>
<p><img src="../resource/java/%E5%93%88%E5%B8%8C%E8%A1%A8.jpg" alt=""></p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>什么是hash冲突呢?<br>哈希函数是哈希表中的一个重要组成，但是字符串是无穷的，很难说有一个hash函数生成的key与一个对象能够一对一关联上，也就是说，可能出现两个不同的对象生成同一个key的情况，这就是hash冲突。有了问题就要解决问题，那么如何解决hash冲突呢：</p>
<ol>
<li>开放地址法。冲突了就继续下一个</li>
<li>在hash，冲突了就运行二次hash</li>
<li>拉链法，冲突了就在数组的那个位置在拉个链表出来。</li>
</ol>
<p><img src="../resource/java/hash%E5%86%B2%E7%AA%81.jpg" alt=""></p>
<h1 id="hashMap源码分析"><a href="#hashMap源码分析" class="headerlink" title="hashMap源码分析"></a>hashMap源码分析</h1><p>说完哈希表这种数据结构，以及hash冲突的解决办法。我们来看看HashMap的实现。</p>
<h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"><span class="comment">// 单个元素结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> Node&lt;K,V&gt; <span class="keyword">implements</span> Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// hash值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="keyword">next</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述源码中，我们可以发现，hashMap底层是有数组来做基础支撑，与我们前面说的哈希表一致。hashMap中含有下一个节点的指针，采用的是拉链法解决冲突。基础结构如下图左侧所示：</p>
<p><img src="../resource/java/HashMap%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>左侧便是jdk1.7的结构，有图是jdk1.8进行的优化，增加了红黑树的结构。</p>
<h2 id="增删改查基础操作"><a href="#增删改查基础操作" class="headerlink" title="增删改查基础操作"></a>增删改查基础操作</h2><h3 id="查询-get"><a href="#查询-get" class="headerlink" title="查询 get()"></a>查询 get()</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> h;</span><br><span class="line">    <span class="comment">//key==null 则直接取0，否则hash()取key的hashCode 和 key的hashCode右移16位取异或。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取k = key的 节点</span></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//先hash key 然后通过hash值去获取</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="built_in">int</span> hash, <span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">//拿hash 与数组长度 n-1 取与操作得到的值 就是索引</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="built_in">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果tab[index]的第一个节点hash值相等，并且equals或者为同一个对象，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//如果有下一个节点 则继续向下一个节点找hash or equals的，知道找到或者未找到。</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="built_in">key</span>);</span><br><span class="line">            do &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hash()哈数</strong><br><img src="../resource/java/hashIndex.jpg" alt=""></p>
<p>hash函数的获取方式: 通过key获取key的hashCode。高16位保持不变，低16位于高16位异或的结果作为低16位。</p>
<p><strong>index获取</strong></p>
<p>index是又hash()值与数组大小n-1做 &amp; and运算的结果。为什么这样操作。 首先，这里给出一个信息 HashMap的大小都是2^n次方（稍后变能看到）。那么n-1的二进制变全部都是1， n-1 做and运算，就想当与hash()对size取模。</p>
<p><strong>get</strong><br><img src="../resource/java/hashMapget.jpg" alt=""></p>
<h3 id="增加-修改-put"><a href="#增加-修改-put" class="headerlink" title="增加/修改 put()"></a>增加/修改 put()</h3><details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置k-v</span></span><br><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,</span><br><span class="line">            <span class="built_in">boolean</span> evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果table =null 空 则进行resize扩缩容处理</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果index索引处为null，表示没有发生hash冲突，直接设置值</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 第一个节点就是要找的key，e=p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 第一个节点是红黑树，则从红黑树中找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="built_in">key</span>, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历后面的链表，找到e</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//此处如果链表长度大于阈值，则会进行链表转红黑树处理</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了节点，并且不为空，如果是替换模式 put是，则替换，返回旧节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果大小大于阈值，扩缩容</span></span><br><span class="line">    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<br/>

<p><strong>说明：</strong></p>
<p>通过上面的代码，我们了解到</p>
<ol>
<li>hashMap的put如果存在，则会替换旧值</li>
<li>hashMap阈值则会扩容处理</li>
<li>如果链表长度大于阈值，则会进行链表转红黑树处理。</li>
</ol>
<p>那么：</p>
<ol>
<li>hashMap链表转红黑树的阈值是多少呢</li>
<li>hashMap扩容是怎么进行扩容的呢。</li>
<li>hashMap扩缩容阈值是怎么确定的呢</li>
</ol>
<p><strong><em>1.hashMap链表转红黑树阈值：</em></strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>The bin count threshold for using </span>a<span class="markdown"> tree rather than list for </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>bin.  Bins </span>are<span class="markdown"> converted to trees when adding </span>an<span class="markdown"> element to </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>bin with at least this many nodes. The value must be greater</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>than 2 and </span>should<span class="markdown"> be at least 8 to mesh with assumptions in</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>tree removal about conversion back to plain bins upon</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>shrinkage.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>The bin count threshold for untreeifying </span>a<span class="markdown"> (split) bin during </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>most 6 to mesh with shrinkage detection under removal.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>当链表结构长度超过8 的时候会转化为红黑树，当冲突节点长度小于6的时候，会退化为链表。</p>
<p><strong><em>3.hashMap扩容是怎么进行扩容的呢。</em></strong></p>
<p>来看看扩容的代码:</p>
<br/>
<br/>

<details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">public</span> HashMap() &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || <span class="keyword">Float</span>.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 旧的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧的数组长度为旧数组容量 cap</span></span><br><span class="line">    int oldCap = (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : <span class="type">oldTab</span>.length;</span><br><span class="line">    <span class="comment">// 旧阈值为0 如果是new HashMap();</span></span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新容量 新阈值初始为0</span></span><br><span class="line">    int <span class="keyword">new</span><span class="type">Cap</span>, <span class="keyword">new</span><span class="type">Thr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 旧容量有值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧容量已经大于1&gt;&gt;30,则不再进行之后的扩容，直接阈值设置为最大值，返回旧数组。</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容，数组扩容为原来2倍，阈值也变更为原来阈值的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">new</span><span class="type">Cap</span> = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="keyword">new</span><span class="type">Thr</span> = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果容量为0 ，但是阈值有值，第二种构造函数创建，则容量设置为旧的阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;          </span><br><span class="line">        <span class="comment">//都没初始化，则初始化 容量为16 阈值为16*0.75 12    </span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的阈值没有初始化，也就是 oldThr&gt;0的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Thr</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//初始化为 newCap*0.75</span></span><br><span class="line">        float ft = (float)<span class="keyword">new</span><span class="type">Cap</span> * loadFactor;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (<span class="keyword">new</span><span class="type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : <span class="type">Integer</span>.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置阈值</span></span><br><span class="line">    threshold = <span class="keyword">new</span><span class="type">Thr</span>;</span><br><span class="line">    <span class="comment">// 设置新数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">new</span><span class="type">Tab</span> = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="type">Node</span>[<span class="keyword">new</span><span class="type">Cap</span>];</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">    <span class="comment">//如果旧数组不为null，需要数据迁移，为空可以直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧链表中所有元素进行数据迁移</span></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//为null的节点不处理</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//先把旧节点位置的数据清空</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//如果当前位置只有一个元素，则直接设置到新位置处</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                   <span class="comment">// 新位置的计算重新取hash与大小取模</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">Tab</span>[e.hash &amp; (<span class="keyword">new</span><span class="type">Cap</span> - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, <span class="keyword">new</span><span class="type">Tab</span>, j, oldCap);</span><br><span class="line">                <span class="comment">// 如果是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//遍历链表所有节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//分为两种情况 1. 当前hash超过了旧容量，2 当前哈希没有超过就容量</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 没超过 则放入loTail</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//超过了，则放入hitail</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 处理loTail  改链表位置不变</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理hiTail 该链表位置变为 原oldCap+j</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<br/>

<p>可以发现：</p>
<ol>
<li>hashMap中数组最大容量是 1&gt;&gt;30</li>
<li>hashMap的table扩容是左移一位，扩容为原来的两倍容量</li>
<li>扩容后的处理，扩容后元素需要迁移，由于hashMap的处理中，扩容为原来的两倍，初始化的时候也是2的n次方这种，所以扩容后节点的hash定位index的时候只有 原位置，和j+oldCap这两种。</li>
</ol>
<p>设置容量的初始化: 巧妙的构思将 n之后的位数全部设置为1，然后+1取2的n次方的整数。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">static final <span class="built_in">int</span> tableSizeFor(<span class="built_in">int</span> cap) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    return (<span class="built_in">n</span> &lt; <span class="number">0</span>) ? <span class="number">1</span> <span class="symbol">:</span> (<span class="built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="symbol">:</span> <span class="built_in">n</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../resource/java/hashMapResize.jpg" alt=""></p>
<p><strong><em>为什么hashMap内部的table要设置为2的n次方倍呢？</em></strong></p>
<ol>
<li>hash映射到数组中需要以取模的方式来进行</li>
<li>取模的操作可以映射到 (n-1) &amp; k 上，</li>
<li>如果n为2的n次方，那么n-1二进制上全部为1，那么与k取and运算的时候，k&lt;=n-1则为k,k&gt;n的时候 高位被舍弃</li>
<li>2的n次方的时候，扩容后舍弃的高位还原，那么元素移动的时候就可以轻易计算出来移动后的位置。</li>
</ol>
<p><strong><em>3.hashMap扩缩容阈值是怎么确定的呢</em></strong></p>
<p>从上述的扩容操作中，我们可以知道，扩容阈值始终为容量的 0.75 也就是设置的扩容因子 loadFactory</p>
<h3 id="删除-remove"><a href="#删除-remove" class="headerlink" title="删除 remove()"></a>删除 remove()</h3><details>
<summary>View Code</summary>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, <span class="literal">false</span>, <span class="literal">true</span>)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                            boolean matchValue, boolean movable) &#123;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab; <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; p; int n, index;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != null) &#123;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; <span class="keyword">node</span> <span class="title">= null</span>, e; K k; V v;</span><br><span class="line">        //找到需要删除的节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">node</span> <span class="title">= p</span>;</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= ((TreeNode</span><span class="tag">&lt;K,V&gt;</span>)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                //循环链表找到需要的节点</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        <span class="keyword">node</span> <span class="title">= e</span>;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到节点 删除掉该节点。</span><br><span class="line">        if (<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; (!matchValue || (v = <span class="keyword">node</span>.<span class="title">value</span>) == value ||</span><br><span class="line">                                (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (<span class="keyword">node</span> <span class="title">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode<span class="tag">&lt;K,V&gt;</span>)<span class="keyword">node</span><span class="title">).removeTreeNode</span>(this, tab, movable);</span><br><span class="line">            else if (<span class="keyword">node</span> <span class="title">== p</span>)</span><br><span class="line">                tab[index] = <span class="keyword">node</span>.<span class="title">next</span>;</span><br><span class="line">            else</span><br><span class="line">                p.next = <span class="keyword">node</span>.<span class="title">next</span>;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">            return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">    return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<br/>
<br/>

<p><strong>说明：</strong><br>删除的操作比较简单，找到节点之后直接移除掉节点就可以了。</p>
<h1 id="使用hashmap需要注意"><a href="#使用hashmap需要注意" class="headerlink" title="使用hashmap需要注意"></a>使用hashmap需要注意</h1><ol>
<li>hashMap是非线程安全的</li>
<li>扩容的操作会遍历所有的元素，并且当元素&gt;0.75cap的时候就会进行扩容，所以在使用的时候，如果能预估容量，最好可以直接设定hashMap的容量，避免扩容处理</li>
<li>equals重写，hashCode一定要进行重写，否则可能导致equals是相同的但是hashCode没有重写导致不同 。因为equals相同，所以我们认为两个对象是一个。但是hashCode不同，会导致其路由到不同的index上，所以如果通过a是找不到我们认为相同的b的。</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>本文首先介绍了哈希表的相关知识，然后通过hashMap的源码，了解了hashMap内部结构和扩容等相关知识。通过上述的分析，我们对于hashMap有了更深刻的理解。但是依旧有很多地方没有涉及，例如红黑树内部的操作，序列化等等操作。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>LinedList源码分析</title>
    <url>/post/2528e072.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>如果说ArrayList是随机访问的典型结构，那LinkedList就是典型的顺序访问结构。</p>
<p>在ArrayList的源码分析中我们提到，ArrayList的出现是为了弥补数组大小需要自我管理，避免数组越界等问题，提供了自动扩容的特性，以及数组插入元素删除元素的元素移动管理等等。</p>
<p>那么LinkedList相比于ArrayList又具有哪些优点或者缺点呢？让我们先看看LinkedList的数据结构在来回答这个问题。 </p>
<h1 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><details>

<summary>view code</summary>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">//首节点</span><br><span class="line">transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; first;</span><br><span class="line">//尾节点</span><br><span class="line">transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; last;</span><br><span class="line"></span><br><span class="line">private static class <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; &#123;</span><br><span class="line">   //元素值</span><br><span class="line">    E item; </span><br><span class="line">    //下一个节点</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next;</span><br><span class="line">    //前一个节点</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Node</span><span class="title">(Node</span><span class="tag">&lt;E&gt;</span> prev, E element, <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p>通过上述源码可以发现，LinkedList内部的结构就如同下图所示的双向链表</p>
<p><img src="../resource/java/LinkedList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>如果所示，在LinkedList的内部维护了一个双向列表，并且分别使用first和last指针指向了双向链表的头部和尾部，如此，便可以从头开始，或者从尾部开始进行查找。 </p>
<p><strong><em>LinkedList的优缺点:</em></strong></p>
<p>既然linkedList是以链表为基础结构的，那边链表的优缺点LinkedList也基本具备。<br>优点： </p>
<ol>
<li>插入删除操作仅仅需要修改对应指针，不在需要移动元素操作。 </li>
<li>大小可无限扩展和缩减，无需进行扩容的相关操作。</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法进行随机访问，需要访问某个位置的节点，只能从头开始遍历。</li>
</ol>
<p>链表的基础操作其实相当麻烦，需要插入一个元素的时候，需要修改前一个节点指针后一个节点指针，那么LinkedList作为链表的封装，又提供了哪些基础函数可以使用呢？</p>
<h2 id="LinkedList重要函数"><a href="#LinkedList重要函数" class="headerlink" title="LinkedList重要函数"></a>LinkedList重要函数</h2><h3 id="link-amp-amp-unLink-方法"><a href="#link-amp-amp-unLink-方法" class="headerlink" title="link* &amp;&amp; unLink* 方法"></a>link* &amp;&amp; unLink* 方法</h3><h4 id="linkFirst-amp-amp-unlinkFirst"><a href="#linkFirst-amp-amp-unlinkFirst" class="headerlink" title="linkFirst &amp;&amp; unlinkFirst"></a>linkFirst &amp;&amp; unlinkFirst</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置e为第一个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> linkFirst(E e) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//设置首个节点为e</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//之前的首节点为null，表示改链表之前未null</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//设置last节点也为e</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否者设置之前的节点的前驱为e</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="keyword">size</span>++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定节点前的所有节点</span></span><br><span class="line"><span class="keyword">private</span> E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; <span class="keyword">next</span> = f.<span class="keyword">next</span>;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.<span class="keyword">next</span> = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//指定节点后的节点设置为首节点</span></span><br><span class="line">    first = <span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="comment">//指定节点后的节点前驱节点设置为null</span></span><br><span class="line">        <span class="keyword">next</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">size</span>--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong><br>上面两个函数，为其他函数例如 addFirst等函数提供了基础操作，主要作用是链表头部插入元素，和链表头部删除元素。</p>
<p>linkFirst:</p>
<p><img src="../resource/java/linkFirst.jpg" alt=""></p>
<p>unlinkFirst:<br><img src="../resource/java/unlinkFirst.jpg" alt=""></p>
<h4 id="剩余link-amp-amp-unlink-函数"><a href="#剩余link-amp-amp-unlink-函数" class="headerlink" title="剩余link* &amp;&amp; unlink* 函数"></a>剩余link* &amp;&amp; unlink* 函数</h4><details>
<summary>view code</summary>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置e为尾节点，为add提供服务</span></span><br><span class="line"><span class="keyword">void</span> linkLast(E e) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.<span class="keyword">next</span> = newNode;</span><br><span class="line">    <span class="keyword">size</span>++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在特定节点前插入节点</span></span><br><span class="line"><span class="keyword">void</span> linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.<span class="keyword">next</span> = newNode;</span><br><span class="line">    <span class="keyword">size</span>++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点后所有节点 用于删除尾节点等</span></span><br><span class="line"><span class="keyword">private</span> E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">size</span>--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除特定节点</span></span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; <span class="keyword">next</span> = x.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = <span class="keyword">next</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>.prev = prev;</span><br><span class="line">        x.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">size</span>--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明：</strong><br>上述所有的link，unlink操作，包含了对于一个链表的最基本插入节点和删除节点操作，提供了对于首、尾、特定节点的插入删除操作的封装，以共用并且简化其他api的复杂度。</p>
<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">Node&lt;E&gt; node(int <span class="meta">index</span>) &#123;</span><br><span class="line">  //优化方案，如果<span class="meta">index</span>在前半部分从前开始搜索，否则从尾节点开始搜索，属于空间换时间的思路</span><br><span class="line">  <span class="meta">if</span> (<span class="meta">index</span> &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">      Node&lt;E&gt; <span class="meta">x</span> = first;</span><br><span class="line">      for (int i = 0; i &lt; <span class="meta">index</span>; i++)</span><br><span class="line">          <span class="meta">x</span> = <span class="meta">x</span>.next;</span><br><span class="line">      <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">  &#125; <span class="meta">else</span> &#123;</span><br><span class="line">    //从尾节点开始搜索</span><br><span class="line">      Node&lt;E&gt; <span class="meta">x</span> = last;</span><br><span class="line">      for (int i = size - 1; i &gt; <span class="meta">index</span>; i--)</span><br><span class="line">          <span class="meta">x</span> = <span class="meta">x</span>.prev;</span><br><span class="line">      <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong><br>node函数，提供了一个搜索特定位置节点的方法，该方法为add(1,e)提供了基础，插入特定位置某个特定元素提供了基础方法</p>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">  link<span class="constructor">Last(<span class="params">e</span>)</span>;</span><br><span class="line">  return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void add<span class="constructor">First(E <span class="params">e</span>)</span> &#123;</span><br><span class="line">  link<span class="constructor">First(<span class="params">e</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void add<span class="constructor">Last(E <span class="params">e</span>)</span> &#123;</span><br><span class="line">  link<span class="constructor">Last(<span class="params">e</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void add(<span class="built_in">int</span> index, E element) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index<span class="operator"> == </span>size)</span><br><span class="line">      link<span class="constructor">Last(<span class="params">element</span>)</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      link<span class="constructor">Before(<span class="params">element</span>, <span class="params">node</span>(<span class="params">index</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> link* 函数上述已经描述过了，add函数均是调用link*还是来实现插入元素的操作。</p>
<h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><details>
<summary>view code</summary>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Inserts all of </span>the<span class="markdown"> elements in </span>the<span class="markdown"> specified collection into this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>list, starting at </span>the<span class="markdown"> specified position.  Shifts </span>the<span class="markdown"> element</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>currently at that position (if any) and any subsequent elements to</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>the<span class="markdown"> right (increases their indices).  The new elements </span>will<span class="markdown"> appear</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>in </span>the<span class="markdown"> list in </span>the<span class="markdown"> order that </span>they<span class="markdown"> </span>are<span class="markdown"> returned by </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>specified collection's iterator.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param index index at which to insert </span>the<span class="markdown"> first element</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*              </span>from </span>the<span class="markdown"> specified collection</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param c collection containing elements to be added to this list</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@return &#123;@code true&#125; if this list changed as </span>a<span class="markdown"> result of </span>the<span class="markdown"> call</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@throws NullPointerException if </span>the<span class="markdown"> specified collection is null</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*/</span></span></span><br><span class="line">public boolean addAll(<span class="built_in">int</span> index, Collection&lt;? <span class="keyword">extends</span> E&gt; c) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">//将集合转化为数组</span></span><br><span class="line">    <span class="built_in">Object</span>[] a = c.toArray();</span><br><span class="line">    <span class="built_in">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 找到index的节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组 将集合插入到index节点后面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">Object</span> o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置尾节点 或者后面的节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明：</strong> </p>
<p>addAll()函数中，有一个很有意思的点，就是 <strong>Object[] a = c.toArray();</strong> 为什么插入集合元素的时候需要先把集合转化为数组呢？</p>
<p>查看addAll的注释解释，发现也并没有说明这个事情，那么我们去看下toArray()方法是否会有这个解释呢？</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Returns an<span class="built_in"> array </span>containing all of the elements in this collection.</span><br><span class="line">  * If this collection makes any guarantees as to what order its elements</span><br><span class="line">  * are returned by its iterator, this method must<span class="built_in"> return </span>the elements in</span><br><span class="line">  * the same order.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;The returned<span class="built_in"> array </span>will be <span class="string">"safe"</span> in that no references to it are</span><br><span class="line">  * maintained by this collection.  (In other words, this method must</span><br><span class="line">  * allocate a<span class="built_in"> new </span>array even<span class="built_in"> if </span>this collection is backed by an array).</span><br><span class="line">  * The caller is thus free to modify the returned array.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;This method acts as<span class="keyword"> bridge</span> between<span class="built_in"> array-based </span>and collection-based</span><br><span class="line">  * APIs.</span><br><span class="line">  *</span><br><span class="line">  * @return an<span class="built_in"> array </span>containing all of the elements in this collection</span><br><span class="line">  */</span><br><span class="line">Object[] toArray();</span><br></pre></td></tr></table></figure>

<p>根据注释的解释我们可以发现：</p>
<p><strong><em>Collection.toArray()方法的定义上，是提供一个安全的方法，是的获取到的数组可以被自由的修改或者是删除元素,而不会影响到原本的集合</em></strong></p>
<p><strong><em>注意：对于Collection.toArray()进行实现的时候，请务必遵循改原则</em></strong></p>
<p>那么我们在来看一下LinkedList的toArray()方法:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span>[] toArray() &#123;</span><br><span class="line">  <span class="keyword">Object</span>[] result = <span class="keyword">new</span> <span class="keyword">Object</span>[<span class="built_in">size</span>];</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">      result[i++] = x.item;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的我们发现一个事情，就是如果你对这个数组进行了增加删除修改，是不会反应到集合的。但是这个safe是不会包含对象的safe，也就是 <strong><em>集合的对象和数组的对象还是一个对象 如果我们修改了数组中对象的属性，那么原集合中也会有体现</em></strong></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">  <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">unlinkFirst</span><span class="params">(f)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">unlinkLast</span><span class="params">(l)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> 与add类似，remove也是基于link* 函数和node函数进行的封装。<br>并且从上述操作中我们可以发现，删除一个特定位置的节点，对于LinkedList来说时间复杂度为O(n).</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> E <span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">  checkElementIndex(<span class="keyword">index</span>);</span><br><span class="line">  <span class="keyword">return</span> node(<span class="keyword">index</span>).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过上面的增加，删除，查询，我们可以发现对于LinkedList或者说对于链表来说，基础操作都是基于link*  unlink*  node()函数进行的，也就是节点前后添加元素，节点前后删除元素的指针操作，以及查找指定位置元素这个三个基本操作进行的。</p>
<h1 id="额外特性，题外话"><a href="#额外特性，题外话" class="headerlink" title="额外特性，题外话"></a>额外特性，题外话</h1><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function">E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>由于LinkedList采用的双链表的实现方式，add 和 remove 头尾节点非常的方便，并且耗时为O(1)，时间复杂度极低，故而LinkedList同样还可以作为栈或者队列来使用， pop push 操作构成了先进后出的栈结构， poll add 变成了先进先出的队列结构。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/post/3fb8877a.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><!-- 为什么需要ArrayList，ArrayList 解决了什么问题? -->

<p>在进入源码分析前，先让我们想一个问题：</p>
<p><em>ArrayList作为一个随机访问(RandomAccess)的类，其基本操作几乎与数组一致，但是对于任何一门计算机语言来说，数组基本都是内置的基础结构，那么既然有了数组，为什么还需要ArrayList这样的数据结构呢？</em></p>
<!-- 因为自动扩容 -->

<p>从ArrayList的注释的第一句话，我们就可以找到上面问题的答案，那就是 </p>
<blockquote>
<p>Resizable-array implementation of the List interface</p>
</blockquote>
<p><strong><em>Resizable-array 大小可调整 即自动扩容</em></strong> </p>
<p>数组作为一个基本的结构，其操作是非常简单的，但是其缺点也是非常明显的，那就是数组的大小是最开始就申请好的，一旦数据数目超过了数组大小，就会有数组越界风险。 那么对于一些我们无法提前知道数据个数的场景，比如用户购物车的场景，用户随时可以增加商品.</p>
<p>而ArrayList的自动扩容恰好弥补该缺陷，开发者无需考虑数组越界的风险，增加商品的时候直接add即可，由ArrayList来进行动态调整。</p>
<p>那么ArrayList又是如何进行resizable呢？这就需要进入源码的世界了</p>
<h1 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The<span class="built_in"> array </span>buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this<span class="built_in"> array </span>buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/%E6%95%B0%E7%BB%84.jpg" alt=""></p>
<p>ArrayList的内部依旧采用的数组(elementData存储元素)的数据结构，并且类型是Object，由于java中所有类都继承自Object，故而ArrayList实质可以存储所有类型。</p>
<h2 id="什么时候扩容？"><a href="#什么时候扩容？" class="headerlink" title="什么时候扩容？"></a>什么时候扩容？</h2><p>对于RandomAccess 随机访问的集合结构来说，最终要的接口无疑是 get，set，add 方法了。</p>
<p>首先来看get方法(如下code)：对于get/set来说，是无需关心扩容问题的，只要没有越界，那么这个数据就肯定存在，故而仅仅检查了越界问题就直接返回了数组中的Index位置的元素（或者设置数组index位置的元素）</p>
<details>
<summary>View Code</summary>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> E <span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> elementData(<span class="keyword">index</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> private <span class="type">void</span> range<span class="keyword">Check</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= size)</span><br><span class="line">         throw <span class="built_in">new</span> IndexOutOfBoundsException(outOfBoundsMsg(<span class="keyword">index</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">public</span> E <span class="keyword">set</span>(<span class="type">int</span> <span class="keyword">index</span>, E element) &#123;</span><br><span class="line">     range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">     E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line">     elementData[<span class="keyword">index</span>] = element;</span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</details>

<br/>
<br/>

<p><strong><em>add方法：</em></strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保容量足够</span></span><br><span class="line">    ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>); </span><br><span class="line">    elementData[<span class="built_in">size</span>++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前数空数组，则取size+1和默认值的最大值，否则取size+1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.<span class="built_in">max</span>(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果 当前需求的最小容量 比内部的数组长度大 则表示内部数组已经存放不了 此时便需要进行扩容处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，ArrayList在进行add操作的时候会先确保当前容量是否足够，如果不足变回调用grow方法进行扩容。</p>
<p><strong>结论：</strong><br>此时，便可以得出结论，当ArrayList在进行add操作的时候，如果所需要的数量大于当前ArrayList内部数组elementData的长度的时候，由于elementData已经存放不下，此时便需要进行扩容。</p>
<h2 id="怎么扩容？"><a href="#怎么扩容？" class="headerlink" title="怎么扩容？"></a>怎么扩容？</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void grow(int minCapacity) &#123;</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的 1.5倍</span></span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新容量比需求容量小，则新容量直接设置为需要的容量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量比 默认最大数值大 Integer.MAX_VALUE-8,则判断需要的是否超过MAX_ARRAY_SIZE，超过取最大，否则取MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 进行原数组复制，扩容。</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :<span class="type"></span></span><br><span class="line"><span class="type">        MAX_ARRAY_SIZE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/ArrayList%E6%89%A9%E5%AE%B9.jpg" alt=""></p>
<p><strong><em>示例：</em></strong><br><img src="../resource/java/ArrayList%E6%89%A9%E5%AE%B9%E7%A4%BA%E4%BE%8B.jpg" alt=""></p>
<p>总结：</p>
<ol>
<li>ArrayList的扩容是以原容量的1.5倍为基础。</li>
<li>扩容的过程中会进行越界检查。</li>
<li><strong><em>如果需求容量大于原容量的1.5倍，则会直接扩容到需求容量。</em></strong>所以当我们多次通过addAll进行新增元素（并且新增元素比较多的时候）的时候，是否可以调用ensureCapacity()方法手动扩容，以避免addAll的多次频繁扩容。</li>
</ol>
<h2 id="其他重要函数"><a href="#其他重要函数" class="headerlink" title="其他重要函数"></a>其他重要函数</h2><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><details>
<summary>view Code</summary>

<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     <span class="comment">//越界检查</span></span><br><span class="line">      rangeCheck(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">      modCount++; </span><br><span class="line">      <span class="comment">//设置值</span></span><br><span class="line">      E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line">      <span class="comment">//不需要移动的数组元素</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">         <span class="comment">//移动删除元素后面的所有元素</span></span><br><span class="line">          System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//设置为null，当数组为null的时候利于GC回收</span></span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>; </span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong> remove方法进行了越界检查，由于数组的特性，remove后需要将remove掉的位置之后的所有元素向前移动，以保证remove后ArrayList还是保持其基本操作不变。</p>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><details>
<summary>view Code</summary>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> indexOf(Object o) &#123;</span><br><span class="line">      <span class="comment">//空进行特殊处理</span></span><br><span class="line">       <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//其余部分均使用equals判断</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong> indexOf查找位置的方法，对于null进行了==号比较，对于普通元素都使用的equals方法进行比较</p>
<h3 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h3><details>
<summary>view Code</summary>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> new SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subList构造函数</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">                int offset, int fromIndex, int toIndex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="keyword">set</span>(int index, E e) &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明:</strong> 使用数组的时候，有时候我们会使用subList方法去构建一个子视图，通过subList方法，我们可以发现，子方法的所有操作都是针对于原ArrayList中的数组的，<strong><em>故而在子视图上进行的任何修改都会反映到原ArrayList对象中</em></strong></p>
<!-- 总结 -->
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>ArrayList的出现，为用户提供了一种自维护的数组数据结构，用户不需要再考虑越界，数组扩容，插入元素数组的元素移动等操作。</li>
<li>ArrayList内部依旧是通过数组的数据结构实现的。</li>
<li>ArrayList的自动扩容机制是通过数组复制实现的，扩容操作是在新增元素的时候进行容量检查，进行扩容</li>
<li>ArrayList的扩容默认容量是原容量的1.5倍，如果新增元素量大于1.5倍原容量，则会直接扩容到新增元素后需要的大小。</li>
<li>ArrayList的subList子视图方法，进行修改操作的时候是直接反映到原ArrayList中的。</li>
</ol>
<p>ArrayList具有随机读写的优点，对于特定位置的元素获取修改等操作可以有O(1)的复杂度，但是却在插入删除中间元素等操作的时候，需要进行大量元素移动的操作，效率低下O(n)。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合框架详解</title>
    <url>/post/82f1582a.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  作为java程序员，java集合在开发过程中使用的非常频繁，例如 ArrayList,HashMap，基本可以说在每一个项目中都会有。但是却又很少去了解其底层原理。所以准备对java集合框架源码进行探究，梳理集合框架数据结构和设计原理。 此次梳理希望能实现下面的目标：<br>      &emsp; 1. 温故而知新，对于java底层知识的回顾。<br>      &emsp; 2. 了解涉及思想，提升代码设计水平。<br>      &emsp; 3. 了解底层设计，能够以最恰当的方式使用java的集合 </p>
<h1 id="梳理线路"><a href="#梳理线路" class="headerlink" title="梳理线路"></a>梳理线路</h1><p><img src="../resource/java/java%E9%9B%86%E5%90%88.png" alt=""></p>
<h1 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h1><p><img src="../resource/java/javaCollection.jpeg" alt="图片源于百度"></p>
<center><font size=1>注明：图片源于百度</font></center>  
<br/>

<p>总结：</p>
<ol>
<li>6大顶层接口:Collection ,Iterator,Map,List,Set,Queue</li>
<li>5大抽象类 AbstractCollection,AbstractList,AbstractSet,AbstractMap,AbstractSeqentialList.</li>
<li>10个一级实现类</li>
<li>两个功能接口：Comparable,Comparator</li>
<li>两大工具类: Collections,Arrays</li>
</ol>
<h1 id="基础接口-类概览"><a href="#基础接口-类概览" class="headerlink" title="基础接口/类概览"></a>基础接口/类概览</h1><p><img src="../resource/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%8E%A5%E5%8F%A3%E6%A2%B3%E7%90%86.png" alt=""></p>
<h1 id="重要接口说明"><a href="#重要接口说明" class="headerlink" title="重要接口说明"></a>重要接口说明</h1><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><details>
<summary>View Code</summary>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    E next();</span><br><span class="line">   <span class="built_in"> default </span>void <span class="builtin-name">remove</span>() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明</strong></p>
<ol>
<li>iterator接口定义迭代器的基本操作,主要方法 hasNext(),next().</li>
</ol>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>除了Map接口，其他的接口都继承自Collection接口，并且由于java多态的特性，Interface i1 = new Immplements() 。 此时该对象i1调用的方法必须是接口中所有的，故而对于Collection接口就必须要有个了解。</p>
<details>
<summary>View Code</summary>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean contains(Object o);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    boolean <span class="builtin-name">add</span>(E e);</span><br><span class="line">    boolean <span class="builtin-name">remove</span>(Object o);</span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line">   <span class="built_in"> default </span>boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line">    void clear();</span><br><span class="line">    boolean equals(Object o);</span><br><span class="line">    int hashCode();</span><br><span class="line">    @Override</span><br><span class="line">   <span class="built_in"> default </span>Spliterator&lt;E&gt; spliterator() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>Stream&lt;E&gt; stream() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>Stream&lt;E&gt; parallelStream() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明：</strong></p>
<ol>
<li>作为集合顶层接口的Collection 定义了对于一个集合最普遍的操作，增，删，判空，转数组，判断包含等等基本操作。</li>
<li>集合继承了Iterable接口，包含了 iterator方法，对于集合来说，需要可遍历集合中所有元素</li>
</ol>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><details>
<summary>View Code</summary>

<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">interface</span> <span class="type">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean containsKey(<span class="type">Object</span> key);</span><br><span class="line">    boolean containsValue(<span class="type">Object</span> value);</span><br><span class="line">    V get(<span class="type">Object</span> key);</span><br><span class="line">    V put(K key, V value);</span><br><span class="line">    V remove(<span class="type">Object</span> key);</span><br><span class="line">    <span class="built_in">void</span> putAll(<span class="type">Map</span>&lt;? extends K, ? extends V&gt; m);</span><br><span class="line">    <span class="built_in">void</span> clear();</span><br><span class="line">    <span class="type">Set</span>&lt;K&gt; keySet();</span><br><span class="line">    <span class="type">Collection</span>&lt;V&gt; values();</span><br><span class="line">    <span class="type">Set</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">    <span class="keyword">interface</span> <span class="type">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        V setValue(V value);</span><br><span class="line">        boolean equals(<span class="type">Object</span> o);</span><br><span class="line">        <span class="built_in">int</span> hashCode();</span><br><span class="line">        public <span class="keyword">static</span> &lt;K extends <span class="type">Comparable</span>&lt;? super K&gt;, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K,V&gt;&gt; comparingByKey() <span class="meta">&#123;...&#125;</span></span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V extends <span class="type">Comparable</span>&lt;? super V&gt;&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K,V&gt;&gt; comparingByValue() &#123; ... &#125;</span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; comparingByKey(<span class="type">Comparator</span>&lt;? super K&gt; cmp) <span class="meta">&#123;...&#125;</span></span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; comparingByValue(<span class="type">Comparator</span>&lt;? super V&gt; cmp) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    boolean equals(<span class="type">Object</span> o);</span><br><span class="line">    <span class="built_in">int</span> hashCode();</span><br><span class="line">    default V getOrDefault(<span class="type">Object</span> key, V defaultValue) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="built_in">void</span> forEach(<span class="type">BiConsumer</span>&lt;? super K, ? super V&gt; action) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="built_in">void</span> replaceAll(<span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; function) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V putIfAbsent(K key, V value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default boolean remove(<span class="type">Object</span> key, <span class="type">Object</span> value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default boolean replace(K key, V oldValue, V newValue) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V replace(K key, V value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V computeIfAbsent(K key,</span><br><span class="line">            <span class="type">Function</span>&lt;? super K, ? extends V&gt; mappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V computeIfPresent(K key,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V compute(K key,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V merge(K key, V value,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super V, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明:</strong></p>
<ol>
<li>通用集合都是单值，Map是 kv 双值，故而Map的接口与Collection的接口会有很大的区别，这也是其他集合接口均集成Collection而Map不继承的原因</li>
<li>Map的基础操作依赖于Entry，外层是对于Entry的Set集合视图。</li>
<li>Map接口定义Map类型的基本增加，删除，判断，清空，大小等方法</li>
</ol>
<h2 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable&amp;Comparator"></a>Comparable&amp;Comparator</h2><details>
<summary>View Code</summary>

<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">interface</span> <span class="type">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> compareTo(T var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">interface</span> <span class="type">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> compare(T o1, T o2);</span><br><span class="line"></span><br><span class="line">    boolean equals(<span class="type">Object</span> obj);</span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; reversed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Collections</span>.reverseOrder(this);</span><br><span class="line">    &#125;</span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparing(<span class="type">Comparator</span>&lt;? super T&gt; other) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default &lt;U&gt; <span class="type">Comparator</span>&lt;T&gt; thenComparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor,</span><br><span class="line">            <span class="type">Comparator</span>&lt;? super U&gt; keyComparator)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default &lt;U extends <span class="type">Comparable</span>&lt;? super U&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; thenComparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">    <span class="meta">&#123;... &#125;</span></span><br><span class="line"><span class="meta">    default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) &#123;...&#125;</span></span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparingLong(<span class="type">ToLongFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparingDouble(<span class="type">ToDoubleFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T extends <span class="type">Comparable</span>&lt;? super T&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; reverseOrder() <span class="meta">&#123;...&#125;</span></span><br><span class="line">    @<span class="type">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    public <span class="keyword">static</span> &lt;T extends <span class="type">Comparable</span>&lt;? super T&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; naturalOrder() <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; nullsFirst(<span class="type">Comparator</span>&lt;? super T&gt; comparator) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; nullsLast(<span class="type">Comparator</span>&lt;? super T&gt; comparator) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T, U&gt; <span class="type">Comparator</span>&lt;T&gt; comparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor,</span><br><span class="line">            <span class="type">Comparator</span>&lt;? super U&gt; keyComparator)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T, U extends <span class="type">Comparable</span>&lt;? super U&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; comparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingInt(<span class="type">ToIntFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingLong(<span class="type">ToLongFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span>&lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingDouble(<span class="type">ToDoubleFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong></p>
<ol>
<li>Comparable与Comparator都是用作定义可排序和排序方式的接口，主要区别Comparable是内比较，用作当前对象和其他对象比较，COmparator是外比较，用于两个对象进行比较。</li>
</ol>
<h2 id="Collections-amp-Arrays"><a href="#Collections-amp-Arrays" class="headerlink" title="Collections&amp;Arrays"></a>Collections&amp;Arrays</h2><p>Collections：主要包含了集合的各种通用方法，例如，排序，拷贝，乱序，反序，查找，替换等等。Arrays类，主要是数组的基本操作，包含了各种排序搜索填充等基本操作</p>
<h2 id="equals-amp-hashCode"><a href="#equals-amp-hashCode" class="headerlink" title="equals &amp; hashCode"></a>equals &amp; hashCode</h2><p>HaseCode 和 equals方法是两个基础方法，其定义在Object.java类中，这两个方法定义了java中判断两个对象是否相等的方法。 </p>
<p>为什么会有equals方法呢，java中== 比较的是对象的内存地址，也就是说判断两个对象是否是统一个对象(<a href="https://blog.csdn.net/AlbenXie/article/details/88921344" target="_blank" rel="noopener">此处存在一个面试题，就是String的不同创建方式的==比较。涉及String常量词的概念</a>)，但是很多时候，比较统一对象是否是同一个对象并不是我们所需要的。所以便出现了equals方法，可以自定义两个对象是否相同。 </p>
<p><strong><em>注意：由于hashMap的比较中即使用了equals也是用到了hashCode所以对于一个对象，如果重写了equals一定要重写hashCode，以免在散列表等等场景下出现异常的情况</em></strong></p>
<p>Object规范规定：</p>
<ol>
<li>在统一个java执行程序中，如果一个对象的equals方法没有发生变更，那么无论调动多少次hashCode方法，始终返回同一个值</li>
<li>如果两个对象的equals()相同，那么两个对象的hashCode()必须返回相同的值</li>
<li>如果两个对象equals不同，那么并不要求一定不能返回两个相同的hashCode。但是不equal的两个值产生不同的hashCode可以有效的提升散列表的性能（此处参见hashMap的源码分析）。</li>
</ol>
<p>equals相等，hashCode必须相同。 equals不同，hashCode可以相同，但是建议不同。应为相同的hashCode多了之后，可能会让hashMap退化成链表结构。</p>
<details>
<summary>原文注释</summary>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>a<span class="markdown"> hash code value for </span>the<span class="markdown"> object. This method is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>supported for </span>the<span class="markdown"> benefit of hash tables </span>such<span class="markdown"> as those provided by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>&#123;@link java.util.HashMap&#125;.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>The general contract of &#123;@code hashCode&#125; is:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Whenever it is invoked on </span>the<span class="markdown"> same object </span>more<span class="markdown"> than once during</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span></span>an<span class="markdown"> execution of </span>a<span class="markdown"> Java application, </span>the<span class="markdown"> &#123;@code hashCode&#125; method</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>must consistently return </span>the<span class="markdown"> same integer, provided no information</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>used in &#123;@code equals&#125; comparisons on </span>the<span class="markdown"> object is modified.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>This integer need not remain consistent from one execution of </span>an</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>application to another execution of </span>the<span class="markdown"> same application.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>If two objects </span>are<span class="markdown"> equal according to </span>the<span class="markdown"> &#123;@code equals(Object)&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>method, then calling </span>the<span class="markdown"> &#123;@code hashCode&#125; method on each of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span></span>the<span class="markdown"> two objects must produce </span>the<span class="markdown"> same integer result.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>It is <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>not<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span> required that if two objects </span>are<span class="markdown"> unequal</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>according to </span>the<span class="markdown"> &#123;@link java.lang.Object#equals(java.lang.Object)&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>method, then calling </span>the<span class="markdown"> &#123;@code hashCode&#125; method on each of </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>two objects must produce distinct integer results.  However, </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>programmer </span>should<span class="markdown"> be aware that producing distinct integer results</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>for unequal objects may improve </span>the<span class="markdown"> performance of hash tables.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>As much as is reasonably practical, </span>the<span class="markdown"> hashCode method defined by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>class &#123;@code Object&#125; does return distinct integers for distinct</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>objects. (This is typically implemented by converting </span>the<span class="markdown"> internal</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>address of </span>the<span class="markdown"> object into </span>an<span class="markdown"> integer, </span>but<span class="markdown"> this implementation</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>technique is not required by </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Java&amp;trade; programming language.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return  </span>a<span class="markdown"> hash code value for this object.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see     java.lang.Object#equals(java.lang.Object)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see     java.lang.System#identityHashCode</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public native <span class="built_in">int</span> hashCode();</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>资源清单</title>
    <url>/post/71d60cd0.html</url>
    <content><![CDATA[<h1 id="建站："><a href="#建站：" class="headerlink" title="建站："></a>建站：</h1><ul>
<li>主站点:      <a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li>
<li>next主题:    <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></li>
<li>标签云:      <a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md</a></li>
<li>文件唯一id节点:<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a></li>
</ul>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ul>
<li>ppt教程:<a href="https://www.bilibili.com/video/av54211804?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av54211804?p=1</a></li>
</ul>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>ppt</tag>
        <tag>收藏夹</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
</search>
