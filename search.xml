<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java集合框架详解</title>
    <url>/post/82f1582a.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  作为java程序员，java集合在开发过程中使用的非常频繁，例如 ArrayList,HashMap，基本可以说在每一个项目中都会有。但是却又很少去了解其底层原理。所以准备对java集合框架源码进行探究，梳理集合框架数据结构和设计原理。 此次梳理希望能实现下面的目标：<br>      &emsp; 1. 温故而知新，对于java底层知识的回顾。<br>      &emsp; 2. 了解涉及思想，提升代码设计水平。<br>      &emsp; 3. 了解底层设计，能够以最恰当的方式使用java的集合 </p>
<h1 id="梳理线路"><a href="#梳理线路" class="headerlink" title="梳理线路"></a>梳理线路</h1><p><img src="../resource/java/java%E9%9B%86%E5%90%88.png" alt=""></p>
<h1 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h1><p><img src="../resource/java/javaCollection.jpeg" alt="图片源于百度"></p>
<center><font size=1>注明：图片源于百度</font></center>  
<br/>

<p>总结：</p>
<ol>
<li>6大顶层接口:Collection ,Iterator,Map,List,Set,Queue</li>
<li>5大抽象类 AbstractCollection,AbstractList,AbstractSet,AbstractMap,AbstractSeqentialList.</li>
<li>10个一级实现类</li>
<li>两个功能接口：Comparable,Comparator</li>
<li>两大工具类: Collections,Arrays</li>
</ol>
<h1 id="基础接口-类概览"><a href="#基础接口-类概览" class="headerlink" title="基础接口/类概览"></a>基础接口/类概览</h1><p><img src="../resource/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%8E%A5%E5%8F%A3%E6%A2%B3%E7%90%86.png" alt=""></p>
<h1 id="重要接口说明"><a href="#重要接口说明" class="headerlink" title="重要接口说明"></a>重要接口说明</h1><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><details>
<summary>View Code</summary>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    E next();</span><br><span class="line">   <span class="built_in"> default </span>void <span class="builtin-name">remove</span>() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明</strong></p>
<ol>
<li>iterator接口定义迭代器的基本操作,主要方法 hasNext(),next().</li>
</ol>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>除了Map接口，其他的接口都继承自Collection接口，并且由于java多态的特性，Interface i1 = new Immplements() 。 此时该对象i1调用的方法必须是接口中所有的，故而对于Collection接口就必须要有个了解。</p>
<details>
<summary>View Code</summary>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean contains(Object o);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    boolean <span class="builtin-name">add</span>(E e);</span><br><span class="line">    boolean <span class="builtin-name">remove</span>(Object o);</span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line">   <span class="built_in"> default </span>boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line">    void clear();</span><br><span class="line">    boolean equals(Object o);</span><br><span class="line">    int hashCode();</span><br><span class="line">    @Override</span><br><span class="line">   <span class="built_in"> default </span>Spliterator&lt;E&gt; spliterator() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>Stream&lt;E&gt; stream() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>Stream&lt;E&gt; parallelStream() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明：</strong></p>
<ol>
<li>作为集合顶层接口的Collection 定义了对于一个集合最普遍的操作，增，删，判空，转数组，判断包含等等基本操作。</li>
<li>集合继承了Iterable接口，包含了 iterator方法，对于集合来说，需要可遍历集合中所有元素</li>
</ol>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><details>
<summary>View Code</summary>

<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">interface</span> <span class="type">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean containsKey(<span class="type">Object</span> key);</span><br><span class="line">    boolean containsValue(<span class="type">Object</span> value);</span><br><span class="line">    V get(<span class="type">Object</span> key);</span><br><span class="line">    V put(K key, V value);</span><br><span class="line">    V remove(<span class="type">Object</span> key);</span><br><span class="line">    <span class="built_in">void</span> putAll(<span class="type">Map</span>&lt;? extends K, ? extends V&gt; m);</span><br><span class="line">    <span class="built_in">void</span> clear();</span><br><span class="line">    <span class="type">Set</span>&lt;K&gt; keySet();</span><br><span class="line">    <span class="type">Collection</span>&lt;V&gt; values();</span><br><span class="line">    <span class="type">Set</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">    <span class="keyword">interface</span> <span class="type">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        V setValue(V value);</span><br><span class="line">        boolean equals(<span class="type">Object</span> o);</span><br><span class="line">        <span class="built_in">int</span> hashCode();</span><br><span class="line">        public <span class="keyword">static</span> &lt;K extends <span class="type">Comparable</span>&lt;? super K&gt;, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K,V&gt;&gt; comparingByKey() <span class="meta">&#123;...&#125;</span></span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V extends <span class="type">Comparable</span>&lt;? super V&gt;&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K,V&gt;&gt; comparingByValue() &#123; ... &#125;</span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; comparingByKey(<span class="type">Comparator</span>&lt;? super K&gt; cmp) <span class="meta">&#123;...&#125;</span></span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; comparingByValue(<span class="type">Comparator</span>&lt;? super V&gt; cmp) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    boolean equals(<span class="type">Object</span> o);</span><br><span class="line">    <span class="built_in">int</span> hashCode();</span><br><span class="line">    default V getOrDefault(<span class="type">Object</span> key, V defaultValue) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="built_in">void</span> forEach(<span class="type">BiConsumer</span>&lt;? super K, ? super V&gt; action) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="built_in">void</span> replaceAll(<span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; function) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V putIfAbsent(K key, V value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default boolean remove(<span class="type">Object</span> key, <span class="type">Object</span> value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default boolean replace(K key, V oldValue, V newValue) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V replace(K key, V value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V computeIfAbsent(K key,</span><br><span class="line">            <span class="type">Function</span>&lt;? super K, ? extends V&gt; mappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V computeIfPresent(K key,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V compute(K key,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V merge(K key, V value,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super V, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明:</strong></p>
<ol>
<li>通用集合都是单值，Map是 kv 双值，故而Map的接口与Collection的接口会有很大的区别，这也是其他集合接口均集成Collection而Map不继承的原因</li>
<li>Map的基础操作依赖于Entry，外层是对于Entry的Set集合视图。</li>
<li>Map接口定义Map类型的基本增加，删除，判断，清空，大小等方法</li>
</ol>
<h2 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable&amp;Comparator"></a>Comparable&amp;Comparator</h2><details>
<summary>View Code</summary>

<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">interface</span> <span class="type">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> compareTo(T var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">interface</span> <span class="type">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> compare(T o1, T o2);</span><br><span class="line"></span><br><span class="line">    boolean equals(<span class="type">Object</span> obj);</span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; reversed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Collections</span>.reverseOrder(this);</span><br><span class="line">    &#125;</span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparing(<span class="type">Comparator</span>&lt;? super T&gt; other) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default &lt;U&gt; <span class="type">Comparator</span>&lt;T&gt; thenComparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor,</span><br><span class="line">            <span class="type">Comparator</span>&lt;? super U&gt; keyComparator)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default &lt;U extends <span class="type">Comparable</span>&lt;? super U&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; thenComparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">    <span class="meta">&#123;... &#125;</span></span><br><span class="line"><span class="meta">    default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) &#123;...&#125;</span></span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparingLong(<span class="type">ToLongFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparingDouble(<span class="type">ToDoubleFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T extends <span class="type">Comparable</span>&lt;? super T&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; reverseOrder() <span class="meta">&#123;...&#125;</span></span><br><span class="line">    @<span class="type">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    public <span class="keyword">static</span> &lt;T extends <span class="type">Comparable</span>&lt;? super T&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; naturalOrder() <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; nullsFirst(<span class="type">Comparator</span>&lt;? super T&gt; comparator) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; nullsLast(<span class="type">Comparator</span>&lt;? super T&gt; comparator) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T, U&gt; <span class="type">Comparator</span>&lt;T&gt; comparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor,</span><br><span class="line">            <span class="type">Comparator</span>&lt;? super U&gt; keyComparator)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T, U extends <span class="type">Comparable</span>&lt;? super U&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; comparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingInt(<span class="type">ToIntFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingLong(<span class="type">ToLongFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span>&lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingDouble(<span class="type">ToDoubleFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong></p>
<ol>
<li>Comparable与Comparator都是用作定义可排序和排序方式的接口，主要区别Comparable是内比较，用作当前对象和其他对象比较，COmparator是外比较，用于两个对象进行比较。</li>
</ol>
<h2 id="Collections-amp-Arrays"><a href="#Collections-amp-Arrays" class="headerlink" title="Collections&amp;Arrays"></a>Collections&amp;Arrays</h2><p>Collections：主要包含了集合的各种通用方法，例如，排序，拷贝，乱序，反序，查找，替换等等。Arrays类，主要是数组的基本操作，包含了各种排序搜索填充等基本操作</p>
<h2 id="equals-amp-hashCode"><a href="#equals-amp-hashCode" class="headerlink" title="equals &amp; hashCode"></a>equals &amp; hashCode</h2><p>HaseCode 和 equals方法是两个基础方法，其定义在Object.java类中，这两个方法定义了java中判断两个对象是否相等的方法。 </p>
<p>为什么会有equals方法呢，java中== 比较的是对象的内存地址，也就是说判断两个对象是否是统一个对象(<a href="https://blog.csdn.net/AlbenXie/article/details/88921344" target="_blank" rel="noopener">此处存在一个面试题，就是String的不同创建方式的==比较。涉及String常量词的概念</a>)，但是很多时候，比较统一对象是否是同一个对象并不是我们所需要的。所以便出现了equals方法，可以自定义两个对象是否相同。 </p>
<p><strong><em>注意：由于hashMap的比较中即使用了equals也是用到了hashCode所以对于一个对象，如果重写了equals一定要重写hashCode，以免在散列表等等场景下出现异常的情况</em></strong></p>
<p>Object规范规定：</p>
<ol>
<li>在统一个java执行程序中，如果一个对象的equals方法没有发生变更，那么无论调动多少次hashCode方法，始终返回同一个值</li>
<li>如果两个对象的equals()相同，那么两个对象的hashCode()必须返回相同的值</li>
<li>如果两个对象equals不同，那么并不要求一定不能返回两个相同的hashCode。但是不equal的两个值产生不同的hashCode可以有效的提升散列表的性能（此处参见hashMap的源码分析）。</li>
</ol>
<p>equals相等，hashCode必须相同。 equals不同，hashCode可以相同，但是建议不同。应为相同的hashCode多了之后，可能会让hashMap退化成链表结构。</p>
<details>
<summary>原文注释</summary>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>a<span class="markdown"> hash code value for </span>the<span class="markdown"> object. This method is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>supported for </span>the<span class="markdown"> benefit of hash tables </span>such<span class="markdown"> as those provided by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>&#123;@link java.util.HashMap&#125;.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>The general contract of &#123;@code hashCode&#125; is:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Whenever it is invoked on </span>the<span class="markdown"> same object </span>more<span class="markdown"> than once during</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span></span>an<span class="markdown"> execution of </span>a<span class="markdown"> Java application, </span>the<span class="markdown"> &#123;@code hashCode&#125; method</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>must consistently return </span>the<span class="markdown"> same integer, provided no information</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>used in &#123;@code equals&#125; comparisons on </span>the<span class="markdown"> object is modified.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>This integer need not remain consistent from one execution of </span>an</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>application to another execution of </span>the<span class="markdown"> same application.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>If two objects </span>are<span class="markdown"> equal according to </span>the<span class="markdown"> &#123;@code equals(Object)&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>method, then calling </span>the<span class="markdown"> &#123;@code hashCode&#125; method on each of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span></span>the<span class="markdown"> two objects must produce </span>the<span class="markdown"> same integer result.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>It is <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>not<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span> required that if two objects </span>are<span class="markdown"> unequal</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>according to </span>the<span class="markdown"> &#123;@link java.lang.Object#equals(java.lang.Object)&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>method, then calling </span>the<span class="markdown"> &#123;@code hashCode&#125; method on each of </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>two objects must produce distinct integer results.  However, </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>programmer </span>should<span class="markdown"> be aware that producing distinct integer results</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>for unequal objects may improve </span>the<span class="markdown"> performance of hash tables.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>As much as is reasonably practical, </span>the<span class="markdown"> hashCode method defined by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>class &#123;@code Object&#125; does return distinct integers for distinct</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>objects. (This is typically implemented by converting </span>the<span class="markdown"> internal</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>address of </span>the<span class="markdown"> object into </span>an<span class="markdown"> integer, </span>but<span class="markdown"> this implementation</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>technique is not required by </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Java&amp;trade; programming language.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return  </span>a<span class="markdown"> hash code value for this object.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see     java.lang.Object#equals(java.lang.Object)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see     java.lang.System#identityHashCode</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public native <span class="built_in">int</span> hashCode();</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>资源清单</title>
    <url>/post/71d60cd0.html</url>
    <content><![CDATA[<h1 id="建站："><a href="#建站：" class="headerlink" title="建站："></a>建站：</h1><ul>
<li>主站点:      <a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li>
<li>next主题:    <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></li>
<li>标签云:      <a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md</a></li>
<li>文件唯一id节点:<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a></li>
</ul>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ul>
<li>ppt教程:<a href="https://www.bilibili.com/video/av54211804?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av54211804?p=1</a></li>
</ul>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>ppt</tag>
        <tag>收藏夹</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
</search>
