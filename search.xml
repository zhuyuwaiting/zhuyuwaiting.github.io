<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ThreadPoolExecutor源码分析</title>
    <url>/post/fffe533f.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p> 在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式。</p>
<p> 通过线程池创建线程是为了代码规范，以及线程池优化资源的开销。</p>
<p> 不适用Executor而使用THreadPoolExecutor是为了让使用线程池的同学明确线程池运行规则，规避资源耗尽的风险。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPoolDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//构造一个线程池</span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>,</span><br><span class="line">                    TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                    <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">        MyRunnable mr1 = <span class="keyword">new</span> MyRunnable(<span class="number">10</span>, <span class="string">"mr1"</span>);</span><br><span class="line">        MyRunnable mr2 = <span class="keyword">new</span> MyRunnable(<span class="number">5</span>, <span class="string">"mr2"</span>);</span><br><span class="line">        MyRunnable mr3 = <span class="keyword">new</span> MyRunnable(<span class="number">10</span>, <span class="string">"mr3"</span>);</span><br><span class="line">        es.submit(mr1);</span><br><span class="line">        es.submit(mr2);</span><br><span class="line">        es.submit(mr3);</span><br><span class="line">        es.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.<span class="built_in">println</span>(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： 创建了一个线程池，提交了3个多线程任务到线程池中运行。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="状态属性"><a href="#状态属性" class="headerlink" title="状态属性"></a>状态属性</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录线程池状态和线程数量 （总共32位，前三位表示线程池状态，后29位表示线程数量）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 线程数量统计位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 容量 0001 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 状态 存储在高位上</span></span><br><span class="line"><span class="comment">// 运行中   111 0  0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">-1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 关闭    000 0  0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 停止    001 0  0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 整理    010 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 终结    011</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// capacity = 0001 1111 1111 1111 1111 1111 1111 1111  取反就是 111 0 00000</span></span><br><span class="line"><span class="comment">//做&amp; 就是 舍弃低位 保留高3位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 舍弃高位，保留低位 就是线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p><strong>状态：</strong></p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">RUNNING:  Accept <span class="keyword">new</span> tasks <span class="keyword">and</span> <span class="keyword">process</span> queued tasks</span><br><span class="line">SHUTDOWN: Don<span class="symbol">'t</span> accept <span class="keyword">new</span> tasks, but <span class="keyword">process</span> queued tasks</span><br><span class="line">STOP:     Don<span class="symbol">'t</span> accept <span class="keyword">new</span> tasks, don<span class="symbol">'t</span> <span class="keyword">process</span> queued tasks,</span><br><span class="line">          <span class="keyword">and</span> interrupt <span class="keyword">in</span>-progress tasks</span><br><span class="line">TIDYING:  <span class="keyword">All</span> tasks have terminated, workerCount <span class="keyword">is</span> zero,</span><br><span class="line">          the thread transitioning <span class="keyword">to</span> state TIDYING</span><br><span class="line">          will run the terminated() hook method</span><br><span class="line">TERMINATED: terminated() has completed</span><br></pre></td></tr></table></figure>
<ol>
<li>RUNNING：接受新任务并且处理阻塞队列中的任务</li>
<li>SHUTDOWN：拒绝新任务但是处理阻塞队列中的任务</li>
<li>STOP: 拒绝新任务并且抛弃阻塞队列中的任务同时中断正在处理的任务</li>
<li>TIDYING ： 所有任务都执行完（包括阻塞队列中的任务） 当前线程池活动线程数为0，调用terminated方法</li>
<li>TERMINATED ：terminated被执行完毕</li>
</ol>
<p><strong>状态转化：</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">RUNNING -&gt; SHUTDOWN</span><br><span class="line">   On invocation of shutdown(), perhaps implicitly <span class="keyword">in</span> finalize()</span><br><span class="line">(RUNNING <span class="keyword">or</span> SHUTDOWN) -&gt; STOP</span><br><span class="line">   On invocation of shutdownNow()</span><br><span class="line">SHUTDOWN -&gt; TIDYING</span><br><span class="line">   When both<span class="built_in"> queue </span><span class="keyword">and</span><span class="built_in"> pool </span>are empty</span><br><span class="line">STOP -&gt; TIDYING</span><br><span class="line">   When<span class="built_in"> pool </span>is empty</span><br><span class="line">TIDYING -&gt; TERMINATED</span><br><span class="line">   When the terminated() hook method has completed</span><br><span class="line"></span><br><span class="line">Threads waiting <span class="keyword">in</span> awaitTermination() will return when the</span><br><span class="line">state reaches TERMINATED.</span><br></pre></td></tr></table></figure>
<p><img src="../resource/java/ThreadPoolExcutor%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96.jpg" alt=""></p>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">// 可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 存放工作线程集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"><span class="comment">// 最大线程池容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">// 已经完成的线程的数目</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"><span class="comment">// 线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">// 拒绝任务的处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler <span class="keyword">handler</span>;</span><br><span class="line"><span class="comment">// 线程等待运行的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//是否允许核心线程超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"><span class="comment">//核心池的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//线程池的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"><span class="comment">//默认的拒绝任务处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">    <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">    <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br></pre></td></tr></table></figure>

<p>说明：默认的拒绝策略是AbortPolicy 抛出异常。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h2><details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                            <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                            <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                            TimeUnit unit,</span><br><span class="line">                            BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                            <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                            <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                            TimeUnit unit,</span><br><span class="line">                            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                            ThreadFactory threadFactory) &#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                            <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                            <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                            TimeUnit unit,</span><br><span class="line">                            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                            RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), <span class="keyword">handler</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全属性构造函数</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                            <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                            <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                            TimeUnit unit,</span><br><span class="line">                            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                            ThreadFactory threadFactory,</span><br><span class="line">                            RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || <span class="keyword">handler</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">handler</span> = <span class="keyword">handler</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
说明:  线程池 ThreadPoolExecutor有6大基础元素

<ol>
<li>核心线程池大小</li>
<li>线程池的最大的容量</li>
<li>keepAliveTime 线程等待时间</li>
<li>workQueue 等待队列</li>
<li>threadFactory 线程生产工厂</li>
<li>handler 拒绝策略</li>
</ol>
<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h3 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以FutureTask的方式去运行线程</span></span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; <span class="keyword">new</span><span class="type">TaskFor</span>(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; <span class="keyword">new</span><span class="type">TaskFor</span>(Runnable runnable, T value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;<span class="keyword">Void</span>&gt; ftask = <span class="keyword">new</span><span class="type">TaskFor</span>(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result 只是通过 future.get去返回result，相当于间接传递</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = <span class="keyword">new</span><span class="type">TaskFor</span>(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = <span class="keyword">new</span><span class="type">TaskFor</span>(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： submit（）方法只是通过newTaskFor方法，把任务封装成FutureTask对象，之后统一调用execute方法 并且返回这个Future</p>
<h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><details>
<summary><font color='red'>View Code</font></summary>


<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作线程，注意其继承自AQS 自带锁特性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="symbol">Worker</span></span><br><span class="line">    <span class="symbol">extends</span> <span class="symbol">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="symbol">implements</span> <span class="symbol">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// worker对应的线程    </span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// worker对应的第一个任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">   <span class="comment">// 已经完成的数量</span></span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个work 状态是-1 </span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 这个状态是AQS的状态</span></span><br><span class="line">        setState(<span class="number">-1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="comment">// 第一个运行的任务</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 根据当前线程初始化一个线程，通常是设置名称，优先级等</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁是否被占有</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean isHeldExclusively() &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean tryAcquire(<span class="built_in">int</span> unused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean tryRelease(<span class="built_in">int</span> unused) &#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</details>


<p>说明： worker 是一个继承了AQS的类，自带锁特性，并且worker提供了对于线程的封装。</p>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>向线程池加入一个任务，这个任务可能会放入池子中，也可能会放入队列中</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在将来执行给定的任务，可能被一个新线程执行，也可能被已经存在的线程执行。</span></span><br><span class="line"><span class="comment">//  如果不可以被执行，则会被拒绝策略通过一定的策略去处理</span></span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    <span class="comment">// 任务不可为null</span></span><br><span class="line">    <span class="keyword">if</span> (command<span class="operator"> == </span>null)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">NullPointerException()</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">        * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">        * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">        * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">        * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">        * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">        * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">        * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">        * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">        * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">        * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">        * and so reject the task.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3步走：</span></span><br><span class="line">    <span class="comment">// 1: 如果当前工作的线程数少于核心线程数corePoolSize 则创建新线程</span></span><br><span class="line">    <span class="comment">// 2: 尝试加入线程，并且再尝试的时候需要进行双重检查</span></span><br><span class="line">    <span class="comment">// 3: 如果无法加入线程，尝试创建一个新的线程，失败则走拒绝策略</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取标识符</span></span><br><span class="line">    <span class="built_in">int</span> c = ctl.get<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">// 线程数小于 corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">c</span>)</span> &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建 新的任务 成功直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (add<span class="constructor">Worker(<span class="params">command</span>, <span class="params">true</span>)</span>)</span><br><span class="line">            return;</span><br><span class="line">        <span class="comment">// 再次重新获取</span></span><br><span class="line">        c = ctl.get<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池还在运行，尝试放入队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">Running(<span class="params">c</span>)</span><span class="operator"> &amp;&amp; </span>workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 队列尾部放入成功，双重检查</span></span><br><span class="line">        <span class="built_in">int</span> recheck = ctl.get<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// 如果线程池关闭了，先移除，然后执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! is<span class="constructor">Running(<span class="params">recheck</span>)</span><span class="operator"> &amp;&amp; </span>remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 没关闭还活着， 判断下如果当前没有线程了，插入一个null节点任务占位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">recheck</span>)</span><span class="operator"> == </span><span class="number">0</span>)</span><br><span class="line">            add<span class="constructor">Worker(<span class="params">null</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程关闭，活着是放入队列尾部失败，尝试创建新的任务 失败就尝试失败策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!add<span class="constructor">Worker(<span class="params">command</span>, <span class="params">false</span>)</span>)</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static boolean is<span class="constructor">Running(<span class="params">int</span> <span class="params">c</span>)</span> &#123;</span><br><span class="line">    return c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 不考虑线程池关闭等异常情况，正常流程如下：<br><img src="../resource/java/ThreadPoolExcute_execute.jpg" alt=""></p>
<h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><p><strong>说明： addWorker主要是向线程池中的运行池加入一个打工仔Worker用于执行任务。 一旦加入到运行池，就会立即启动</strong></p>
<details>
<summary><font color='red'>View Code</font></summary>



<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// firstTask的作用是新线程应该首先运行的任务，Workers传入firstTask 来再线程数很少的时候绕过队列 活着当队列满了的时候绕过队列</span></span><br><span class="line"><span class="comment">// core true 表示使用corePoolSize 否则使用maxPoolSize</span></span><br><span class="line"><span class="comment">// firstTask ==null 主要是用来串联队列中的，如果firstTask==null 就从队列中取任务来运行</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">boolean</span> addWorker(Runnable firstTask, <span class="built_in">boolean</span> core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 自旋， 获取标志位</span></span><br><span class="line">        <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="built_in">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 线程池不在是RUNNING,要关闭了  SHUTDOWN状态需要处理队列中数据，所以此处查看firstTask是否为null b并且队列不为null</span></span><br><span class="line">        <span class="comment">// 只要不能处理 就发挥false  RUNNING可以处理， SHUTDOWN看看是否可以加入到队列？</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前线程数</span></span><br><span class="line">            <span class="built_in">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果超过最大容量  超过线程池容量 直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 可以处理这个线程（1.RUNNING 2. SHUTDOWN 队列还有 并且firstTask==null,3 没有超过数量限制）， 自增线程数</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 重新校验</span></span><br><span class="line">            c = ctl.<span class="built_in">get</span>();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 查看状态 状态有变更，重试</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可处理</span></span><br><span class="line">    <span class="comment">// 状态标志</span></span><br><span class="line">    <span class="built_in">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="built_in">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个新worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从新校验正泰</span></span><br><span class="line">                <span class="built_in">int</span> rs = runStateOf(ctl.<span class="built_in">get</span>());</span><br><span class="line">                <span class="comment">// 是否存活， 或者SHUTDOWN 但是firstTask==null</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 线程池加一个</span></span><br><span class="line">                    workers.<span class="built_in">add</span>(w);</span><br><span class="line">                    <span class="built_in">int</span> s = workers.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="comment">// 超过最大值 就把最大值设置为s？ 啥情况会超过最大值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 已加入 设置标志</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动</span></span><br><span class="line">                <span class="comment">// 注意此处 一旦被加入到运行池就会立即启动这个线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            <span class="comment">// 加入失败 移除</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否加入成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> addWorkerFailed(Worker w) &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</details>


<p>说明： workers 是真正的执行者线程，一个任务可以通过addWork加入到执行线程的条件：线程池开启并且不超过corePoolSize 或者maxPoolSize</p>
<p>addWork() 方法加入线程池中之后会调用线程的start()方法。</p>
<h3 id="worker-start"><a href="#worker-start" class="headerlink" title="worker.start"></a>worker.start</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> static boolean run<span class="constructor">StateAtLeast(<span class="params">int</span> <span class="params">c</span>, <span class="params">int</span> <span class="params">s</span>)</span> &#123;</span><br><span class="line">    return c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line">public void run<span class="literal">()</span> &#123;</span><br><span class="line">    run<span class="constructor">Worker(<span class="params">this</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">final void run<span class="constructor">Worker(Worker <span class="params">w</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread wt = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">    <span class="comment">// 获取第一个要执行的任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    <span class="comment">// 释放锁，设置state=0  worker默认的初始state都是-1 开始允许中断</span></span><br><span class="line">    w.unlock<span class="literal">()</span>; <span class="comment">// allow interrupts</span></span><br><span class="line">    boolean completedAbruptly = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环获取task执行，如果fistTask=null 就通过getTask获取队列中的任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != null<span class="operator"> || </span>(task = get<span class="constructor">Task()</span>) != null) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            w.lock<span class="literal">()</span>;</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果线程池STOP了，检查当前线程是否被中断，如果是 则中断worker线程</span></span><br><span class="line">            <span class="keyword">if</span> ((run<span class="constructor">StateAtLeast(<span class="params">ctl</span>.<span class="params">get</span>()</span>, STOP) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">                    (<span class="constructor">Thread</span>.interrupted() <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">                    run<span class="constructor">StateAtLeast(<span class="params">ctl</span>.<span class="params">get</span>()</span>, <span class="constructor">STOP</span>))) <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">                !wt.is<span class="constructor">Interrupted()</span>)</span></span><br><span class="line"><span class="pattern-match">                wt.interrupt();</span></span><br><span class="line"><span class="pattern-match">            <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">                <span class="operator">/</span><span class="operator">/</span> 调用前置执行</span></span><br><span class="line"><span class="pattern-match">                before<span class="constructor">Execute(<span class="params">wt</span>, <span class="params">task</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">                <span class="constructor">Throwable</span> thrown = null;</span></span><br><span class="line"><span class="pattern-match">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span> 执行</span></span><br><span class="line"><span class="pattern-match">                    task.run();</span></span><br><span class="line"><span class="pattern-match">                &#125; catch (<span class="constructor">RuntimeException</span> x) &#123;</span></span><br><span class="line"><span class="pattern-match">                    thrown = x; throw x;</span></span><br><span class="line"><span class="pattern-match">                &#125; catch (<span class="constructor">Error</span> x) &#123;</span></span><br><span class="line"><span class="pattern-match">                    thrown = x; throw x;</span></span><br><span class="line"><span class="pattern-match">                &#125; catch (<span class="constructor">Throwable</span> x) &#123;</span></span><br><span class="line"><span class="pattern-match">                    thrown = x; throw <span class="keyword">new</span> <span class="constructor">Error(<span class="params">x</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">                &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span> 调用后置处理，处理异常等等信息</span></span><br><span class="line"><span class="pattern-match">                    after<span class="constructor">Execute(<span class="params">task</span>, <span class="params">thrown</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">                &#125;</span></span><br><span class="line"><span class="pattern-match">            &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">                <span class="operator">/</span><span class="operator">/</span> task 执行完毕</span></span><br><span class="line"><span class="pattern-match">                task = null;</span></span><br><span class="line"><span class="pattern-match">                w.completed<span class="constructor">Tasks</span><span class="operator">++</span>;</span></span><br><span class="line"><span class="pattern-match">                <span class="operator">/</span><span class="operator">/</span> 释放锁</span></span><br><span class="line"><span class="pattern-match">                w.unlock();</span></span><br><span class="line"><span class="pattern-match">            &#125;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        completed<span class="constructor">Abruptly</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 处理完成后，调用钩子函数</span></span><br><span class="line"><span class="pattern-match">        process<span class="constructor">WorkerExit(<span class="params">w</span>, <span class="params">completedAbruptly</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<p>说明： 外部传入的线程实际是变成了一个个任务，由worker线程来循环执行。先处理firstTask，如果firstTask执行完毕再从队列中获取任务。</p>
<p>会有前置执行 beforeExecute和后置执行afterExecute钩子， 后置执行处理一些异常等等信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>前置执行后置执行默认不处理任何事情</p>
<h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void decrement<span class="constructor">WorkerCount()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compare<span class="constructor">AndDecrementWorkerCount(<span class="params">ctl</span>.<span class="params">get</span>()</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Runnable get<span class="constructor">Task()</span> &#123;</span><br><span class="line">    boolean timedOut = <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = ctl.get<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> rs = run<span class="constructor">StateOf(<span class="params">c</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 状态&gt;=STOP 或者队列为null </span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN<span class="operator"> &amp;&amp; </span>(rs &gt;= STOP<span class="operator"> || </span>workQueue.is<span class="constructor">Empty()</span>)) &#123;</span><br><span class="line">            <span class="comment">// 线程数-1  由于返回null worker数该退出了</span></span><br><span class="line">            decrement<span class="constructor">WorkerCount()</span>;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取线程worker数目</span></span><br><span class="line">        <span class="built_in">int</span> wc = worker<span class="constructor">CountOf(<span class="params">c</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">//  如果允许核心线程超时，并且当前worke 或者 当前线程已经大于corePoolSize了</span></span><br><span class="line">        boolean timed = allowCoreThreadTimeOut<span class="operator"> || </span>wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">// 如果worker大于最大线程数  并且可以被超时 并且已经超时了 并且核心线程 &gt;1 或者队列为null</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize<span class="operator"> || </span>(timed<span class="operator"> &amp;&amp; </span>timedOut))</span><br><span class="line"><span class="operator">            &amp;&amp; </span>(wc &gt; <span class="number">1</span><span class="operator"> || </span>workQueue.is<span class="constructor">Empty()</span>)) &#123;</span><br><span class="line">            <span class="comment">// 减少核心线程数 成功 直接让该线程退出</span></span><br><span class="line">            <span class="keyword">if</span> (compare<span class="constructor">AndDecrementWorkerCount(<span class="params">c</span>)</span>)</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试从队列中获取一个，等待keepAliveTime时间 如果需要捕杀多余线程</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take<span class="literal">()</span>;</span><br><span class="line">            <span class="comment">// 获取到 直接返回 </span></span><br><span class="line">            <span class="keyword">if</span> (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            <span class="comment">// 超时没获取到</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： getTask的核心功能：</p>
<ol>
<li>从队列中获取一个任务</li>
<li>如果没有获取到任务，判断是否需要杀死当前线程，以减少同时运行的线程数。</li>
</ol>
<h3 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果被中断 需要减少核心线程数目</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 修改执行完成的数目</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 线程获取不到任务 退出执行了 需要从运行池</span></span><br><span class="line">        workers.<span class="built_in">remove</span>(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//如果 是SHUTDONW 或者RUNNING</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//不是被中断结束的  获取最小的线程数量</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 如果队列没空 最小线程数量设置为1</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">min</span> == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                <span class="built_in">min</span> = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果线程数量大于最小的 直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= <span class="built_in">min</span>)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被中断的或者 线程数量太少了 ，则创建一个线程worker 用于从队列中获取任务执行</span></span><br><span class="line">        addWorker(null, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： processWorkerExit 函数，是每个线程退出后的钩子函数，需要从运行池中移除，并且校验现有的线程数目是否足够，不足需要补充。</p>
<h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void interrupt<span class="constructor">IdleWorkers(<span class="params">boolean</span> <span class="params">onlyOne</span>)</span> &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有线程</span></span><br><span class="line">        for (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 没有中断 则中断</span></span><br><span class="line">            <span class="keyword">if</span> (!t.is<span class="constructor">Interrupted()</span><span class="operator"> &amp;&amp; </span>w.<span class="keyword">try</span><span class="constructor">Lock()</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt<span class="literal">()</span>;</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    w.unlock<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试终止</span></span><br><span class="line">final void <span class="keyword">try</span><span class="constructor">Terminate()</span> &#123;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = ctl.get<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// RUNNING || TIDYING || TERMINALED 或者 SHUTDOWN 队列有元素 不终止 继续</span></span><br><span class="line">        <span class="keyword">if</span> (is<span class="constructor">Running(<span class="params">c</span>)</span> <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">            run<span class="constructor">StateAtLeast(<span class="params">c</span>, TIDYING)</span> <span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">            (run<span class="constructor">StateOf(<span class="params">c</span>)</span> <span class="operator">==</span> <span class="constructor">SHUTDOWN</span> <span class="operator">&amp;&amp;</span> ! work<span class="constructor">Queue</span>.is<span class="constructor">Empty()</span>))</span></span><br><span class="line"><span class="pattern-match">            return;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 线程数不为0 默认只中断一个</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (worker<span class="constructor">CountOf(<span class="params">c</span>)</span> != 0) &#123; <span class="operator">/</span><span class="operator">/</span> <span class="constructor">Eligible</span> <span class="keyword">to</span> terminate</span></span><br><span class="line"><span class="pattern-match">            interrupt<span class="constructor">IdleWorkers(ONLY_ONE)</span>;</span></span><br><span class="line"><span class="pattern-match">            return;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">        final <span class="constructor">ReentrantLock</span> main<span class="constructor">Lock</span> = this.main<span class="constructor">Lock</span>;</span></span><br><span class="line"><span class="pattern-match">        main<span class="constructor">Lock</span>.lock();</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="operator">/</span><span class="operator">/</span> 设置为 <span class="constructor">TYPEDING</span></span></span><br><span class="line"><span class="pattern-match">            <span class="keyword">if</span> (ctl.compare<span class="constructor">AndSet(<span class="params">c</span>, <span class="params">ctlOf</span>(TIDYING, 0)</span>)) &#123;</span></span><br><span class="line"><span class="pattern-match">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span> 直接终止</span></span><br><span class="line"><span class="pattern-match">                    terminated();</span></span><br><span class="line"><span class="pattern-match">                &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span> 设置<span class="constructor">TERMINATED</span></span></span><br><span class="line"><span class="pattern-match">                    ctl.set(ctl<span class="constructor">Of(TERMINATED, 0)</span>);</span></span><br><span class="line"><span class="pattern-match">                    <span class="operator">/</span><span class="operator">/</span>  释放在termination条件上等待的所有线程</span></span><br><span class="line"><span class="pattern-match">                    termination.signal<span class="constructor">All()</span>;</span></span><br><span class="line"><span class="pattern-match">                &#125;</span></span><br><span class="line"><span class="pattern-match">                return;</span></span><br><span class="line"><span class="pattern-match">            &#125;</span></span><br><span class="line"><span class="pattern-match">        &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">            main<span class="constructor">Lock</span>.unlock();</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> <span class="keyword">else</span> retry on failed <span class="constructor">CAS</span></span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>说明：如果worker中还有线程，则需要中断一个线程，然后尝试设置状态为整理，成功，则直接终止线程。</p>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void advance<span class="constructor">RunState(<span class="params">int</span> <span class="params">targetState</span>)</span> &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = ctl.get<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span> (run<span class="constructor">StateAtLeast(<span class="params">c</span>, <span class="params">targetState</span>)</span> <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">            ctl.compare<span class="constructor">AndSet(<span class="params">c</span>, <span class="params">ctlOf</span>(<span class="params">targetState</span>, <span class="params">workerCountOf</span>(<span class="params">c</span>)</span>)))</span></span><br><span class="line"><span class="pattern-match">            break;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match">public void shutdown() &#123;</span></span><br><span class="line"><span class="pattern-match">    final <span class="constructor">ReentrantLock</span> main<span class="constructor">Lock</span> = this.main<span class="constructor">Lock</span>;</span></span><br><span class="line"><span class="pattern-match">    main<span class="constructor">Lock</span>.lock();</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> 检查shutdown权限</span></span><br><span class="line"><span class="pattern-match">        check<span class="constructor">ShutdownAccess()</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 设置状态为<span class="constructor">SHUTDOWN</span></span></span><br><span class="line"><span class="pattern-match">        advance<span class="constructor">RunState(SHUTDOWN)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 中断线程</span></span><br><span class="line"><span class="pattern-match">        interrupt<span class="constructor">IdleWorkers()</span>;</span></span><br><span class="line"><span class="pattern-match">        on<span class="constructor">Shutdown()</span>; <span class="operator">/</span><span class="operator">/</span> hook for <span class="constructor">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="pattern-match">    &#125; finally &#123;</span></span><br><span class="line"><span class="pattern-match">        main<span class="constructor">Lock</span>.unlock();</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> 尝试终结 </span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">try</span><span class="constructor">Terminate()</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>说明： 校验权限，设置状态，中断线程，尝试终结。</p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 哪个线程提交的任务，哪个线程自己去执行run方法  会阻塞提交的那个线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                                <span class="string">" rejected from "</span> +</span><br><span class="line">                                                e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 不执行了，直接丢弃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 从队列尾部去一个任务丢弃，将这个任务加入尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>假设corePoolSize=3 maxPoolSize=5 阻塞队列大小为 3 提交线程流程如下</p>
<p><img src="../resource/java/ThreadPoolExecute_1.jpg" alt=""></p>
<p>继续添加，corePoolSize满了，加入阻塞队列<br><img src="../resource/java/ThreadPoolExecute_2.jpg" alt=""></p>
<p>此时队列满了，继续添加submit(6),submit(7),submit(8)<br><img src="../resource/java/ThreadPoolExecute_3.jpg" alt=""></p>
<p><strong>在继续添加就没办承受了，所以执行拒绝策略</strong></p>
<p>执行的时候，先执行自己的任务，然后通过getTask从队列中获取任务执行。</p>
<p>提交流程：</p>
<ol>
<li>如果worker数目不超过corePoolSize ，创建新的worker，开启一个线程</li>
<li>如果worker数目超过了corePoolSize 放入阻塞队列</li>
<li>如果阻塞队列满了，不超过maxPoolSize,创建新的worker，开启一个新的线程</li>
<li>如果超过了maxPoolSize，直接拒绝，执行拒绝策略。</li>
</ol>
<p>执行流程：</p>
<ol>
<li>实际执行是有worker来执行的，worker数目是真正运行的线程数目，提交的线程叫做任务。</li>
<li>worker执行首个任务，执行完毕后从队列中获取，获取到则继续执行run。</li>
<li>如果获取不到，则考虑要不要退出，释放线程。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>resource/post</title>
    <url>/post/ac782cf8.html</url>
    <content><![CDATA[<p><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/3bd81454.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/3bd81454.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/3fb8877a.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/3fb8877a.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/4b83aa2d.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/4b83aa2d.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/19c86886.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/19c86886.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/31afbc55.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/31afbc55.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/54dc35c3.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/54dc35c3.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/62b74ffe.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/62b74ffe.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/71d60cd0.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/71d60cd0.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/82f1582a.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/82f1582a.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/85e75abb.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/85e75abb.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/715fcc86.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/715fcc86.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/2528e072.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/2528e072.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/9749aebd.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/9749aebd.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/414857a8.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/414857a8.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/75655826.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/75655826.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/a1e0d9b8.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/a1e0d9b8.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/ab0f6be5.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/ab0f6be5.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/b51bcd65.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/b51bcd65.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/b6468daf.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/b6468daf.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/b5837189.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/b5837189.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/ba7856b4.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/ba7856b4.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/ca50378a.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/ca50378a.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/e62a890b.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/e62a890b.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/e74dcc0a.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/e74dcc0a.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/ebfd7e71.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/ebfd7e71.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/f036f8db.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/f036f8db.html</a><br><a href="https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/f3607baf.html" target="_blank" rel="noopener">https://zhuyuwaiting-github-io.zhuyuwaiting.now.sh/post/f3607baf.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>ThreadLocal源码分析</title>
    <url>/post/ba7856b4.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">class</span> provides thread-local variables.  These variables differ <span class="keyword">from</span></span><br><span class="line">their normal counterparts <span class="keyword">in</span> that <span class="keyword">each</span> thread that accesses one (via its</span><br><span class="line"><span class="comment">&#123;@code get&#125;</span> <span class="keyword">or</span> <span class="comment">&#123;@code set&#125;</span> <span class="function"><span class="keyword">method</span>) <span class="title">has</span> <span class="title">its</span> <span class="title">own</span>, <span class="title">independently</span> <span class="title">initialized</span></span></span><br><span class="line"><span class="function"><span class="title">copy</span> <span class="title">of</span> <span class="title">the</span> <span class="title">variable</span>.  <span class="comment">&#123;@code ThreadLocal&#125;</span> <span class="title">instances</span> <span class="title">are</span> <span class="title">typically</span> <span class="title">private</span></span></span><br><span class="line"><span class="function"><span class="title">static</span> <span class="title">fields</span> <span class="title">in</span> <span class="title">classes</span> <span class="title">that</span> <span class="title">wish</span> <span class="title">to</span> <span class="title">associate</span> <span class="title">state</span> <span class="title">with</span> <span class="title">a</span> <span class="title">thread</span> <span class="params">(e.g.,</span></span></span><br><span class="line"><span class="function"><span class="params">a user ID <span class="keyword">or</span> Transaction ID)</span>.</span></span><br></pre></td></tr></table></figure>
<p>ThreadLocal 提供共了线程本地变量的能力，每个线程单独保留变量的副本，进行get，set操作的时候，都是操作的线程本地变量。<br>ThreadLocal通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。有着丰富的使用场景，例如数据库链接，session管理等等。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Thread local variable containing each thread's ID</span></span><br><span class="line">     <span class="comment">// 创建线程本地变量 初始化nextId 值</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">       <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span> </span><br><span class="line">           <span class="keyword">protected</span> <span class="function">Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="function"><span class="keyword">return</span> nextId.<span class="title">getAndIncrement</span><span class="params">()</span></span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Returns the current thread's unique ID, assigning it if necessary</span></span><br><span class="line">     <span class="comment">// 获取线程本地变量nextId的值</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">return</span> threadId.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br>创建一个ThreadLocal变量，初始化值为nextId的值，用来表示线程Id，get的时候，返回线程本地变量，该例子返回的是每个线程自己的ThreadId.</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于ThreadLocalMap 的key的hash </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个threadLocalHashCode</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// 两个hashCoe的间隔</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>说明： ThreadLocal类中的ThreadLocalMap是用来存储每个线程本地变量的地方，其是一个典型的Map结构，ThreadLocal的实现，多数是通过ThreadLocalMap来实现的。<br>WeakReference 弱引用 关于引用的区别可以参考:<a href="https://www.cnblogs.com/gudi/p/6403953.html" target="_blank" rel="noopener">https://www.cnblogs.com/gudi/p/6403953.html</a></p>
<p>对象回收：<a href="https://www.oracle.com/technical-resources/articles/javase/finalization.html" target="_blank" rel="noopener">https://www.oracle.com/technical-resources/articles/javase/finalization.html</a></p>
<p>ThreadLocal引用关系链：</p>
<p><img src="../resource/java/ThreadLocal%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p><strong>这里有个很重要的点就是 ThreadLocalMap中对于ThreadLocal的应用是一个弱引用，而弱引用一旦外围没有应用关系，也就是关系链中的ThreadLocalRefd断开设置为null,那么ThreadlLocal就会被垃圾回收器回收。</strong></p>
<p><strong>但是当前线程依旧会存在引用链条: CurrentThreadRef -&gt; CurrentThread -&gt; ThreadLocalMap -&gt; entry-&gt; V 的引用链条，如果 CurrentThreadRef不被清空回收，那么会导致的问题就是V这个对象也不会被回收。由于我们线程经常是利用线程池来管理做到线程复用，那么可能V就会一直不被回收，导致出现内存泄露的问题。</strong></p>
<p>而 ThreadLocal类也采用了一些技术去避免这种内存泄露的问题，通过下面的源码会详细分析如何避免这个问题。</p>
<h2 id="setInitialValue-初始化方法"><a href="#setInitialValue-初始化方法" class="headerlink" title="setInitialValue 初始化方法"></a>setInitialValue 初始化方法</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化值为null</span></span><br><span class="line">protected T initial<span class="constructor">Value()</span> &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> T set<span class="constructor">InitialValue()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化value</span></span><br><span class="line">    T value = initial<span class="constructor">Value()</span>;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap </span></span><br><span class="line">    ThreadLocalMap map = get<span class="constructor">Map(<span class="params">t</span>)</span>;</span><br><span class="line">    <span class="comment">// map不为null 则直接放置</span></span><br><span class="line">    <span class="keyword">if</span> (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="comment">// 创建map</span></span><br><span class="line">        create<span class="constructor">Map(<span class="params">t</span>, <span class="params">value</span>)</span>;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">void create<span class="constructor">Map(Thread <span class="params">t</span>, T <span class="params">firstValue</span>)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="constructor">ThreadLocalMap(<span class="params">this</span>, <span class="params">firstValue</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 初始化的时候默认的初始化值为null，会创建一个ThreadLocalMap对象到 线程的Thread对象中存储。</p>
<h2 id="ThreadLocalMap-expungeStaleEntry"><a href="#ThreadLocalMap-expungeStaleEntry" class="headerlink" title="ThreadLocalMap.expungeStaleEntry"></a>ThreadLocalMap.expungeStaleEntry</h2><p><strong>针对于key=null的节点,也就是脏数据，做失效处理。key=null的节点，上面说了，是因为ThreadLocal外部引用被清空，导致垃圾回收器回收了ThreadLocal对象</strong></p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下一个索引位置  如果i+1&lt;len 就返回i+1  否则从数组头开始</span></span><br><span class="line"><span class="comment">// 数组环</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span>(<span class="params"><span class="keyword">int</span> i, <span class="keyword">int</span> len</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span>(<span class="params"><span class="keyword">int</span> staleSlot</span>)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    <span class="comment">// 直接清除脏数据</span></span><br><span class="line">    tab[staleSlot].<span class="keyword">value</span> = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    <span class="comment">// 重新hash</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 从下一个索引位置开始，直到tab[i] ==null 为止 环形查找</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">        <span class="comment">//获取ThreadLocal 如果ThreadLocal是null</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">// 脏数据 清除</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置为null 释放掉</span></span><br><span class="line">            e.<span class="keyword">value</span> = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不为null 获取其索引</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 处理rehash的情况， k 当前在i的位置 但是hash值h不是i，表示是经过了rehash的情况 开放地址法解决的冲突</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// 把i处设置为null 现在tab[i] 的值是 e， 相当于把 tab[i] 释放到，应为i是rehash后的</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="comment">// 从h位置开始找，找第一个为null的索引位置</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                <span class="comment">// 将e移动到h处。</span></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: </p>
<p>expungeStaleEntry 是清理失效节点的作用，防止应为ThreadLocal被释放，线程不释放，导致value不释放 出现的内存泄露问题。</p>
<p>expungeStaleEntry 由于ThreadLocalMap是通过开放地址法来解决的hash冲突问题，所以此处进行清理的时候，重新整理了节点的位置。</p>
<p>过程如下：</p>
<p><img src="../resource/java/ThreadLocal%E6%B8%85%E7%90%86%E5%A4%B1%E6%95%88%E8%8A%82%E7%82%B9.jpg" alt=""></p>
<h2 id="ThreadLocalMap-getEntry"><a href="#ThreadLocalMap-getEntry" class="headerlink" title="ThreadLocalMap.getEntry"></a>ThreadLocalMap.getEntry</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一个ThreadLocal的值</span></span><br><span class="line"><span class="keyword">private</span> Entry getEntry(ThreadLocal&lt;?&gt; <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到hash索引的位置</span></span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 如果key相等 表示是这个 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.<span class="built_in">get</span>() == <span class="built_in">key</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 不想等 可能e为null 或者是被开放地址法的冲突解决办法rehash了</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(<span class="built_in">key</span>, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从i位置开始找key 这个ThreadLocal的值</span></span><br><span class="line"><span class="keyword">private</span> Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; <span class="built_in">key</span>, <span class="built_in">int</span> i, Entry e) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="built_in">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 找到e 不等于null的时候为止 如果e==null 直接返回null</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// 表示找到了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">key</span>)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 如果k==null 需要进行脏节点清除了 上面说过清除流程</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 指针后移 看下一个节点的数据</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> </p>
<ol>
<li>由于ThreadLocalMap使用开放地址法进行hash冲突解决，所以找到hashIndex之后需要比较key是否相等，如果相等直接返回value，否则利用开放地址法特性向后查找。</li>
<li>查找节点的过程，如果有遇到key==null的节点表示有脏数据了，需要进行清理。</li>
</ol>
<p><img src="../resource/java/ThreadLocal_getEntry.jpg" alt=""></p>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从线程t中获取 ThreadLocalMap</span></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="title">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 threadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果 map不为null</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用这个ThreadLocalMap的 getEntry方法 获取 entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 不为null 表示找到了值直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前Thread没有ThreadLocalMap 没有初始化过 ，则进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>get方法主要首先获取当前线程的ThreadLocalMap然后利用getEntry去获取值。</p>
<h2 id="cleanSomeSlots"><a href="#cleanSomeSlots" class="headerlink" title="cleanSomeSlots"></a>cleanSomeSlots</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> boolean clean<span class="constructor">SomeSlots(<span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    boolean removed = <span class="literal">false</span>;</span><br><span class="line">    Entry<span class="literal">[]</span> tab = table;</span><br><span class="line">    <span class="built_in">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 从i 开始 循环 n控制循环次数 循环次数为 n 的二进制位数</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//找i的下一个节点</span></span><br><span class="line">        i = next<span class="constructor">Index(<span class="params">i</span>, <span class="params">len</span>)</span>;</span><br><span class="line">        Entry e = tab<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">        <span class="comment">// e!=null 但是key为null 需要进行清理</span></span><br><span class="line">        <span class="keyword">if</span> (e != null<span class="operator"> &amp;&amp; </span>e.get<span class="literal">()</span><span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="comment">// 重置循环点</span></span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 清理</span></span><br><span class="line">            i = expunge<span class="constructor">StaleEntry(<span class="params">i</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    return removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 从i开始查看一半的节点，如果有需要清理的，进行清理，再重试。没有清理的的直接退出</p>
<h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span>(<span class="params"><span class="keyword">int</span> i, <span class="keyword">int</span> len</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span>(<span class="params">ThreadLocal&lt;?&gt; key, Object <span class="keyword">value</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> staleSlot</span>)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="comment">// 向前找第一个脏节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">            i = prevIndex(i, len))</span><br><span class="line">        <span class="comment">// 如果key为空，则设置需要清理的slotIndex 为i</span></span><br><span class="line">        <span class="keyword">if</span> (e.<span class="keyword">get</span>() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    <span class="comment">// 从i 向后找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">// 如果k==key </span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">//重新设置value</span></span><br><span class="line">            e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            <span class="comment">//找到相同的key 覆盖，并且与staleSlot位置的节点交换</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            <span class="comment">// 向前查找的时候没有脏节点，则从当前开始清理</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="comment">// 返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 向前查找的时候没有找到脏节点 则 从 i处开始清理 但是i是脏节点 </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].<span class="keyword">value</span> = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, <span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        <span class="comment">// 有脏节点，从上面的i处开始清理</span></span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">ThreadLocal&lt;?&gt; key, Object <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 找到当前hash</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 循环向后，知道找到一个位置为null的</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">            e != <span class="literal">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">// 如果找到了一样的，则直接重新赋值，返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有脏节点 重新设置返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, <span class="keyword">value</span>, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了空位置</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 如果个数超过了阈值，则直接进行扩容重新 hash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">// 重hash</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个情况的大致流程如下所示：</p>
<p><img src="../resource/java/ThreadLocal_set.jpg" alt=""></p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> remove(ThreadLocal&lt;?&gt; <span class="built_in">key</span>) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="built_in">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">//找到索引</span></span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (len<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//遍历找到e==null位置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">            e != <span class="keyword">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// key相等 表示找到了</span></span><br><span class="line">        <span class="keyword">if</span> (e.<span class="built_in">get</span>() == <span class="built_in">key</span>) &#123;</span><br><span class="line">            <span class="comment">// 清楚key</span></span><br><span class="line">            e.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">//执行清除失效节点操作</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没找到不处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 通过循环，找到节点，找到了就清楚。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>ThreadLocal是通过线程本地变量的方式解决并发访问的问题。</li>
<li>每个线程Thread对象中，都有一个ThreadLocalMap的对象，ThreadLocalMap中以key=ThreadLocal value为值的结构存储了ThreadLocal的本地副本，get，set的访问都是访问这个本地的副本</li>
<li>由于ThreadLocalMap对于key ThreadLocal是弱引用 WeakReference,意味着外部定义的ThreadLocal=null 这样被释放后，或者外部的ThreadLocal变量被回收后，由于是WeakReference的对象，ThreadLocal的这个对象会被GC回收，由于我们的线程通常是通过线程池使用达到线程复用，所以可能线程没被回收，导致这个ThreadLocal的本地副本value对象不会被回收。ThreadLocal通过expungeStaleEntry方法重整清理失效节点。</li>
<li>由于ThreadLocalMap是通过开放地址法解决的hash冲突。所以在进行清除节点的时候，需要重新整理节点的位置，查找节点的时候如果hashIndex处不是并且不为null，则需要向后查找。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Semaphore源码分析</title>
    <url>/post/b51bcd65.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">A counting semaphore.  Conceptually, a semaphore maintains a set of</span><br><span class="line">permits.  <span class="keyword">Each</span> &#123;@<span class="literal">link</span> <span class="comment">#acquire&#125; blocks if necessary until a permit is</span></span><br><span class="line">available, <span class="keyword">and</span> then takes it.  Each &#123;@<span class="literal">link</span> <span class="comment">#release&#125; adds a permit,</span></span><br><span class="line">potentially releasing a blocking acquirer.</span><br><span class="line">However, no actual permit objects are used; the &#123;@code Semaphore&#125; <span class="keyword">just</span></span><br><span class="line"><span class="keyword">keeps</span> <span class="keyword">a</span> <span class="keyword">count</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">number</span> <span class="keyword">available</span> <span class="keyword">and</span> <span class="keyword">acts</span> <span class="keyword">accordingly</span>.</span><br><span class="line"></span><br><span class="line">Semaphores are often used to restrict the number of threads than can</span><br><span class="line">access some (physical or logical) resource.</span><br></pre></td></tr></table></figure>

<p>semaphore持有一组许可证，每次acquire的时候，会请求一个许可证，之后获取到了许可证才可以执行，release会想semaphore中创建一个许可证。</p>
<p>semaphore通常用于对某个资源的访问线程数量有严格控制需求的时候。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">   <span class="comment">// 初始化100个许可证</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Semaphore <span class="built_in">available</span> = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> throws InterruptedException </span>&#123;</span><br><span class="line">     <span class="comment">// 先加锁 获取运行许可证</span></span><br><span class="line">     <span class="built_in">available</span>.acquire();</span><br><span class="line">     <span class="comment">// 拿去item资源</span></span><br><span class="line">     <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 放资源 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// x 没被使用  则存放</span></span><br><span class="line">     <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">       <span class="comment">// 存放成功后，释放一个运行许可</span></span><br><span class="line">       <span class="built_in">available</span>.<span class="built_in">release</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> synchronized Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">          used[i] = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> items[i];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> null; <span class="comment">// not reached</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> synchronized <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>说明: </p>
<ol>
<li>available.acquire(); 获取运行代码（访问资源）的许可证书，失败等待</li>
<li>available.release(); 释放资源，在资源池中创建一个许可证书。</li>
</ol>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="属性-和结构"><a href="#属性-和结构" class="headerlink" title="属性 和结构"></a>属性 和结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非公平，如果有许可证 则直接尝试占有</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试释放，修改state 也就是在semaphore中创建一个许可</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少许可 也就是减少 state</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 摧毁所有许可，也就是直接设置state=0</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * NonFair version</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Fair version</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有等待，如果有 则加入 没有尝试直接获取许可</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： semaphore数据结构复用  <a href="/post/b6468daf.html" title="&lt;b&gt;Aqs&lt;&#x2F;b&gt;"><b>Aqs</b></a> 的数据结构。<br><img src="../resource/java/CountDownLatch%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>内部有公平策略和非公平策略：</p>
<ol>
<li>公平策略   ，有等待 先加入等待，在尝试获取</li>
<li>非公平策略   直接尝试获取，失败在加入等待</li>
</ol>
<h2 id="aquire"><a href="#aquire" class="headerlink" title="aquire"></a>aquire</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> release() &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><p>我们可以看到semaphore结果和重要的方法都是AQS sync队列的方法，掌握了AQS 也就掌握了semaphore的源码。<br>semaphore源码过程：</p>
<ol>
<li>初始化的时候，设置state等于初始化许可的数量</li>
<li>尝试获取执行许可的过程，其实是将state-1的过程，如果能成功，则获取许可，否则不可以获取许可</li>
<li>创建许可的过程，其实是state+1的过程。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDownLatch源码分析</title>
    <url>/post/f036f8db.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> A synchronization aid that allows one or more threads to wait until</span><br><span class="line"> a <span class="keyword">set</span> <span class="keyword">of</span> <span class="keyword">operations</span> being performed <span class="keyword">in</span> other threads completes.</span><br><span class="line">&lt;p&gt;A &#123;@code CountDownLatch&#125; <span class="keyword">is</span> <span class="keyword">initialized</span> <span class="keyword">with</span> a given &lt;em&gt;<span class="keyword">count</span>&lt;/em&gt;.</span><br><span class="line">The &#123;@<span class="keyword">link</span> <span class="comment">#await await&#125; methods block until the current count reaches</span></span><br><span class="line">zero due <span class="keyword">to</span> invocations <span class="keyword">of</span> the &#123;@<span class="keyword">link</span> <span class="comment">#countDown&#125; method, after which</span></span><br><span class="line"><span class="keyword">all</span> waiting threads <span class="keyword">are</span> released <span class="keyword">and</span> <span class="keyword">any</span> subsequent invocations <span class="keyword">of</span></span><br><span class="line">&#123;@<span class="keyword">link</span> <span class="comment">#await await&#125; return immediately.  This is a one-shot phenomenon</span></span><br><span class="line"><span class="comment">-- the count cannot be reset.  If you need a version that resets the</span></span><br><span class="line"><span class="keyword">count</span>, <span class="keyword">consider</span> <span class="keyword">using</span> a &#123;@<span class="keyword">link</span> CyclicBarrier&#125;.</span><br></pre></td></tr></table></figure>
<p>分析完了CyclicBarrier后，下面分析CountDownLatch，CountDownLatch用于同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。CountDownLatch典型的用法是将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。当每一个任务完成时，都会在这个锁存器上调用countDown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束</p>
<p>CountDownLatch与CyclicBarrier的区别另一个点就是CountDownLatch的count计数 不可以被重设置，CyclicBarrier的线程结束后会自动开启下一代generation.</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Driver &#123; <span class="comment">// ...</span></span><br><span class="line">    void main<span class="literal">()</span> throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch startSignal = <span class="keyword">new</span> <span class="constructor">CountDownLatch(1)</span>;</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> <span class="constructor">CountDownLatch(N)</span>;</span><br><span class="line"></span><br><span class="line">        for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">new</span> Worker(<span class="params">startSignal</span>, <span class="params">doneSignal</span>)</span>).start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span><span class="constructor">SomethingElse()</span>;            <span class="comment">// don't let run yet</span></span><br><span class="line">        startSignal.count<span class="constructor">Down()</span>;      <span class="comment">// let all threads proceed</span></span><br><span class="line">        <span class="keyword">do</span><span class="constructor">SomethingElse()</span>;</span><br><span class="line">        doneSignal.await<span class="literal">()</span>;           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Worker implements Runnable &#123;</span><br><span class="line">    <span class="keyword">private</span> final CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> final CountDownLatch doneSignal;</span><br><span class="line">    <span class="constructor">Worker(CountDownLatch <span class="params">startSignal</span>, CountDownLatch <span class="params">doneSignal</span>)</span> &#123;</span><br><span class="line">        this.startSignal = startSignal;</span><br><span class="line">        this.doneSignal = doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startSignal.await<span class="literal">()</span>;</span><br><span class="line">            <span class="keyword">do</span><span class="constructor">Work()</span>;</span><br><span class="line">            doneSignal.count<span class="constructor">Down()</span>;</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void <span class="keyword">do</span><span class="constructor">Work()</span> &#123;<span class="operator"> ... </span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： 主线程创建N个worker线程，worker线程等所有线程创建成功，主线程说可以启动后，同时启动。 主线程执行其他操作，等待所有线程都执行完毕。</p>
<p>主线程在 startSignal.countDown()出启动worker线程 ， worker线程在startSignal.await 出去等待主线程启动他们</p>
<p>worker线程在doneSignal.countDown() 处 告诉主线程自己执行完毕，主线程在 doneSignal.await处等待所有worker线程执行完毕。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="keyword">class</span> <span class="symbol">Sync</span> <span class="symbol">extends</span> <span class="symbol">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">4982264981922014374</span>L;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="built_in">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> getCount() &#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁，只有当锁的数量为0 的时候 才可以获取</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> tryAcquireShared(<span class="built_in">int</span> acquires) &#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  尝试释放锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean tryReleaseShared(<span class="built_in">int</span> releases) &#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="built_in">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 释放一个资源</span></span><br><span class="line">            <span class="built_in">int</span> nextc = c<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 数据结构复用  <a href="/post/b6468daf.html" title="&lt;b&gt;Aqs&lt;&#x2F;b&gt;"><b>Aqs</b></a> 的数据结构。<br><img src="../resource/java/CountDownLatch%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// await是尝试获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h2><p>// countDown 是释放锁资源</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> countDown() &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getCount"><a href="#getCount" class="headerlink" title="getCount"></a>getCount</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> sync.<span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>有了Aqs的基础，CountDownLatch基本没有新东西，CountDownLatch复用AQS的sync队列，初始化的时候设置sync队列的state为n，每次调用countDown方法的时候，就释放一个锁资源，await是尝试获取锁资源，在重写的Sync中可以发现，只有现在被占用的锁资源为0的时候，才可以获取，也就是调用await的线程必须等待n次调用countDown之后才可以获取锁资源。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>CyclicBarrier源码分析</title>
    <url>/post/3bd81454.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">A synchronization aid that allows <span class="keyword">a</span> <span class="built_in">set</span> <span class="keyword">of</span> threads <span class="built_in">to</span> all <span class="built_in">wait</span> <span class="keyword">for</span></span><br><span class="line"><span class="keyword">each</span> other <span class="built_in">to</span> reach <span class="keyword">a</span> common barrier point.  CyclicBarriers are</span><br><span class="line">useful <span class="keyword">in</span> programs involving <span class="keyword">a</span> fixed sized party <span class="keyword">of</span> threads that</span><br><span class="line">must occasionally <span class="built_in">wait</span> <span class="keyword">for</span> <span class="keyword">each</span> other. The barrier is called</span><br><span class="line">&lt;em&gt;cyclic&lt;/em&gt; because <span class="keyword">it</span> can be re-used <span class="keyword">after</span> <span class="keyword">the</span> waiting threads</span><br><span class="line">are released.</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier用于所有互相等待彼此到达一个共同点，对于固定大小线程互相等待的场景比较适用</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[][] data;</span><br><span class="line">    <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> myRow;</span><br><span class="line">        Worker(<span class="keyword">int</span> row) &#123; myRow = row; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!done()) &#123;</span><br><span class="line">            processRow(myRow);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solver</span><span class="params">(<span class="keyword">float</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        data = matrix;</span><br><span class="line">        N = matrix.length;</span><br><span class="line">        Runnable barrierAction =</span><br><span class="line">        <span class="keyword">new</span> Runnable() &#123; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; mergeRows(...); &#125;&#125;;</span><br><span class="line">        barrier = <span class="keyword">new</span> CyclicBarrier(N, barrierAction);</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(i));</span><br><span class="line">            threads.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads)</span><br><span class="line">            thread.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： 等待所有线程执行完processRow之后执行mergeRows。 thread.join() 此处只是为了确保所有线程都已经退出了，跟前面的语义无关系</p>
<h1 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示屏障是否已经破坏</span></span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">// 参与线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">//都达到等待点后 最后一个线程执行的操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">// 当前的代</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"><span class="comment">//正在等待进入屏障的线程数目</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始下一代  先唤醒所有  重试代</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> nextGeneration() &#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    <span class="keyword">count</span> = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">dowait</span><span class="params">(<span class="keyword">false</span>, <span class="number">0</span>L)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待条件发生</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前带</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">//  已经被打破 则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">// 线程被中断 打破屏障</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数-1</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">//如果当前线程是最后一个</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">           <span class="comment">// 并且没有执行过最后的指令</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 设置执行结果 并且开启下一代</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 失败 则打破屏障</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 没有设置超时时间</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    <span class="comment">// 直接等待条件发生</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 限时等待</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果屏障被打破 抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            <span class="comment">// 如果已经开启下一代 直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            <span class="comment">//  等待超时 抛出超时异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： </p>
<ol>
<li>dowait主要是阻塞当前线程</li>
<li>如果其发现自己是最后一个，则执行后续操作，并且开启下一代 唤醒所有等待者</li>
<li>如果超时，直接打破屏障，抛出超时异常。否则等待</li>
</ol>
<h2 id="nextGeneration"><a href="#nextGeneration" class="headerlink" title="nextGeneration"></a>nextGeneration</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void next<span class="constructor">Generation()</span> &#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signal<span class="constructor">All()</span>;</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> <span class="constructor">Generation()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： 唤醒所有线程，开启下一次屏障代</p>
<h2 id="breakBarrier"><a href="#breakBarrier" class="headerlink" title="breakBarrier"></a>breakBarrier</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： 设置打破标志，唤醒所有线程。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>可重入锁其实是Aqs的实现，ArrayBlockQueue内部用到了可重入锁和Condition等待队列，可以参考<br> <a href="/post/4b83aa2d.html" title="&lt;b&gt;ReentrantLock源码分析&lt;&#x2F;b&gt;"><b>ReentrantLock源码分析</b></a><br>  <a href="/post/b6468daf.html" title="&lt;b&gt;Aqs源码解析&lt;&#x2F;b&gt;"><b>Aqs源码解析</b></a></p>
<p>有了Aqs的基础，可以说上面的源码非常的简单，只是使用到了AQS的await队列，在此基础上增加一个等待线程数的判断，如果等待线程数为0，则直接唤醒所有线程，清空等待队列。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedBlockQueue源码解析</title>
    <url>/post/ca50378a.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p> ArrayBlckQueue使用了数组来实现阻塞队列，但是数组实现的阻塞队列有个问题是，其大小始终都是确定的。于是便有了LinkedBlockQueue,从名字我们就可以发现，其是通过链表实现的</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">LinkedBlockingQueue</span>&lt;<span class="type">Integer</span>&gt; abq;</span><br><span class="line">    public <span class="type">Producer</span>(<span class="type">LinkedBlockingQueue</span>&lt;<span class="type">Integer</span>&gt; abq) &#123;</span><br><span class="line">        <span class="keyword">this</span>.abq = abq;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">System</span>.out.println(<span class="string">"put "</span> + i);</span><br><span class="line">                abq.put(i);</span><br><span class="line">                <span class="type">Thread</span>.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">LinkedBlockingQueue</span>&lt;<span class="type">Integer</span>&gt; abq;</span><br><span class="line">    public <span class="type">Consumer</span>(<span class="type">LinkedBlockingQueue</span>&lt;<span class="type">Integer</span>&gt; abq) &#123;</span><br><span class="line">        <span class="keyword">this</span>.abq = abq;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">System</span>.out.println(<span class="string">"take "</span> + abq.take());</span><br><span class="line">                <span class="type">Thread</span>.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">LinkedBlockingQueue</span>&lt;<span class="type">Integer</span>&gt; abq = <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;<span class="type">Integer</span>&gt;();</span><br><span class="line">        <span class="type">Producer</span> p1 = <span class="keyword">new</span> <span class="type">Producer</span>(abq);</span><br><span class="line">        <span class="type">Consumer</span> c1 = <span class="keyword">new</span> <span class="type">Consumer</span>(abq);</span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 由于LinkedBlockingQueue是一个链表结构，所以当不设置大小的时候，表示的是大小无限制，那么对于生产者来说，其实就相当于无限制生产，消费者无数据消费的时候会被阻塞，适用于生产者性能远远差于消费者的时候。不推荐不设限制</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; <span class="keyword">next</span>;</span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>



<p><img src="../resource/java/%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt=""></p>
<p>可重入锁其实是Aqs的实现，ArrayBlockQueue内部用到了可重入锁和Condition等待队列，可以参考<br> <a href="/post/4b83aa2d.html" title="&lt;b&gt;ReentrantLock源码分析&lt;&#x2F;b&gt;"><b>ReentrantLock源码分析</b></a><br>  <a href="/post/b6468daf.html" title="&lt;b&gt;Aqs源码解析&lt;&#x2F;b&gt;"><b>Aqs源码解析</b></a></p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">private void enqueue(<span class="keyword">Node</span><span class="title">&lt;E</span>&gt; <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">    // assert</span> putLock.isHeldByCurrentThread();</span><br><span class="line">    // assert last.next == null;</span><br><span class="line">    last = last.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>

<p>说明: enqueue极其简单，直接添加到链表尾部，调用方保证线程安全 </p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> signalNotEmpty() &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> signalNotFull() &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> put(E e) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否满了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">count</span>.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 满了等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入链表尾部</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 计数增加</span></span><br><span class="line">        c = <span class="keyword">count</span>.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">           <span class="comment">// 唤醒其他生产者</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原来的c==0 表示有消费者在等待</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 唤醒消费者</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 基本与ArrayBlockQueue的流程一致</p>
<h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    <span class="comment">// 超过容量直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span>.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span>.get() &lt; capacity) &#123;</span><br><span class="line">            <span class="comment">//容量充足 放入链尾</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = <span class="keyword">count</span>.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">               <span class="comment">//唤醒其他生产者</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原来的c==0 表示有消费者在等待</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 唤醒消费者</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h3><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">    // <span class="keyword">assert</span> takeLock.isHeldByCurrentThread();</span><br><span class="line">    // <span class="keyword">assert</span> head.<span class="attr">item</span> == <span class="literal">null</span>;</span><br><span class="line">    Node&lt;E&gt; <span class="attr">h</span> = head;</span><br><span class="line">    Node&lt;E&gt; <span class="attr">first</span> = h.next;</span><br><span class="line">    h.<span class="attr">next</span> = h; // help GC</span><br><span class="line">    <span class="attr">head</span> = first;</span><br><span class="line">    E <span class="attr">x</span> = first.item;</span><br><span class="line">    first.<span class="attr">item</span> = <span class="literal">null</span>;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： 直接移除头结点并且返回头结点的值。 注意头结点是h.next  head是一个空节点  用来表示链表起始的</p>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">E</span> take() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">    <span class="type">E</span> x;</span><br><span class="line">    int <span class="built_in">c</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="built_in">count</span> = this.<span class="built_in">count</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 空就等待</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span>.<span class="keyword">get</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除头节点并且返回锁</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="built_in">c</span> = <span class="built_in">count</span>.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">c</span> &gt; <span class="number">1</span>)</span><br><span class="line">           <span class="comment">// 如果还有值 就唤醒其他消费者</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果原来满了 表名有生产者在等待 唤醒生产者</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">c</span> == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E poll() &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger <span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span>.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果可以获取则获取  否则返回null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span>.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = <span class="keyword">count</span>.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E peek() &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">if</span> (count.<span class="keyword">get</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 直接获取头节点的值</span></span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    putLock.<span class="keyword">lock</span>();</span><br><span class="line">    takeLock.<span class="keyword">lock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 加读写锁</span></span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 链表遍历设置null</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p, h = head; (p = h.next) != <span class="literal">null</span>; h = p) &#123;</span><br><span class="line">            h.next = h;</span><br><span class="line">            p.item = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置头结点为尾节点</span></span><br><span class="line">        head = last;</span><br><span class="line">        <span class="comment">// assert head.item == null &amp;&amp; head.next == null;</span></span><br><span class="line">        <span class="keyword">if</span> (count.getAndSet(<span class="number">0</span>) == capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedBlockQueue与ArrayBlockQueue基本一样，有三点区别：</p>
<ol>
<li>LinkedBlockQueue是链表实现，ArrayBlockQueue是数组实现</li>
<li>LinkedBlockQueue是双锁，读写锁分离，ArrayBlockQueue是单锁</li>
<li>LinkedBlockQueue是判断原始消费者等待的时候，才唤醒消费者，原始有生产者等待的时候，才唤醒生产者，而ArrayBlockQueue是放入数据的时候就唤醒消费者，消费数据的时候就唤醒生产者。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>线程安全集合</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayBlockQueue源码分析</title>
    <url>/post/a1e0d9b8.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>ArrayBlockingQueue是一个阻塞队列，支持多任务并发操作，在线程池创建的时候会经常使用到。 是一个先进先出的队列。为生产者消费者模型提供了很好的支撑。</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Producer</span> <span class="symbol">extends</span> <span class="symbol">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; abq;</span><br><span class="line">    <span class="keyword">public</span> Producer(ArrayBlockingQueue&lt;Integer&gt; abq) &#123;</span><br><span class="line">        <span class="keyword">this</span>.abq = abq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"put "</span> + i);</span><br><span class="line">                abq.put(i);</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Consumer</span> <span class="symbol">extends</span> <span class="symbol">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; abq;</span><br><span class="line">    <span class="keyword">public</span> Consumer(ArrayBlockingQueue&lt;Integer&gt; abq) &#123;</span><br><span class="line">        <span class="keyword">this</span>.abq = abq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"take "</span> + abq.take());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ArrayBlockingQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; abq = new ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">        Producer p1 = new Producer(abq);</span><br><span class="line">        Consumer c1 = new Consumer(abq);</span><br><span class="line">        </span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： ArrayBlockingQueue为生产者和消费者模型提供了很好的支撑，上诉如果生产者快，将队列塞满后则生产者会等待被put阻塞，消费则取完数据，则消费者会等待被take阻塞。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">// 等待获取条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"> <span class="comment">// 等待存放条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>通过属性可以看出来，ArrayBlockQueue 内部实现是数组和可重入锁来实现的<br><img src="../resource/java/%E6%95%B0%E7%BB%84.jpg" alt=""></p>
<p>可重入锁其实是Aqs的实现，ArrayBlockQueue内部用到了可重入锁和Condition等待队列，可以参考<br> <a href="/post/4b83aa2d.html" title="&lt;b&gt;ReentrantLock源码分析&lt;&#x2F;b&gt;"><b>ReentrantLock源码分析</b></a><br>  <a href="/post/b6468daf.html" title="&lt;b&gt;Aqs源码解析&lt;&#x2F;b&gt;"><b>Aqs源码解析</b></a></p>
<h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void enqueue(E x) &#123;</span><br><span class="line">    <span class="comment">// 获取素组</span></span><br><span class="line">    final Object[] <span class="built_in">items</span> = this.<span class="built_in">items</span>;</span><br><span class="line">    <span class="comment">// 放入元素 </span></span><br><span class="line">    <span class="built_in">items</span>[putIndex] = x;</span><br><span class="line">    <span class="comment">// 元素已经放满</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == <span class="built_in">items</span>.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计数加1</span></span><br><span class="line">    <span class="built_in">count</span>++;</span><br><span class="line">    <span class="comment">// 唤醒await链表中等待的消费者</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： enqueue是一个内部方法，外层调用这回判断是否已满。所以此处不进行先置判断</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 满了</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 等待 加入await的链表中</span></span><br><span class="line">            notFull.<span class="keyword">await</span>();</span><br><span class="line">        <span class="comment">// 可以放入通过enqueue方法放入</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 首先加锁，判断是否满了，如果满了，则等待。没满则放入队列。</p>
<h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">offer</span>(<span class="params">E e</span>)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否满了 如果满了 返回false 表示不可以加了</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没满 直接添加 返回true 添加成功</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：offer尝试添加，失败返回false，加锁 通过判断是否已满来判定是否可以添加</p>
<h3 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E dequeue() &#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></span><br><span class="line">    <span class="comment">// 取takeIndex数据</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">// 把takeIndex数据设置为null takeIndex 后移</span></span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计数-1</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 唤醒生产者</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： 上层加锁，private方法，只要取出一个数据，就唤醒生产者</p>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已空</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 加入await等待链表</span></span><br><span class="line">            notEmpty.<span class="keyword">await</span>();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明: 加锁，如果空了，则等待数据生产 ，否则直接取数据</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="comment">// 加锁 不等待，空了直接返回null</span></span><br><span class="line">        final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：加锁 直接获取。</p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    final Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = count;</span><br><span class="line">        <span class="comment">// 空 不处理</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            final <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="comment">// 从takeIndex处 清空 设置null 到putIndex</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                items[i] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            <span class="comment">// 重新设置putIndex</span></span><br><span class="line">            takeIndex = putIndex;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">                itrs.queueIsEmpty();</span><br><span class="line">            <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">lock</span>.hasWaiters(notFull); k--)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 清空操作是从takeIndex开始到putIndex全部设置为Null,之后唤醒生产者线程。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>有了Aqs和ReentrantLock的基础，ArrayBlockQueue可以说非常简单，只是对ReentrantLock和Aqs的上层应用。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>线程安全集合</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentSkipListMap源码分析</title>
    <url>/post/b5837189.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>LinkedHashMap和TreeMap实现了Hash表的有序访问，但是LinkedHashMap和TreeMap都不是线程安全的，ConcurrentHashMap实现了线程安全，却又是无序的Hashmap,而ConcurrentSkipListMap，即是线程安全的，也是有序的hash表实现。</p>
<p>其内部有序性是通过跳表来实现的。</p>
<h2 id="什么是跳表"><a href="#什么是跳表" class="headerlink" title="什么是跳表"></a>什么是跳表</h2><p>跳表（SkipList）是一种随机化的数据结构，通过“空间来换取时间”的一个算法，建立多级索引，实现以二分查找遍历一个有序链表。时间复杂度等同于红黑树，O(log n)。但实现却远远比红黑树要简单。</p>
<p>结构：</p>
<p><img src="../resource/java/%E8%B7%B3%E8%A1%A8.jpg" alt=""><br><img src="../resource/java/%E8%B7%B3%E8%A1%A8%E6%9F%A5%E6%89%BE.jpg" alt=""></p>
<p>跳表可参考 <a href="">https://time.geekbang.org/column/article/42896</a></p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    ConcurrentSkipListMap&lt;<span class="keyword">String</span>, Integer&gt; cslm = <span class="keyword">new</span> ConcurrentSkipListMap&lt;<span class="keyword">String</span>, Integer&gt;();</span><br><span class="line">    cslm.put(<span class="string">"2"</span>, <span class="number">24</span>);</span><br><span class="line">    cslm.put(<span class="string">"1"</span>, <span class="number">24</span>);</span><br><span class="line">    cslm.put(<span class="string">"11"</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">key</span> :cslm.keySet()) &#123;</span><br><span class="line">        System.out.<span class="built_in">print</span>(<span class="string">"["</span> + <span class="built_in">key</span> + <span class="string">","</span> + cslm.<span class="built_in">get</span>(<span class="built_in">key</span>) + <span class="string">"] "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="built_in">println</span>();</span><br><span class="line">    cslm.remove(<span class="string">"2"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">key</span> :cslm.keySet()) &#123;</span><br><span class="line">        System.out.<span class="built_in">print</span>(<span class="string">"["</span> + <span class="built_in">key</span> + <span class="string">","</span> + cslm.<span class="built_in">get</span>(<span class="built_in">key</span>) + <span class="string">"] "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">24</span>] [<span class="number">11</span>,<span class="number">24</span>] [<span class="number">2</span>,<span class="number">24</span>] </span><br><span class="line">[<span class="number">1</span>,<span class="number">24</span>] [<span class="number">11</span>,<span class="number">24</span>]</span><br></pre></td></tr></table></figure>

<p>说明： 按照key的字符串顺序排序的，所以 11&lt;2</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"><span class="symbol">*</span> Head nodes          Index nodes</span><br><span class="line"><span class="symbol">*</span> +-+    right        +-+                      +-+</span><br><span class="line"><span class="symbol">*</span> |<span class="string">2</span>|<span class="string">----------------&gt;</span>|<span class="string"> </span>|<span class="string">---------------------&gt;</span>|<span class="string"> </span>|<span class="string">-&gt;null</span></span><br><span class="line"><span class="string">* +-+                 +-+                      +-+</span></span><br><span class="line"><span class="string">*  </span>|<span class="string"> down              </span>|<span class="string">                        </span>|</span><br><span class="line"><span class="symbol">*</span>  v                   v                        v</span><br><span class="line"><span class="symbol">*</span> +-+            +-+  +-+       +-+            +-+       +-+</span><br><span class="line"><span class="symbol">*</span> |<span class="string">1</span>|<span class="string">-----------&gt;</span>|<span class="string"> </span>|<span class="string">-&gt;</span>|<span class="string"> </span>|<span class="string">------&gt;</span>|<span class="string"> </span>|<span class="string">-----------&gt;</span>|<span class="string"> </span>|<span class="string">------&gt;</span>|<span class="string"> </span>|<span class="string">-&gt;null</span></span><br><span class="line"><span class="string">* +-+            +-+  +-+       +-+            +-+       +-+</span></span><br><span class="line"><span class="string">*  v              </span>|<span class="string">    </span>|<span class="string">         </span>|<span class="string">              </span>|<span class="string">         </span>|</span><br><span class="line"><span class="symbol">*</span> Nodes  next     v    v         v              v         v</span><br><span class="line"><span class="symbol">*</span> +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br><span class="line"><span class="symbol">*</span> |<span class="string"> </span>|<span class="string">-&gt;</span>|<span class="string">A</span>|<span class="string">-&gt;</span>|<span class="string">B</span>|<span class="string">-&gt;</span>|<span class="string">C</span>|<span class="string">-&gt;</span>|<span class="string">D</span>|<span class="string">-&gt;</span>|<span class="string">E</span>|<span class="string">-&gt;</span>|<span class="string">F</span>|<span class="string">-&gt;</span>|<span class="string">G</span>|<span class="string">-&gt;</span>|<span class="string">H</span>|<span class="string">-&gt;</span>|<span class="string">I</span>|<span class="string">-&gt;</span>|<span class="string">J</span>|<span class="string">-&gt;</span>|<span class="string">K</span>|<span class="string">-&gt;null</span></span><br><span class="line"><span class="string">* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span></span><br><span class="line"><span class="string">*</span></span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/ConcurrentSkipListMap%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<h2 id="重要方法："><a href="#重要方法：" class="headerlink" title="重要方法："></a>重要方法：</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base Level Header</span></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> Object BASE_HEADER = new Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最顶层的的headIndex</span></span><br><span class="line"><span class="keyword">private</span> transient volatile HeadIndex&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">// map视图</span></span><br><span class="line"><span class="keyword">private</span> transient KeySet&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">private</span> transient EntrySet&lt;K,V&gt; entrySet;</span><br><span class="line"><span class="keyword">private</span> transient Values&lt;V&gt; values;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> EQ = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> LT = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> GT = <span class="number">0</span>; <span class="comment">// Actually checked as !LT</span></span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="keyword">class</span> <span class="symbol">Node</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    volatile Object value;</span><br><span class="line">    volatile Node&lt;K,V&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">static <span class="keyword">class</span> <span class="symbol">Index</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">    volatile Index&lt;K,V&gt; right;</span><br><span class="line">&#125;</span><br><span class="line">static <span class="keyword">final</span> <span class="keyword">class</span> <span class="symbol">HeadIndex</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt; <span class="symbol">extends</span> <span class="symbol">Index</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="index类"><a href="#index类" class="headerlink" title="index类"></a>index类</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">    <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// CSA 设置right指针</span></span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">casRight</span><span class="params">(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> UNSAFE.<span class="title">compareAndSwapObject</span><span class="params">(<span class="keyword">this</span>, rightOffset, cmp, val)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是已经删除的节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">indexesDeletedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.value == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前节点的right节点修改为 newSucc</span></span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; n = node;</span><br><span class="line">        newSucc.right = succ;</span><br><span class="line">        <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将succ节点删除掉</span></span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： index 提供了基础的判断节点是否删除，和进行right指针修改的能力</p>
<h3 id="Node-类"><a href="#Node-类" class="headerlink" title="Node 类"></a>Node 类</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">K,V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> Object value;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// CAS 设置node 的value值</span></span><br><span class="line">    Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean casValue(Object cmp, Object <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, <span class="keyword">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS 设置next指针</span></span><br><span class="line">    boolean casNext(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, <span class="keyword">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isMarker() &#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否是头</span></span><br><span class="line">    boolean isBaseHeader() &#123;</span><br><span class="line">        <span class="keyword">return</span> value == BASE_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入一个 marker节点</span></span><br><span class="line">    boolean appendMarker(Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> casNext(f, new Node&lt;K,V&gt;(f));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        <span class="comment">// f为当前结点的后继并且b为当前结点的前驱</span></span><br><span class="line">        <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">              <span class="comment">// f为空或者f的value不为本身 也就是不是 marker节点</span></span><br><span class="line">              <span class="comment">// 当前结点后添加一个marker结点，并且当前结点的后继为marker，marker结点的后继为f</span></span><br><span class="line">                casNext(f, new Node&lt;K,V&gt;(f));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">             <span class="comment">// f不是空 或者是标记节点  设置b 的 next 为 f的next 也就是直接删除当前节点</span></span><br><span class="line">                b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取node的值</span></span><br><span class="line">    V getValidValue() &#123;</span><br><span class="line">        Object v = value;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">this</span> || v == BASE_HEADER)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span> V vv = (V)v;</span><br><span class="line">        <span class="keyword">return</span> vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br>node节点封装了删除节点标记节点等等基础操作。</p>
<h3 id="findPredecessor"><a href="#findPredecessor" class="headerlink" title="findPredecessor"></a>findPredecessor</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取比key 小的 baseLevel node 或者返回baseLevel header 如果没找到的话， 在查找的时候，清除已经删除的节点的 index</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K,V&gt; findPredecessor(<span class="keyword">Object</span> <span class="built_in">key</span>, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// q = head  从head 开始找 head是最顶层的 headIndex 向后查找</span></span><br><span class="line">        <span class="comment">// 此处在查找节点应该在的index 位置 并且移除了null节点的index索引</span></span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不为null</span></span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                K k = n.<span class="built_in">key</span>;</span><br><span class="line">                <span class="comment">// 如果节点的value是空 ，表示已经删除 把index删除</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 删除r 这个index 由于是CAS可能失败 失败就重新走循环流程</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    <span class="comment">// 删除成功，处理下一个节点</span></span><br><span class="line">                    r = q.right;         <span class="comment">// reread r</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 比较key 和当前node的k 如果 大于0 也就是 key&gt;k 则享有移动</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, <span class="built_in">key</span>, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 右移 下一个</span></span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了节点应该在的 index  q r  比q大 比r小</span></span><br><span class="line">            <span class="comment">// 如果q.down木有了 表示是最底层的了，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">            <span class="comment">// 否则下移 </span></span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../resource/java/ConcurrentSkipListMap%E6%9F%A5%E6%89%BE%E5%89%8D%E9%A9%B1.jpg" alt=""></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取某个值</span></span><br><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取key的值</span></span><br><span class="line"><span class="keyword">private</span> V doGet(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找到key对应的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(<span class="built_in">key</span>, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="keyword">Object</span> v; <span class="built_in">int</span> c;</span><br><span class="line">            <span class="comment">// 如果节点是null 则跳出循环 返回null</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// 查看下一个节点 next</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">// 校验 未变更</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 判断next 是否删除 如果删除 </span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">               <span class="comment">// 直接删除 或者标记节点</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果b为空，则继续下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// key==n.key  直接返回  找到了</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, <span class="built_in">key</span>, n.<span class="built_in">key</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                @SuppressWarnings(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 小于0 表示 没找到 返回</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// 向后</span></span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：key对应的节点，肯定在其前驱之后，于是先查找前驱节点，然后向后找key，沿途清理无效节点。找到返回v，没找到则返回null</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(<span class="built_in">key</span>, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> V doPut(K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent) &#123;</span><br><span class="line">    Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">// 此循环 插入节点</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找前驱节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(<span class="built_in">key</span>, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="comment">// 表示的是不在链表尾</span></span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">Object</span> v; <span class="built_in">int</span> c;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="comment">// 不一致 重试</span></span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// n.value是空，标记删除</span></span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果b已经删除 则重试</span></span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果key比n大 向后移动</span></span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, <span class="built_in">key</span>, n.<span class="built_in">key</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 相等，csa替换值，返回</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        @SuppressWarnings(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置值失败 重试</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加节点</span></span><br><span class="line">            z = <span class="keyword">new</span> Node&lt;K,V&gt;(<span class="built_in">key</span>, value, n);</span><br><span class="line">            <span class="comment">// b的next设置为新节点 </span></span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机数  此处是进行跳表结构的调整，随机数查看是否要调整跳表结构</span></span><br><span class="line">    <span class="built_in">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">        <span class="built_in">int</span> level = <span class="number">1</span>, <span class="built_in">max</span>;</span><br><span class="line">        <span class="comment">// level = rnd 表示从右向左  第2位开始  连续1的个数</span></span><br><span class="line">        <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            ++level;</span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        <span class="comment">// 从 下到上 创建index节点 并且设置 down指针</span></span><br><span class="line">        <span class="keyword">if</span> (level &lt;= (<span class="built_in">max</span> = h.level)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果level太大</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">            <span class="comment">// 向上一级新增一个层级</span></span><br><span class="line">            level = <span class="built_in">max</span> + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">            <span class="comment">// 生成 index节点</span></span><br><span class="line">            @SuppressWarnings(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 遍历设置index节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">                h = head;</span><br><span class="line">                <span class="built_in">int</span> oldLevel = h.level;</span><br><span class="line">                <span class="comment">// 可能别的线程已经新增了层级，不在新增</span></span><br><span class="line">                <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                <span class="comment">// 为每一新层生成 headIndex节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                    newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                <span class="comment">// 设置头结点</span></span><br><span class="line">                <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                    h = newh;</span><br><span class="line">                    <span class="comment">// idx赋值为之前层级的头结点，并将level赋值为之前的层级</span></span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入index节点</span></span><br><span class="line">        <span class="comment">// find insertion points and splice in</span></span><br><span class="line">        <span class="built_in">splice</span>: <span class="keyword">for</span> (<span class="built_in">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">            <span class="built_in">int</span> j = h.level;</span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                <span class="comment">// 头结点或者idx结点为空 退出</span></span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> <span class="built_in">splice</span>;</span><br><span class="line">                <span class="comment">// r!=null 表示有右节点</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                    <span class="comment">// 比较值</span></span><br><span class="line">                    <span class="built_in">int</span> c = cpr(cmp, <span class="built_in">key</span>, n.<span class="built_in">key</span>);</span><br><span class="line">                    <span class="comment">// 删除失效节点</span></span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果&gt;0 表示需要插入的还在右边 继续查找</span></span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  判断是否有其他线程将 level 升了一层  如果是 则循环重试</span></span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                    <span class="comment">// 把 r节点 插入到 q , t 之间 </span></span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                       <span class="comment">// 失败不插入</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                    <span class="comment">// t 为null 则删除t</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        findNode(<span class="built_in">key</span>);</span><br><span class="line">                        <span class="keyword">break</span> <span class="built_in">splice</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 到达最底层，跳出循环 </span></span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> <span class="built_in">splice</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断当前节点的上层已经处理完毕了 则可以处理下层了</span></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: put的核心点在于两步：</p>
<ol>
<li>插入节点</li>
<li>新增index(两种情况，一种是只增加index，另一种是加index并且加一个层级)<ol>
<li>不新增层级</li>
<li>新增层级</li>
</ol>
</li>
<li>处理新增的index的next指针</li>
</ol>
<p><img src="../resource/java/ConcurrentSkipListMap_put1.jpg" alt=""><br><img src="../resource/java/ConcurrentSkipListMap_put2.jpg" alt=""><br><img src="../resource/java/ConcurrentSkipListMap_put3.jpg" alt=""></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(<span class="built_in">key</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除一个节点</span></span><br><span class="line"><span class="keyword">final</span> V doRemove(<span class="keyword">Object</span> <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找前驱</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(<span class="built_in">key</span>, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="keyword">Object</span> v; <span class="built_in">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">// 下面3不 移除空节点</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 小于 key&lt;n key 说明中不到 退出</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, <span class="built_in">key</span>, n.<span class="built_in">key</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// &gt;0 则继续向后查找</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了  如果需要校验value的场景</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// 把value设置为null </span></span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//  添加marker节点 在利用findNode删除</span></span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(<span class="built_in">key</span>);                  <span class="comment">// retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(<span class="built_in">key</span>, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 尝试减少层级</span></span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            @SuppressWarnings(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：删除操作总共4步</p>
<ol>
<li>找到前驱</li>
<li>找到节点</li>
<li>设置value 添加marker节点</li>
<li>删除节点和marker节点<br><img src="../resource/java/ConcurrentSkipListMap_remove.jpg" alt=""></li>
</ol>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">size</span>() &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; n = findFirst(); n != <span class="keyword">null</span>; n = n.<span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n.getValidValue() != <span class="keyword">null</span>)</span><br><span class="line">            ++<span class="keyword">count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">count</span> &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>) <span class="keyword">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>ConcurrentSkipListMap是对于跳表的一个典型的利用场景，并且利用CAS 自旋 删除的marker节点等等操作实现了线程安全。很巧妙</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>线程安全集合</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteArrayList源码分析</title>
    <url>/post/715fcc86.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>CopyOnWriteArrayList 作为ArrayList的线程安全类，无疑是很重要的，从名字上我们可以感知到一二，该集合就是在ArrayList的基础上，在需要修改的时候通过CopyOnWrite来实现的线程安全，那么是否是这样呢？我们来看看源码</p>
<h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">PutThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Integer&gt; cowal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PutThread(CopyOnWriteArrayList&lt;Integer&gt; cowal) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cowal = cowal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">100</span>; i &lt; <span class="number">110</span>; i++) &#123;</span><br><span class="line">                cowal.add(i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">CopyOnWriteArrayListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; cowal = new CopyOnWriteArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cowal.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        PutThread p1 = new PutThread(cowal);</span><br><span class="line">        p1.start();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = cowal.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.print(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        iterator = cowal.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.print(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可重入锁</span></span><br><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部是数组结构</span></span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/%E6%95%B0%E7%BB%84.jpg" alt=""></p>
<h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span>(<span class="params">E e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 加可重入锁</span></span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取当前数组大小</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 进行数组复制</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 把当前元素加入数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置为新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： add 方法相对比较简单，即使加入可重入锁，然后在进行数组复制，把需要add加入的元素放入到新数组的尾部</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接获取某个数组的index处的元素</span></span><br><span class="line"><span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="keyword">get</span>(Object[] a, int index) &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="keyword">get</span>(int index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置某个位置的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span>(<span class="params"><span class="keyword">int</span> index, E element</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取旧数组index处的元素</span></span><br><span class="line">        E oldValue = <span class="keyword">get</span>(elements, index);</span><br><span class="line">        <span class="comment">// 不相等 通过素组复制设置新值</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//相同，则吧array设置为elements </span></span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：赋予新值的过程也是通过加锁，数组复制来实现的。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> E remove(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    // 加锁</span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = this.<span class="keyword">lock</span>;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取旧数组</span><br><span class="line">        <span class="keyword">Object</span>[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> len = elements.length;</span><br><span class="line">        E oldValue = <span class="keyword">get</span>(elements, <span class="keyword">index</span>);</span><br><span class="line">        // 获取需要移动的数组的数目</span><br><span class="line">        <span class="type">int</span> numMoved = len - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">        // 不用移动，则直接数组复制</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            // 通过数组复制进行移动</span><br><span class="line">            <span class="keyword">Object</span>[] newElements = <span class="built_in">new</span> <span class="keyword">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">System</span>.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, <span class="keyword">index</span>);</span><br><span class="line">            <span class="keyword">System</span>.arraycopy(elements, <span class="keyword">index</span> + <span class="number">1</span>, newElements, <span class="keyword">index</span>,</span><br><span class="line">                                numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接遍历旧数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">        action.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="COWIterator"><a href="#COWIterator" class="headerlink" title="COWIterator"></a>COWIterator</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;E&gt; <span class="title">implements</span> <span class="title">ListIterator</span>&lt;E&gt; &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">cursor</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cursor</span> = initialCursor;</span><br><span class="line">            snapshot = elements;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cursor</span> &lt; snapshot.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cursor</span> &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (! hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">return</span> (E) snapshot[<span class="built_in">cursor</span>++];</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">return</span> (E) snapshot[--<span class="built_in">cursor</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cursor</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cursor</span><span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>说明：  COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException</p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>通过上面的源码，我们可以发现，CopyOnWriteArrayList在进行修改数组元素的操作的时候，都是通过加锁，然后进行数组复制来实现的，此操作也是非常消耗性能的，此处便可以感知到，使用CopyOnWriteArrayList的时候，最好是读多，写少的场景。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>　CopyOnWriteArrayList的源码很简单，主要是在修改的时候，通过数组复制来实现对集合的修改，在读访问，或者是遍历的时候，访问的依旧是旧素组的快照（没有修改完成的时候）。 因此CopyOnWriteArrayList比较适用于读多写少的场景，而不适用于写多的场景，数组赋值较为消耗性能</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>线程安全集合</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码解析</title>
    <url>/post/54dc35c3.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap是最常用的集合类，也是面试中经常被问到的类，HashMap延伸出来的 线程安全的HashMap，ConcurrentHashMap无疑也是极其重要的，ConccurrentHashMap内部数据结构，实现原理等等也无疑是必须要掌握的。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><p>前面我们说过了HashMap的数据机构，其实ConcurrentHashMap与HashMap的数据结构一致，都是 数组+链表+红黑树的实现</p>
<p><img src="../resource/java/HashMap%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<h2 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h2><details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 数组最大size</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 默认并发数，1.8以前的版本需要</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"><span class="comment">// 链表转树临界值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 树转链表临界值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 链表转树时候最小的容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 每次进行转移的最小容量，避免resize 写内存竞争过多</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// sizeCtl的bit位数， sizeCtl用于大小容量控制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 允许进行resize的最大线程数目</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 计算sizeCtl的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// 节点的标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = <span class="number">-1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = <span class="number">-2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = <span class="number">-3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="comment">// 可用cpu个数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 之后的表，resize的时候使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 用于没有竞争的时候的计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">//初始化 resize控制字段</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment"> * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment"> * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment"> * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment"> * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment"> * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">//resize的时候到另一个表的时候的索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize时候使用的自旋锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// views</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p>关于 sizeCtl 变量：</p>
<p>-1 :代表table正在初始化,其他线程应该交出CPU时间片<br>-N: 表示正有N-1个线程执行扩容操作（高 16 位是 length 生成的标识符，低 16 位是扩容的线程数）<br>大于 0: 如果table已经初始化,代表table容量,默认为table大小的0.75,如果还未初始化,代表需要初始化的大小</p>
<p><img src="../resource/java/ConcurrentHashMap_sizeCtl.jpg" alt=""></p>
<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><details>
<summary><font color='red'>View Code</font></summary>


<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">public V <span class="built_in">put</span>(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">putVal</span>(<span class="built_in">key</span>, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V <span class="built_in">putVal</span>(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    <span class="comment">// k or v =null 则直接报异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> <span class="built_in">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    int hash = <span class="built_in">spread</span>(<span class="built_in">key</span>.<span class="built_in">hashCode</span>());</span><br><span class="line">    int binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] <span class="built_in">tab</span> = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        <span class="comment">// table为空 初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="built_in">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 详情见下面初始化</span></span><br><span class="line">            tab = <span class="built_in">initTable</span>();</span><br><span class="line">        <span class="comment">//  tabAt 通过Unsafe 原子性获取 索引出的值，如果为null 表示没有发生hash冲突</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = <span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="comment">//casTabAt Unsafe CAS 设置此处的值为当前节点，失败则自旋重试</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">casTabAt</span>(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</span><br><span class="line">                            new Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// f表示首节点  如果 f 的hash被设置为了moved 表示resize 进行中  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// resize进行中，本线程帮助扩容。</span></span><br><span class="line">            tab = <span class="built_in">helpTransfer</span>(<span class="built_in">tab</span>, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="built_in">null</span>;</span><br><span class="line">            <span class="comment">// 头结点加锁</span></span><br><span class="line">            <span class="built_in">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次校验头结点是否改变 无改变 执行 否则再次自旋</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//  fh&gt;0 表示 没有resize  没有 treebin  没有被compute临时保留</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 默认bicontent</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历 binCount表示遍历到的节点个数</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果找到节点 则直接设值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == <span class="built_in">key</span> ||</span><br><span class="line">                                    (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 没找到 加入链表尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                            value, <span class="built_in">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是树结构，调用树结构的putTreeVal</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).<span class="built_in">putTreeVal</span>(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                        value)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果大于树化临界点 则直接转为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="built_in">treeifyBin</span>(<span class="built_in">tab</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加用于计算size的count值 并且判断是否扩容 进行扩容  binCount 用来记录是否有冲突，默认为0 没有冲突。有冲突的时候  取值为链表长度</span></span><br><span class="line">    <span class="built_in">addCount</span>(<span class="number">1</span>L, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><img src="../resource/java/ConcurrentHashMap_put.jpg" alt=""></p>
<h3 id="initTable-初始化数组"><a href="#initTable-初始化数组" class="headerlink" title="initTable 初始化数组"></a>initTable 初始化数组</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">        <span class="comment">// 如果sizeClt&lt;0 表示 表示table正在初始化或者 扩容处理，此处应该是多线程初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0)</span><br><span class="line">            <span class="comment">// 自旋交出cpu控制权</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 设置sizeCtl 表示表由我来初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                    int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                    <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                    <span class="comment">// 设置sizeCtl n是容量 ？ 为啥是设置为这个</span></span><br><span class="line">                    <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： 由于ConcurrentHashMap是为了多线程设计，初始化也要考虑并发的问题，通过sizeCtl检测，数组table是否在被初始化中，或者在被resize中，如果在，则自旋等待，否则CAS设置sizeCtl表示由我来初始化。</p>
<h3 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer"></a>helpTransfer</h3><details>
<summary><font color='red'>View Code</font></summary>


<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// put的时候发现 hash=moved 有线程在进行扩容处理则帮助其进行扩容</span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    // table 不为空 并且 f 节点是 forwardingNode 并且有 nextTable</span><br><span class="line">    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">        // nextTab 设置为 f.nextTable</span><br><span class="line">        // 此处 标识位， 假设n=16 1000 0   rs = (32 - 5) = 27 | 1&lt;&lt; 15 =  1&lt;&lt;15+27 第16位为1 低位是 高位0个数</span><br><span class="line">        int rs = resizeStamp(tab.length);</span><br><span class="line">        // 校验值 如果 sizeCtl&lt;0 表示在扩容中  table!=null 表示已经初始化了</span><br><span class="line">        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">            // 1. sc 的高16位 如果不等于 rs(此处标志位会在trasfer的时候设定) 标识标志位变了 退出循环</span><br><span class="line">            // 2. 上面说了 rs = 16位设置1  和高位0个数 如果 rs+1 = sizeCtr 标识 高位个数-1了  也就是扩容成功了 退出循环</span><br><span class="line">            // 3. sc = rs + MAX_RESIZERS(1&lt;&lt;15 -1)   也就是说，帮忙的线程已经达到了65535个了 不需要帮忙了 (下面可以看到，帮忙的时候sc = sc+1)</span><br><span class="line">            // 4. transfer下标调整了，则退出循环</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 检测到可以帮忙，则设置sizeCtl 标志位，帮忙transfer  失败自旋</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                // 转移</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* A node inserted at head of bins during transfer operations.</span><br><span class="line">* 在进行resize 转化的时候， 头节点类型</span><br><span class="line">*/</span><br><span class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    final Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        super(MOVED, null, null, null);</span><br><span class="line">        this.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">    // 从 nextTable中找到 hash=h  key为k的节点</span><br><span class="line">    Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">        // loop to avoid arbitrarily deep recursion on forwarding nodes</span><br><span class="line">        // 自旋</span><br><span class="line">        outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; int n;</span><br><span class="line">            // 检验</span><br><span class="line">            if (k == null || tab == null || (n = tab.length) == 0 ||</span><br><span class="line">                (e = tabAt(tab, (n - 1) &amp; h)) == null)</span><br><span class="line">                return null;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int eh; K ek;</span><br><span class="line">                // 头结点的值是否相同</span><br><span class="line">                if ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                    return e;</span><br><span class="line">                // 扩容中，自旋，递归 处理</span><br><span class="line">                if (eh &lt; 0) &#123;</span><br><span class="line">                    if (e instanceof ForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        continue outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        return e.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                if ((e = e.next) == null)</span><br><span class="line">                    return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int resizeStamp(int n) &#123;</span><br><span class="line">    // 首位前 0的个数 32-length(n)</span><br><span class="line">    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p>说明： resizeStamp()是扩容标志位， 首先需要检测当前状态是否需要帮忙扩容，如果需要，则帮忙扩容，否则不进行扩容</p>
<p>是否帮助扩容检测：</p>
<ol>
<li>如果标志位变了，很可能以为这扩容完成了或者失败等等情况，则不帮忙</li>
<li>如果rs+1 = sizeCtl 表示扩容完成，则不需要帮忙了，自旋走put流程就好</li>
<li>如果帮忙的线程超过了65535，这都完不成也是没谁了，就别添乱了</li>
<li>transferIndex下标调整了，表示本次的扩容已经结束，下次的扩容开始了。重新进入判断</li>
</ol>
<h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h3><details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容转移</span></span><br><span class="line"><span class="keyword">private</span> final void transfer(Node&lt;K,V&gt;<span class="literal">[]</span> tab, Node&lt;K,V&gt;<span class="literal">[]</span> nextTab) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 多核CPU n/8/NCPU   如果结果小于 16 则去16  (为什么要/8 之后 在除以NCPU)   stride表示每个线程处理的桶的个数 最小16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>)<span class="operator"> / </span>NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">// 对转移后的数组初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab<span class="operator"> == </span>null) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            @<span class="constructor">SuppressWarnings(<span class="string">"unchecked"</span>)</span></span><br><span class="line">            <span class="comment">// 扩容为2倍 与HashMap 一样</span></span><br><span class="line">            Node&lt;K,V&gt;<span class="literal">[]</span> nt = (Node&lt;K,V&gt;<span class="literal">[]</span>)<span class="keyword">new</span> Node&lt;?,?&gt;<span class="literal">[<span class="identifier">n</span> &lt;&lt; <span class="number">1</span>]</span>;</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">           <span class="comment">// 容量超过线程</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 设置当前在扩容的标志  n 表示扩容前容量</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容后的大小</span></span><br><span class="line">    <span class="built_in">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 标志位</span></span><br><span class="line">    boolean advance = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 完成标志</span></span><br><span class="line">    boolean finishing = <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// 自旋式扩容处理</span></span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="built_in">int</span> fh;</span><br><span class="line">        <span class="comment">// 是否推进下一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">// nextIndex 表示上界  nextBound 表示下界</span></span><br><span class="line">            <span class="built_in">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// i&gt;=bount 或者已经 finishing了 不需要再进行处理了，循环结束  --i&gt;=bound 很重要，不成立的时候 不推进 标识这个桶内的还没有处理完，处理桶内的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound<span class="operator"> || </span>finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//  tranferIndex 是不是&lt;=0 如果是则表示扩容结束了</span></span><br><span class="line">            <span class="comment">// 设置nextIndex 为新上界</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 nextBound 也就是下界 为当前的 nextIndex - 步长  也就是每个线程的处理桶数量。 默认16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">U</span>.</span></span>compareAndSwapInt</span><br><span class="line">                        (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否扩容结束</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span><span class="operator"> || </span>i &gt;= n<span class="operator"> || </span>i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="built_in">int</span> sc;</span><br><span class="line">            <span class="comment">// 结束 设置table sizeCtl</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 设置扩容阈值 为 n*0.75</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没结束，则本线程退出 sizeCtl-1 表示扩容线程数-1</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">U</span>.</span></span>compare<span class="constructor">AndSwapInt(<span class="params">this</span>, SIZECTL, <span class="params">sc</span> = <span class="params">sizeCtl</span>, <span class="params">sc</span> - 1)</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否结束 因为第一个线程是这的 是rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2  参见 addCount() 方法</span></span><br><span class="line">                <span class="comment">// 没有结束 当前线程退出 结束了 则设置标识位   </span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resize<span class="constructor">Stamp(<span class="params">n</span>)</span> &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首节点为null，i 是上界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tab<span class="constructor">At(<span class="params">tab</span>, <span class="params">i</span>)</span>)<span class="operator"> == </span>null)</span><br><span class="line">            <span class="comment">// 设置成功后 继续循环设置下一个节点 空节点是不用转移节点信息的 只用设置标志位就可以了</span></span><br><span class="line">            advance = cas<span class="constructor">TabAt(<span class="params">tab</span>, <span class="params">i</span>, <span class="params">null</span>, <span class="params">fwd</span>)</span>;</span><br><span class="line">        <span class="comment">// 已经设置过了，需要推进下一个桶 如果有节点已经处理过了，标识的是 我拿不到了。 继续向下推进了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash)<span class="operator"> == </span>MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 标识的是，当前头结点不是null，并且节点没处理，那么久加锁处理这个</span></span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                <span class="comment">// 判断首节点信息正确性</span></span><br><span class="line">                <span class="keyword">if</span> (tab<span class="constructor">At(<span class="params">tab</span>, <span class="params">i</span>)</span><span class="operator"> == </span>f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// &gt;0 标识链表 进行链表的处理</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// n=2^n 所以 fn&amp;n 只会保留第n为的值 </span></span><br><span class="line">                        <span class="built_in">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">// 遍历所有处理节点</span></span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">// p的hash值 只会保留 2^n 位，  可以这样说，第n位决定了 扩容后的位置，如果第n位为0 扩容后则index不变 否则index等于原位置+原大小 解释可以看HashMap一文</span></span><br><span class="line">                            <span class="built_in">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="comment">// 不想等，则表示在新的位置 和首节点不是一个地方</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                <span class="comment">// 设置最后运行的是p  runbit 设置为p的</span></span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果为0  表示原位置  则low 低位链表是p 代表的链表  觉得这里的处理没有hashMap处的清晰 原理与HashMap的扩容一致</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 否则 p代表的是高位的链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 循环设置高低位链表</span></span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="built_in">int</span> ph = p.hash; K pk = p.key; V pv = p.<span class="keyword">val</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n)<span class="operator"> == </span><span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 设置高低位的index处的链表值</span></span><br><span class="line">                        set<span class="constructor">TabAt(<span class="params">nextTab</span>, <span class="params">i</span>, <span class="params">ln</span>)</span>;</span><br><span class="line">                        set<span class="constructor">TabAt(<span class="params">nextTab</span>, <span class="params">i</span> + <span class="params">n</span>, <span class="params">hn</span>)</span>;</span><br><span class="line">                        set<span class="constructor">TabAt(<span class="params">tab</span>, <span class="params">i</span>, <span class="params">fwd</span>)</span>;</span><br><span class="line">                        <span class="comment">// 向下推进</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树扩容  与链表一致</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        <span class="built_in">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            <span class="built_in">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.<span class="keyword">val</span>, null, null);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n)<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail)<span class="operator"> == </span>null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail)<span class="operator"> == </span>null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        set<span class="constructor">TabAt(<span class="params">nextTab</span>, <span class="params">i</span>, <span class="params">ln</span>)</span>;</span><br><span class="line">                        set<span class="constructor">TabAt(<span class="params">nextTab</span>, <span class="params">i</span> + <span class="params">n</span>, <span class="params">hn</span>)</span>;</span><br><span class="line">                        set<span class="constructor">TabAt(<span class="params">tab</span>, <span class="params">i</span>, <span class="params">fwd</span>)</span>;</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><img src="../resource/java/ConcurrentHashMap_transfer.jpg" alt=""></p>
<p>说明：</p>
<ol>
<li>ConcurrentHashMap的扩容处理会充分利用多线程，如果一个线程put数据的是否，其他线程在扩容，那么put的这个线程也会调用helpTransfer去帮忙扩容</li>
<li>扩容的过程是将整个数组分成多个桶，每个线程处理一个桶内的数据，处理完成后获取下一个桶的数据。</li>
<li>每个线程循环处理一个桶内所有index的数据，如果tab[index]处的首节点是空，则设置为hash=MOVED的节点，表示这个桶内的节点正在进行扩容处理。如果不为空，对该节点加锁，然后进行节点迁移，此过程与HashMap的节点迁移流程一致。</li>
</ol>
<p>线程分桶处理：<br><img src="../resource/java/ConcurrentHashMap_tableStride.jpg" alt=""></p>
<p>每个线程领取一个stride去循环处理其中的所有节点数据。</p>
<h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><details>
<summary><font color='red'>View Code</font></summary>


<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* PUT 操作完成后 增加计数信息  并且判断是否需要进行扩容 需要则调用transfer扩容。</span></span><br><span class="line"><span class="comment">* Adds to count, and if table is too small and not already</span></span><br><span class="line"><span class="comment">* resizing, initiates transfer. If already resizing, helps</span></span><br><span class="line"><span class="comment">* perform transfer if work is available.  Rechecks occupancy</span></span><br><span class="line"><span class="comment">* after a transfer to see if another resize is already needed</span></span><br><span class="line"><span class="comment">* because resizings are lagging additions.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> final <span class="keyword">void</span> <span class="title">addCount</span>(<span class="params"><span class="keyword">long</span> x, <span class="keyword">int</span> check</span>)</span> &#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span>; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 计数单元组不为null，尝试设置 baseCount(用于没有资源竞争时候的数量计数) </span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">as</span> = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">// counterCells为null 或者设置基础计数失败</span></span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">// 默认无竞争</span></span><br><span class="line">        boolean uncontended = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// as null 无并发竞争</span></span><br><span class="line">        <span class="comment">// m = as.length-1  &lt; 0  就是as.length = 0 没有完成初始化</span></span><br><span class="line">        <span class="comment">// 随机去一个as[i] 修改其值为 v+x 失败表示出现竞争，否则没有 结束</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">as</span> == <span class="literal">null</span> || (m = <span class="keyword">as</span>.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = <span class="keyword">as</span>[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">                U.compareAndSwapLong(a, CELLVALUE, v = a.<span class="keyword">value</span>, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// as = null  切check&gt;=0 有冲突  此处传入的是binCount 这个可以看putVal 的源码 putVal默认就是0 或者是链表长度  所以put进来的都需要检查</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 上面 s = b+x  如果插入元素后 &gt;sizeCtl 也就是0.75n的阈值 并且table不为空 切不超过最大容量 需要扩容</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// rs标志位  16位1  低位是 n 的 高位0个数</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">//sc 为sizeCtl&lt;0 表示 没有初始化 或者 在扩容 此处表示在扩容中</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 右移16位 不等于rs 表示 sizeCtl变化了 变化了表示其他的地方扩容了 此处不需要管了</span></span><br><span class="line">                <span class="comment">// sc == rs+1  表示的是 扩容已经结束了 不管了 </span></span><br><span class="line">                <span class="comment">// sc == rs + MAX_RESIZERS 表示帮忙的已经有65535个线程了 您别添乱了</span></span><br><span class="line">                <span class="comment">// nt = nextTable 表示扩容结束了 释放阶段</span></span><br><span class="line">                <span class="comment">// transferIndex &lt;= 0 表示马上结束 或者已经结束 别管了</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 需要帮助， 帮助线程数+1  transfer 参与扩容去</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有线程在扩容 自己扩， 初始化为 sc = rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 所以如果sc=rs+1 就表示没有线程在扩容了。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 扩容</span></span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算总数</span></span><br><span class="line"><span class="function">final <span class="keyword">long</span> <span class="title">sumCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a;</span><br><span class="line">    <span class="comment">// 默认取 基础计数</span></span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="comment">// 校验as  不为null 以as为准</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环算总数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p>说明： 主要作用是设置计数，以及判断要不要进行扩容</p>
<ol>
<li>随机选一个countCell增加计数。失败则调用fullAddCount</li>
<li>通过sizeCtl标志位判断是否在扩容中，如果在扩容中，判断是否需要帮忙，不需要直接退出，需要的话加入扩容大军中进行扩容。无扩容，则自己开先锋进行扩容。</li>
<li>计数信息已CounterCell为准 CounterCell无数据 则去baseCount. map.size也是如此调用的sumCount()方法。</li>
</ol>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取key 的值</span></span><br><span class="line">public V <span class="built_in">get</span>(Object <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="built_in">tab</span>; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    int h = <span class="built_in">spread</span>(<span class="built_in">key</span>.<span class="built_in">hashCode</span>());</span><br><span class="line">    <span class="comment">//table校验 如果tab[h]=null 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = <span class="built_in">tabAt</span>(<span class="built_in">tab</span>, (n - <span class="number">1</span>) &amp; h)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 与头结点hash相同 </span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">// 优先判断头结点是否是要找的节点 是 直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == <span class="built_in">key</span> || (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash值和头结点不相同， 则判断是否是 &lt;0  表示正在初始化或者扩容中。通过 头结点的find 方法找到值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="built_in">null</span> ? p.val : <span class="built_in">null</span>;</span><br><span class="line">        <span class="comment">// 下一个节点不为null 循环遍历链表后面的节点查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == <span class="built_in">key</span> || (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：获取key的value的操作相对来说比较简单。</p>
<ol>
<li>hash和头结点相同，优先看是不是头结点的值</li>
<li>头结点hash&lt;0 表示的是在扩容或者初始化中，则利用头结点的find函数查找，以免并发问题</li>
<li>非扩容中，直接在链表后面查找。</li>
</ol>
<p><strong>注意：此处如果链表过长，在while处的时候，进行了扩容处理，怎么办？：可以查看transfer源码，transfer的时候，其实旧的table没有进行主动的释放，在进行节点迁移的时候，也是深度拷贝，创建的先的链表和节点，所以不会旧的链表还是可以访问。</strong></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>ConcurrentHashMap 的设计可以说非常的巧妙，整体思路是减少锁操作，以及并发处理扩容。</p>
<p>减少锁操作：</p>
<ol>
<li>读取的时候，优先判断首节点，在判断是否扩容操作中，如果是，则从首节点的链表往后自旋查找。不在扩容在继续向后，整体无锁。仅仅是在有竞争的时候，进行自旋，这种自旋可以说很快的了</li>
<li>写操作的时候如果在resize 则帮忙进行，如果没有resize，则仅仅对头结点table[i]加锁，这样就不会影响其他线程对于table[j]的写入了。</li>
</ol>
<p>并发扩容：</p>
<ol>
<li>当前线程要进行写操作的时候，如果检测到有其他线程正在进行扩容，则积极加入到扩容大军中，帮助推进扩容的处理。</li>
<li>扩容的时候，是将table分成了n个桶 默认是 一个桶包含了16个单元index。 每个线程去申请一个桶的操作权限，申请完成后，循环处理这个桶中的所有节点，对所有节点进行节点迁移处理。处理过的节点设置为hash=MODED。</li>
</ol>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

<h1 id="参考和引申"><a href="#参考和引申" class="headerlink" title="参考和引申"></a>参考和引申</h1><blockquote>
<p><a href="https://www.cnblogs.com/leesf456/p/5453341.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/5453341.html</a><br><a href="https://www.jianshu.com/p/2829fe36a8dd" target="_blank" rel="noopener">https://www.jianshu.com/p/2829fe36a8dd</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>线程安全集合</tag>
      </tags>
  </entry>
  <entry>
    <title>StampedLock源码分析</title>
    <url>/post/414857a8.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>StampedLock是对读写锁ReentrantReadWriteLock的增强，该类提供了锁的基础功能，优化了读锁，写锁的访问，同时使读写锁可以相互转化，更细粒度控制并发。本文就来看看StampedLock的使用和实现。</p>
<h2 id="为啥引入StampedLock"><a href="#为啥引入StampedLock" class="headerlink" title="为啥引入StampedLock"></a>为啥引入StampedLock</h2><p>ReentrantReadWriteLock 利用Aqs实现了读写锁的功能，但是其默认是非公平的，非公平的情况下，对于读多写少的情况，很容易产生饥饿的现象，也就是写锁始终获取不到资源。</p>
<p>非公平锁尝试获取锁资源的时候，直接尝试能不能获取。<br>公平锁是优先放入sync队列中。由队列进行调度</p>
<p>如果使用公平的ReentrantReadWriteLock对于一些频繁获取释放锁的场景会非常耗费性能，因为所有线程都必须通过Aqs的sync队列来进行调度，即使当前线程本可以获取资源，也需要等待Aqs来进行调度。</p>
<p>故而引入了StampedLock锁，来优化读写锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">StampedLocks are designed for <span class="keyword">use</span> <span class="keyword">as</span> internal utilities <span class="keyword">in</span> the</span><br><span class="line">development <span class="keyword">of</span> <span class="keyword">thread</span>-<span class="keyword">safe</span> components. Their <span class="keyword">use</span> relies <span class="keyword">on</span></span><br><span class="line">knowledge <span class="keyword">of</span> the internal properties <span class="keyword">of</span> the <span class="keyword">data</span>, objects, <span class="keyword">and</span></span><br><span class="line">methods they <span class="keyword">are</span> protecting.  They <span class="keyword">are</span> <span class="keyword">not</span> reentrant, so <span class="keyword">locked</span></span><br><span class="line">bodies should <span class="keyword">not</span> <span class="keyword">call</span> other <span class="literal">unknown</span> methods that may try <span class="keyword">to</span></span><br><span class="line">re-acquire locks (although you may pass a stamp <span class="keyword">to</span> other methods</span><br><span class="line">that can <span class="keyword">use</span> <span class="keyword">or</span> <span class="keyword">convert</span> it).  The <span class="keyword">use</span> <span class="keyword">of</span> <span class="keyword">read</span> <span class="keyword">lock</span> modes relies <span class="keyword">on</span></span><br><span class="line">the associated code sections being side-effect-free.  Unvalidated</span><br><span class="line">optimistic <span class="keyword">read</span> sections cannot <span class="keyword">call</span> methods that <span class="keyword">are</span> <span class="keyword">not</span> known <span class="keyword">to</span></span><br><span class="line">tolerate potential inconsistencies.  Stamps <span class="keyword">use</span> finite</span><br><span class="line">representations, <span class="keyword">and</span> <span class="keyword">are</span> <span class="keyword">not</span> cryptographically secure (i.e., a</span><br><span class="line">valid stamp may be guessable). Stamp <span class="keyword">values</span> may <span class="keyword">recycle</span> <span class="keyword">after</span> (<span class="keyword">no</span></span><br><span class="line">sooner <span class="keyword">than</span>) one <span class="keyword">year</span> <span class="keyword">of</span> continuous operation. A stamp held <span class="keyword">without</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">or</span> <span class="keyword">validation</span> <span class="keyword">for</span> longer <span class="keyword">than</span> this <span class="keyword">period</span> may fail <span class="keyword">to</span> <span class="keyword">validate</span></span><br><span class="line">correctly.  StampedLocks <span class="keyword">are</span> <span class="keyword">serializable</span>, but <span class="keyword">always</span> deserialize</span><br><span class="line"><span class="keyword">into</span> <span class="keyword">initial</span> unlocked state, so they <span class="keyword">are</span> <span class="keyword">not</span> useful <span class="keyword">for</span> remote</span><br><span class="line">locking.</span><br></pre></td></tr></table></figure>

<ol>
<li>该类主要设计是用于内部设计线程安全组件的工具类。</li>
<li>they are not reentrant. 非重入锁 （如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li>
<li>如果被反序列化，则会重新初始化lock的状态，所以不可以用于远程锁。</li>
<li>stamp标志最长为一年，锁持有时间不能超过1年。</li>
</ol>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// an exclusively locked method</span></span><br><span class="line">    <span class="comment">//移动点，写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 修改</span></span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放写锁</span></span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A read-only method</span></span><br><span class="line">    <span class="comment">// 计算距离 读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 尝试使用 乐观读锁</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line">        <span class="comment">// 无效 获取失败</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">//加读锁</span></span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解除读锁</span></span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Math.<span class="title">sqrt</span><span class="params">(currentX  currentX + currentY  currentY)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// upgrade</span></span><br><span class="line">    <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读锁 </span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="comment">// 升级为写锁</span></span><br><span class="line">                <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                <span class="keyword">if</span> (ws != <span class="number">0</span>L) &#123;</span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放读锁</span></span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    <span class="comment">//加写锁</span></span><br><span class="line">                    stamp = sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可用CPU数量，用于自旋控制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = <span class="keyword">Runtime</span>.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果CPU数量&gt;1 则自旋次数为 2^6 64次 超过数量则加入队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待队列首节点尝试获取锁自旋次数 1024 超过该值 阻塞</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次阻塞前的最大自旋数量 2^16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋锁超限后的yield周期</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERFLOW_YIELD_RATE = <span class="number">7</span>; <span class="comment">// must be power 2 - 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁最大bit位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">----------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1</span>L;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT  = <span class="number">1</span>L &lt;&lt; LG_READERS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = WBIT - <span class="number">1</span>L;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = RBITS - <span class="number">1</span>L;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = RBITS | WBIT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = ~RBITS; <span class="comment">// note overlap with ABITS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始值  1 0000 0000 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORIGIN = WBIT &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INTERRUPTED = <span class="number">1</span>L;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING   = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RMODE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WMODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> WNode &#123;</span><br><span class="line">    <span class="keyword">volatile</span> WNode prev;</span><br><span class="line">    <span class="keyword">volatile</span> WNode <span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">volatile</span> WNode cowait;    <span class="comment">// list of linked readers</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;   <span class="comment">// non-null while possibly parked</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> status;      <span class="comment">// 0, WAITING, or CANCELLED</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mode;           <span class="comment">// RMODE or WMODE</span></span><br><span class="line">    WNode(<span class="keyword">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Head of CLH queue */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;</span><br><span class="line"><span class="comment">/** Tail (last) of CLH queue */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// views</span></span><br><span class="line"><span class="keyword">transient</span> ReadLockView readLockView;</span><br><span class="line"><span class="keyword">transient</span> WriteLockView writeLockView;</span><br><span class="line"><span class="keyword">transient</span> ReadWriteLockView readWriteLockView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock sequence/state */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁超过128后 的记录数。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> STATE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WHEAD;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WTAIL;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WNEXT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WSTATUS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WCOWAIT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PARKBLOCKER;</span><br></pre></td></tr></table></figure>

</details>



<p><img src="../resource/java/StampLock%E5%B1%9E%E6%80%A7%E4%BA%8C%E8%BF%9B%E5%88%B6.jpg" alt=""></p>
<p>数据结构：</p>
<p><img src="../resource/java/StampedLock%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>说明： </p>
<ol>
<li>StampedLock 内部是使用Long来保存各种操作变量，进行二进制转化判断</li>
<li>StampedLock 内部结构是一个双向链表加栈（单链表实现）的结构</li>
</ol>
<h2 id="重要方法："><a href="#重要方法：" class="headerlink" title="重要方法："></a>重要方法：</h2><h3 id="readLock"><a href="#readLock" class="headerlink" title="readLock"></a>readLock</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public long read<span class="constructor">Lock()</span> &#123;</span><br><span class="line">    long s = state, next;  </span><br><span class="line">    <span class="comment">// whead==wtail 表示队列中没有节点  s&amp; ABITS 表示没有线程独占资源  </span></span><br><span class="line">    return ((whead<span class="operator"> == </span>wtail<span class="operator"> &amp;&amp; </span>(s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">U</span>.</span></span>compare<span class="constructor">AndSwapLong(<span class="params">this</span>, STATE, <span class="params">s</span>, <span class="params">next</span> = <span class="params">s</span> + RUNIT)</span>) ?</span><br><span class="line">            next : acquire<span class="constructor">Read(<span class="params">false</span>, 0L)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../resource/java/StampedLock%E8%AF%BB%E9%94%81.jpg" alt=""></p>
<p>说明：</p>
<ol>
<li>ABIT = 1111 1111  读锁最大值是 0111 1111 如果 s&amp;ABITS &lt; RFULL(0111 1111) 表示的是 s=0<strong>* **</strong>  无写锁，读锁不超过最大位数(写锁只能有一个).</li>
<li>如果没有写锁且读锁不超过126个，则读锁可以直接尝试CAS获取，失败在尝试acquire</li>
</ol>
<h3 id="acquireRead"><a href="#acquireRead" class="headerlink" title="acquireRead"></a>acquireRead</h3><p>实话说 ，这个方法复杂到一定的程度了。</p>
<details>
<summary><font color='red'>View Code</font></summary>


<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自旋入队操作</span></span><br><span class="line"><span class="comment">     * 如果写锁未被占用, 则立即尝试获取读锁, 获取成功则返回.</span></span><br><span class="line"><span class="comment">     * 如果写锁被占用, 则将当前读线程包装成结点, 并插入等待队列（如果队尾是写结点,直接链接到队尾;否则,链接到队尾读结点的栈中）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">private long acquireRead(boolean interruptible, long deadline) &#123;</span><br><span class="line">    </span><br><span class="line">    WNode <span class="attr">node</span> = <span class="literal">null</span>, p;</span><br><span class="line">    // 自旋</span><br><span class="line">    for (int <span class="attr">spins</span> = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        WNode h;</span><br><span class="line">        // 队列无等待元素节点  通过自旋尝试获取锁 。</span><br><span class="line">        <span class="keyword">if</span> ((<span class="attr">h</span> = whead) == (<span class="attr">p</span> = wtail)) &#123;</span><br><span class="line">            //自旋<span class="number">1</span></span><br><span class="line">            for (long m, s, ns;;) &#123;</span><br><span class="line">                // (<span class="attr">s</span> = state) &amp; ABITS) &lt; RFULL  表示无写锁被占用  如果超过<span class="number">126</span> 则包多的记录到 readerOverflow中</span><br><span class="line">                <span class="keyword">if</span> ((<span class="attr">m</span> = (<span class="attr">s</span> = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                    U.compareAndSwapLong(this, STATE, s, <span class="attr">ns</span> = s + RUNIT) :</span><br><span class="line">                    (m &lt; WBIT &amp;&amp; (<span class="attr">ns</span> = tryIncReaderOverflow(s)) != <span class="number">0</span>L))</span><br><span class="line">                    return ns;</span><br><span class="line">                // 有写锁</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                            --spins;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="attr">spins</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            WNode <span class="attr">nh</span> = whead, <span class="attr">np</span> = wtail;</span><br><span class="line">                            <span class="keyword">if</span> ((<span class="attr">nh</span> == h &amp;&amp; <span class="attr">np</span> == p) || (<span class="attr">h</span> = nh) != (<span class="attr">p</span> = np))</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="attr">spins</span> = SPINS;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 上诉自旋退出 可能是超时 ，如果队列还是五元素，则初始化一个写节点</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">p</span> == <span class="literal">null</span>) &#123; // initialize queue</span><br><span class="line">            WNode <span class="attr">hd</span> = new WNode(WMODE, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(this, WHEAD, <span class="literal">null</span>, hd))</span><br><span class="line">                <span class="attr">wtail</span> = hd;</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化当前节点为读节点</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">node</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">node</span> = new WNode(RMODE, p);</span><br><span class="line">        // 如果当前没有等待节点（只有初始化的那个写节点），或者尾节点是写节点 则把当前节点 加入到队列尾部</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">h</span> == p || p.mode != RMODE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">                node.<span class="attr">prev</span> = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(this, WTAIL, p, node)) &#123;</span><br><span class="line">                p.<span class="attr">next</span> = node;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 尾节点是读节点，则加入到尾节点的cowait 栈中</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!U.compareAndSwapObject(p, WCOWAIT,</span><br><span class="line">                                            node.<span class="attr">cowait</span> = p.cowait, node))</span><br><span class="line">            node.<span class="attr">cowait</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            // 自旋 尝试从cowait中唤醒， 如果无法唤醒 则阻塞住。</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                WNode pp, c; Thread w;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="attr">h</span> = whead) != <span class="literal">null</span> &amp;&amp; (<span class="attr">c</span> = h.cowait) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (<span class="attr">w</span> = c.thread) != <span class="literal">null</span>) // help release</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">if</span> (<span class="attr">h</span> == (<span class="attr">pp</span> = p.prev) || <span class="attr">h</span> == p || <span class="attr">pp</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">                    long m, s, ns;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="attr">m</span> = (<span class="attr">s</span> = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                            U.compareAndSwapLong(this, STATE, s,</span><br><span class="line">                                                    <span class="attr">ns</span> = s + RUNIT) :</span><br><span class="line">                            (m &lt; WBIT &amp;&amp;</span><br><span class="line">                                (<span class="attr">ns</span> = tryIncReaderOverflow(s)) != <span class="number">0</span>L))</span><br><span class="line">                            return ns;</span><br><span class="line">                    &#125; while (m &lt; WBIT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="attr">whead</span> == h &amp;&amp; p.<span class="attr">prev</span> == pp) &#123;</span><br><span class="line">                    long time;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="attr">pp</span> == <span class="literal">null</span> || <span class="attr">h</span> == p || p.status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="attr">node</span> = <span class="literal">null</span>; // <span class="built_in">throw</span> away</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="attr">deadline</span> == <span class="number">0</span>L)</span><br><span class="line">                        <span class="attr">time</span> = <span class="number">0</span>L;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">time</span> = deadline - System.nanoTime()) &lt;= <span class="number">0</span>L)</span><br><span class="line">                        return cancelWaiter(node, p, <span class="literal">false</span>);</span><br><span class="line">                    Thread <span class="attr">wt</span> = Thread.currentThread();</span><br><span class="line">                    U.putObject(wt, PARKBLOCKER, this);</span><br><span class="line">                    node.<span class="attr">thread</span> = wt;</span><br><span class="line">                    <span class="keyword">if</span> ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                        <span class="attr">whead</span> == h &amp;&amp; p.<span class="attr">prev</span> == pp)</span><br><span class="line">                        U.park(<span class="literal">false</span>, time);</span><br><span class="line">                    node.<span class="attr">thread</span> = <span class="literal">null</span>;</span><br><span class="line">                    U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                        return cancelWaiter(node, p, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 上面的自旋退出条件是加入到了队列中，等待队里中，这了自旋</span><br><span class="line">    for (int <span class="attr">spins</span> = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        WNode h, np, pp; int ps;</span><br><span class="line">        // 队列中无其他元素 需要尝试唤醒</span><br><span class="line">        <span class="keyword">if</span> ((<span class="attr">h</span> = whead) == p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="attr">spins</span> = HEAD_SPINS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            // 自旋尝试获取锁，获取成功 则吧 cowait堆栈的所有节点唤醒</span><br><span class="line">            for (int <span class="attr">k</span> = spins;;) &#123; // spin at head</span><br><span class="line">                long m, s, ns;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="attr">m</span> = (<span class="attr">s</span> = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                    U.compareAndSwapLong(this, STATE, s, <span class="attr">ns</span> = s + RUNIT) :</span><br><span class="line">                    (m &lt; WBIT &amp;&amp; (<span class="attr">ns</span> = tryIncReaderOverflow(s)) != <span class="number">0</span>L)) &#123;</span><br><span class="line">                    WNode c; Thread w;</span><br><span class="line">                    <span class="attr">whead</span> = node;</span><br><span class="line">                    node.<span class="attr">prev</span> = <span class="literal">null</span>;</span><br><span class="line">                    while ((<span class="attr">c</span> = node.cowait) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(node, WCOWAIT,</span><br><span class="line">                                                    c, c.cowait) &amp;&amp;</span><br><span class="line">                            (<span class="attr">w</span> = c.thread) != <span class="literal">null</span>)</span><br><span class="line">                            U.unpark(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return ns;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT &amp;&amp;</span><br><span class="line">                            LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp; --k &lt;= <span class="number">0</span>)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 首节点不为<span class="literal">null</span>，并且有cowait 表示是读节点 ，则唤醒cowait 栈上的所有节点</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123;</span><br><span class="line">            WNode c; Thread w;</span><br><span class="line">            while ((<span class="attr">c</span> = h.cowait) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (<span class="attr">w</span> = c.thread) != <span class="literal">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 首节点无变化</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">whead</span> == h) &#123;</span><br><span class="line">            // 自旋过程中前尾节点p 有变动 重置状态</span><br><span class="line">            <span class="keyword">if</span> ((<span class="attr">np</span> = node.prev) != p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (np != <span class="literal">null</span>)</span><br><span class="line">                    (<span class="attr">p</span> = np).<span class="attr">next</span> = node;   // stale</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">ps</span> = p.status) == <span class="number">0</span>)</span><br><span class="line">                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">ps</span> == CANCELLED) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="attr">pp</span> = p.prev) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.<span class="attr">prev</span> = pp;</span><br><span class="line">                    pp.<span class="attr">next</span> = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 尾节点还是 等待状态 则继续阻塞</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                long time;</span><br><span class="line">                <span class="keyword">if</span> (<span class="attr">deadline</span> == <span class="number">0</span>L)</span><br><span class="line">                    <span class="attr">time</span> = <span class="number">0</span>L;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">time</span> = deadline - System.nanoTime()) &lt;= <span class="number">0</span>L)</span><br><span class="line">                    return cancelWaiter(node, node, <span class="literal">false</span>);</span><br><span class="line">                Thread <span class="attr">wt</span> = Thread.currentThread();</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, this);</span><br><span class="line">                node.<span class="attr">thread</span> = wt;</span><br><span class="line">                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                    <span class="attr">whead</span> == h &amp;&amp; node.<span class="attr">prev</span> == p)</span><br><span class="line">                    U.park(<span class="literal">false</span>, time);</span><br><span class="line">                node.<span class="attr">thread</span> = <span class="literal">null</span>;</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                    return cancelWaiter(node, node, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<br/>

<p><img src="../resource/java/stampedLock_readlock1.jpg" alt=""><br><img src="../resource/java/stampedLock_readlock2.jpg" alt=""></p>
<h3 id="writeLock"><a href="#writeLock" class="headerlink" title="writeLock"></a>writeLock</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public long write<span class="constructor">Lock()</span> &#123;</span><br><span class="line">    long s, next;  <span class="comment">// bypass acquireWrite in fully unlocked case only</span></span><br><span class="line">    <span class="comment">// ABITS = 1111 1111  state &amp; ABITS = 0 表示锁没有被占有。 则 直接尝试获取，失败通过aquire获取</span></span><br><span class="line">    return ((((s = state) &amp; ABITS)<span class="operator"> == </span><span class="number">0L</span> &amp;&amp;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">U</span>.</span></span>compare<span class="constructor">AndSwapLong(<span class="params">this</span>, STATE, <span class="params">s</span>, <span class="params">next</span> = <span class="params">s</span> + WBIT)</span>) ?</span><br><span class="line">            next : acquire<span class="constructor">Write(<span class="params">false</span>, 0L)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol>
<li>ABITS = 1111 1111  state &amp; ABITS = 0</li>
</ol>
<h3 id="acquireWrite"><a href="#acquireWrite" class="headerlink" title="acquireWrite"></a>acquireWrite</h3><details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自旋入队操作</span></span><br><span class="line"><span class="comment">* 如果没有任何锁被占用, 则立即尝试获取写锁, 获取成功则返回.</span></span><br><span class="line"><span class="comment">* 如果存在锁被使用, 则将当前线程包装成独占结点, 并插入等待队列尾部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> long acquireWrite(<span class="built_in">bool</span>ean <span class="built_in">int</span>erruptible, long deadline) &#123;</span><br><span class="line">    WNode node = <span class="literal">null</span>, p;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> spins = <span class="number">-1</span>;;) &#123; <span class="comment">// spin while enqueuing</span></span><br><span class="line">        long m, s, ns;</span><br><span class="line">        <span class="comment">// 无锁 ，直接获取返回</span></span><br><span class="line">        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0</span>L) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + WBIT))</span><br><span class="line">                <span class="keyword">return</span> ns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置次数操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">            spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列无节点，有锁被占用，初始化一个写的首节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="literal">null</span>) &#123; <span class="comment">// initialize queue</span></span><br><span class="line">            WNode hd = new WNode(WMODE, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="literal">null</span>, hd))</span><br><span class="line">                wtail = hd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化当前节点为写节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            node = new WNode(WMODE, p);</span><br><span class="line">        <span class="comment">// 加入队列尾部</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">            node.prev = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">            p.next = node;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自旋，此时已经在队列中了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> spins = <span class="number">-1</span>;;) &#123;</span><br><span class="line">        WNode h, np, pp; <span class="built_in">int</span> ps;</span><br><span class="line">        <span class="comment">// 队列之前无元素</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == p) &#123;</span><br><span class="line">            <span class="comment">// 自旋数操作</span></span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                spins = HEAD_SPINS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 小自旋 如果没有锁释放了，则尝试获取锁</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> k = spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">                long s, ns;</span><br><span class="line">                <span class="keyword">if</span> (((s = state) &amp; ABITS) == <span class="number">0</span>L) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                                ns = s + WBIT)) &#123;</span><br><span class="line">                        whead = node;</span><br><span class="line">                        node.prev = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">return</span> ns;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            --k &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果首节点是读，则唤醒首节点的cowait</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123; <span class="comment">// help release stale waiters</span></span><br><span class="line">            WNode c; Thread w;</span><br><span class="line">            <span class="keyword">while</span> ((c = h.cowait) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="literal">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首节点无变动</span></span><br><span class="line">        <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">            <span class="comment">// 设置node 前驱节点P 状态 cancelled移除，还需等待设置为 waiting 阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (np != <span class="literal">null</span>)</span><br><span class="line">                    (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pp = p.prev) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.prev = pp;</span><br><span class="line">                    pp.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                long time; <span class="comment">// 0 argument to park means no timeout</span></span><br><span class="line">                <span class="keyword">if</span> (deadline == <span class="number">0</span>L)</span><br><span class="line">                    time = <span class="number">0</span>L;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0</span>L)</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">false</span>);</span><br><span class="line">                Thread wt = Thread.currentThread();</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                node.thread = wt;</span><br><span class="line">                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp; (p != h || (state &amp; ABITS) != <span class="number">0</span>L) &amp;&amp;</span><br><span class="line">                    whead == h &amp;&amp; node.prev == p)</span><br><span class="line">                    U.park(<span class="literal">false</span>, time);  <span class="comment">// emulate LockSupport.park</span></span><br><span class="line">                node.thread = <span class="literal">null</span>;</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">int</span>erruptible &amp;&amp; Thread.<span class="built_in">int</span>errupted())</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<br/>

<p><img src="../resource/java/stampedLock_readlock1.jpg" alt=""></p>
<h3 id="读写锁获取总结"><a href="#读写锁获取总结" class="headerlink" title="读写锁获取总结"></a>读写锁获取总结</h3><p>读写锁获取的关键点主要是：</p>
<ol>
<li>如果当前可获取，直接尝试获取 （读：无写锁占有则可获取， 写：无锁占有则可获取）</li>
<li>直接获取失败，acquire尝试。<ol>
<li>队列无元素。表示只有一个线程占有。乐观锁假定会很快释放，所以自旋等待锁释放，直接获取</li>
<li>队列有元素需要加入到队列中。涉及初始化首节点</li>
<li>已加入队列中，如果现在只有自己在队列中，则乐观锁假定会很快释放，所以自旋等待锁释放尝试获取</li>
<li>如果自旋过程中，读锁节点变成了首节点，则唤醒该节点cowait栈中的所有节点</li>
<li>自旋节点中，如果首节点无变动，表示没有锁释放，进入悲观，依次删除超时cancel的节点，然后还有前驱，则park</li>
</ol>
</li>
</ol>
<p><img src="../resource/java/stampedLock%E9%94%81%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<h3 id="unlockRead"><a href="#unlockRead" class="headerlink" title="unlockRead"></a>unlockRead</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 锁释放</span></span><br><span class="line">public void unlock<span class="constructor">Read(<span class="params">long</span> <span class="params">stamp</span>)</span> &#123;</span><br><span class="line">    long s, m; WNode h;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        <span class="comment">// 状态异常检测</span></span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">            (stamp &amp; <span class="constructor">ABITS</span>) <span class="operator">==</span> 0<span class="constructor">L</span> <span class="operator">||</span> (m = s &amp; <span class="constructor">ABITS</span>) <span class="operator">==</span> 0<span class="constructor">L</span> <span class="operator">||</span> m <span class="operator">==</span> <span class="constructor">WBIT</span>)</span></span><br><span class="line"><span class="pattern-match">            throw <span class="keyword">new</span> <span class="constructor">IllegalMonitorStateException()</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 如果写锁本身不超过126 则 直接修改state 否则需要修改 readeroverflow字段</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (m &lt; <span class="constructor">RFULL</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="keyword">if</span> (<span class="constructor">U</span>.compare<span class="constructor">AndSwapLong(<span class="params">this</span>, STATE, <span class="params">s</span>, <span class="params">s</span> - RUNIT)</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">                <span class="keyword">if</span> (m <span class="operator">==</span> <span class="constructor">RUNIT</span> <span class="operator">&amp;&amp;</span> (h = whead) != null <span class="operator">&amp;&amp;</span> h.status != 0)</span></span><br><span class="line"><span class="pattern-match">                   <span class="operator">/</span><span class="operator">/</span>m=1 的时候 唤醒头结点</span></span><br><span class="line"><span class="pattern-match">                    release(h);</span></span><br><span class="line"><span class="pattern-match">                break;</span></span><br><span class="line"><span class="pattern-match">            &#125;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">try</span><span class="constructor">DecReaderOverflow(<span class="params">s</span>)</span> != 0<span class="constructor">L</span>)</span></span><br><span class="line"><span class="pattern-match">            break;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">private</span> void release(<span class="constructor">WNode</span> h) &#123;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (h != null) &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">WNode</span> q; <span class="constructor">Thread</span> w;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 设置状态</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">U</span>.compare<span class="constructor">AndSwapInt(<span class="params">h</span>, WSTATUS, WAITING, 0)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 对位检测取消的节点</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> ((q = h.next) <span class="operator">==</span> null <span class="operator">||</span> q.status <span class="operator">==</span> <span class="constructor">CANCELLED</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">            for (<span class="constructor">WNode</span> t = wtail; t != null <span class="operator">&amp;&amp;</span> t != h; t = t.prev)</span></span><br><span class="line"><span class="pattern-match">                <span class="keyword">if</span> (t.status &lt;= 0)</span></span><br><span class="line"><span class="pattern-match">                    q = t;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 唤醒</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (q != null <span class="operator">&amp;&amp;</span> (w = q.thread) != null)</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">U</span>.unpark(w);</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>自旋</li>
<li>状态一致性检测</li>
<li>读锁的存储有两个地方 state低7位 和readeroverflow字段，需要判断从哪里去减除</li>
<li>如果读只有1个了，则唤醒下一个节点</li>
</ol>
<h3 id="unlockWrite"><a href="#unlockWrite" class="headerlink" title="unlockWrite"></a>unlockWrite</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    WNode h;</span><br><span class="line">    <span class="comment">// 状态检测</span></span><br><span class="line">    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//WBIT 1000 0000  stamp+=WBIT 由于写锁只有一个 加上之后就溢出 表示写锁释放 也就是 ORIGIN的值  1 0000 0000</span></span><br><span class="line">    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;</span><br><span class="line">    <span class="comment">// 唤醒头结点</span></span><br><span class="line">    <span class="keyword">if</span> ((h = whead) != null &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">release</span>(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>队列有节点，则释放队列中等待的节点</li>
</ol>
<h3 id="tryOptimisticRead"><a href="#tryOptimisticRead" class="headerlink" title="tryOptimisticRead"></a>tryOptimisticRead</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">public long tryOptimisticRead() &#123;</span><br><span class="line">    long s;</span><br><span class="line">    // statue &amp; WBIT = <span class="number">0</span> 表示无写。  s&amp;SBITS 表示去除读的数量 也就是写锁的值。</span><br><span class="line">    return (((s = <span class="keyword">state</span>) &amp; WBIT) == <span class="number">0</span>L) ? (s &amp; SBITS) : <span class="number">0</span>L;</span><br><span class="line">&#125;</span><br><span class="line">// 有效 表示的是 现在有写锁占用 也就是 <span class="keyword">state</span>&amp;WBIT==<span class="number">0</span></span><br><span class="line">public boolean validate(long stamp) &#123;</span><br><span class="line">        U.<span class="built_in">load</span>Fence();</span><br><span class="line">        //</span><br><span class="line">        return (stamp &amp; SBITS) == (<span class="keyword">state</span> &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明： tryOptimisticRead 和 validate放在一起其实是表示当前有没有写锁，如果没有写锁，则读取数据就不加锁 直接读取。</p>
<p>注意 loadFence : 读屏障，确保之前的写入都已经写进去了 不会出现多线程缓存等问题影响。如果中间一直无写锁，则直接读 不加锁</p>
<h1 id="示例。"><a href="#示例。" class="headerlink" title="示例。"></a>示例。</h1><p>假设现在有5个线程 thread A ,thread B, thread C, thread D, thread E</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadA调用writeLock, 获取写锁</span></span><br><span class="line"><span class="comment">//ThreadB调用readLock, 获取读锁</span></span><br><span class="line"><span class="comment">//ThreadC调用readLock, 获取读锁</span></span><br><span class="line"><span class="comment">//ThreadD调用writeLock, 获取写锁</span></span><br><span class="line"><span class="comment">//ThreadE调用readLock, 获取读锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">依次释放</span><br></pre></td></tr></table></figure>

<p>参考锁流程：</p>
<p><img src="../resource/java/stampedLock%E9%94%81%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<ol>
<li>ThreadA 获取写锁，无竞争，直接获取。</li>
</ol>
<p><img src="../resource/java/stampedLock_1.jpg" alt=""></p>
<ol start="2">
<li>ThreadB 获取读锁，不可直接获取，队列无元素，加入队列中等待。由于队列只有他自己，所以做</li>
</ol>
<p><img src="../resource/java/stampedLock_2.jpg" alt=""></p>
<ol start="3">
<li>ThreadC 获取readLock，不可直接获取，队列有元素，尾节点是读节点，加入cowait</li>
</ol>
<p><img src="../resource/java/stampedLock_3.jpg" alt=""></p>
<ol start="4">
<li>ThreadD 获取写锁,不可直接获取，加入队列等待</li>
</ol>
<p><img src="../resource/java/stampedLock_4.jpg" alt=""></p>
<ol start="5">
<li>ThreadE 获取读锁,不可直接获取，对尾不是读，加入队列</li>
</ol>
<p><img src="../resource/java/stampedLock_5.jpg" alt=""></p>
<ol start="5">
<li><p>ThreadA 释放  首先首节点状态设置为-1 ，然后unpark Thread B，由于 Tread B 有cowait<br><img src="../resource/java/stampedLock_6.jpg" alt=""><br>由于ThreadB 中的自旋会 释放头结点 唤醒 cowait 并且解除 cowait链接<br><img src="../resource/java/stampedLock_7.jpg" alt=""></p>
</li>
<li><p>ThreadB 释放，ThreadD获取写<br><img src="../resource/java/stampedLock_8.jpg" alt=""></p>
</li>
<li><p>ThreadD 释放 ThreadE 获取读</p>
</li>
</ol>
<p><img src="../resource/java/stampedLock_9.jpg" alt=""></p>
<p>说明: 流程大致是这样的流程，但是此处由很多细节没有说明，就是自旋的那个地方释放，从哪里开始执行，执行后做了什么。<br>这个可以具体看代码细节，获取锁的地方有这么的自旋操作，就是希望尽量减少锁本身带来的开销，以及起来之后能够较快唤醒相关线程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>StampedLock代码上来说，可以说非常复杂，其将CAS，自旋，乐观锁，悲观锁玩的非常溜。通过各种自旋操作，乐观，悲观判定，来减少锁本身带来的开销。</p>
<ol>
<li>StampedLock 通过state 低7位表示读锁， 第8位表示写锁。</li>
<li>StampedLock 没有进行读写锁重入的判定，线程重入可能有死锁风险</li>
<li>StampedLock 有三种模式，读，写，优化读。 所谓的优化读，是判定当前是否有写锁，没有写锁就不加锁 直接读取。 这里利用了内存屏障的概念可以参考<a href="/post/ab0f6be5.html" title="&lt;b&gt;并发理论一文&lt;&#x2F;b&gt;"><b>并发理论一文</b></a></li>
<li>StampedLock 为了优化锁本身开销，有大量自旋操作，和乐观锁判定操作。</li>
</ol>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>






<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://segmentfault.com/a/1190000015808032?utm_source=tag-newest#item-3-10" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015808032?utm_source=tag-newest#item-3-10</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantReadWriteLock源码分析</title>
    <url>/post/62b74ffe.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>ReentrantLock提供了独占锁的实现，但是现实场景很多都是属于读多写少的场景，这种场景如果是使用独占锁就会很消耗读的性能，在没有写操作的时候，多个线程同时读同一个数据的时候是没有问题的。</p>
<p>ReentrantReadWriteLock 就是通过提供读写锁的方式来满足这个场景。</p>
<p>其有两个锁</p>
<ol>
<li>readlock   共享锁</li>
<li>writeLock  独占锁</li>
</ol>
<p>线程可拥有读锁的条件：无线程占用写锁，或者本线程占用写锁。</p>
<p>可拥有写锁的条件： 无其他线程读锁， 无其他线程写锁</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> boolean cacheValid;</span><br><span class="line">    final ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      rwl.readLock().<span class="keyword">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">        <span class="comment">// 加写锁前需要先释放读锁</span></span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">        rwl.writeLock().<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//设置值</span></span><br><span class="line">          <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            data = ...</span><br><span class="line">            cacheValid = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 写锁退化为读锁 已经修改完成 其他线程可读</span></span><br><span class="line">          rwl.readLock().<span class="keyword">lock</span>();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放写锁</span></span><br><span class="line">          rwl.writeLock().unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        use(data);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放读锁</span></span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span>.<span class="type">ReadLock</span> readerLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span>.<span class="type">WriteLock</span> writerLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Sync</span> sync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReetrantReadWriteLock与 <a href="/post/4b83aa2d.html" title="&lt;b&gt;ReentrantLock&lt;&#x2F;b&gt;"><b>ReentrantLock</b></a> 的结构基本一致 :</p>
<p><img src="../resource/java/Aqs%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p><img src="../resource/java/sync%E7%BB%A7%E6%89%BF.jpg" alt=""></p>
<h2 id="重要类"><a href="#重要类" class="headerlink" title="重要类"></a>重要类</h2><h3 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Aqs 结构</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">           sync = lock.sync;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//锁定</span></span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//使用共享锁</span></span><br><span class="line">           sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">           sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尝试获取共享锁</span></span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">return</span> sync.<span class="title">tryReadLock</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">boolean</span> tryLock(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">               <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">           <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//释放共享锁</span></span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 使用Aqs结构</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">           sync = lock.sync;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//使用Aqs的独占锁</span></span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sync.acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">           sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尝试获取写锁</span></span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">return</span> sync.<span class="title">tryWriteLock</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">boolean</span> tryLock(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">               <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">           <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//释放独占锁</span></span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sync.release(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">return</span> sync.<span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">return</span> sync.<span class="title">isHeldExclusively</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">return</span> sync.<span class="title">getWriteHoldCount</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>说明：</p>
<ol>
<li>读锁写锁均使用Aqs结构来实现锁定和释放</li>
<li>读锁使用的是共享锁模式</li>
<li>写锁使用的是 独占锁模式</li>
</ol>
<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享锁 移动位数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 共享锁基础单位， 没增加一个单位共享锁 其实是加上1&lt;&lt;16的数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="comment">//最大的锁数量，锁的数量不能超过 2^16-1个 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算独占锁数量的中间变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取共享锁占有数量  无符号右移16位 获得读写数量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取独占锁占有数量   与mask做&amp;运算 消除高16位 结果就是独占锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁当前线程持有数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个成功获取读锁的线程 的读锁持有数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个持有读写的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>说明：</p>
<ol>
<li>AbstractQueuedSychronized 的状态是int 的state属性 int是32位的</li>
<li>由于state是32位，只有1个状态，所以ReentrantReadWriteLock通过高16位和低16位分隔，高16位存储读锁，低16位存储写锁。</li>
<li>锁的最大数量是2^16-1个</li>
</ol>
<p><img src="../resource/java/%E8%AF%BB%E5%86%99%E9%94%81%E6%95%B0%E9%87%8F.jpg" alt=""></p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="sync-tryAcquireShared"><a href="#sync-tryAcquireShared" class="headerlink" title="sync.tryAcquireShared();"></a>sync.tryAcquireShared();</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="built_in">int</span> tryAcquireShared(<span class="built_in">int</span> unused) &#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="built_in">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 有写锁 并且不是当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 获取读锁个数</span></span><br><span class="line">    <span class="built_in">int</span> r = sharedCount(c);</span><br><span class="line">   <span class="comment">//有写锁等待唤醒 读锁增加成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">//设置计数器</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.<span class="keyword">get</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.<span class="keyword">set</span>(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示还可以获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 兜底策略 处理 并发CAS miss的场景。</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="keyword">class</span> <span class="symbol">NonfairSync</span> <span class="symbol">extends</span> <span class="symbol">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span>ean writerShouldBlock() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span>ean readerShouldBlock() &#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否有写锁在等待唤醒 此处是为了防止写锁出现饿死现象。所以后面一个节点如果是写锁，则需要阻塞住读锁的资源获取。</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">bool</span>ean apparentlyFirstQueuedIsExclusive() &#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整的尝试获取方案 ，包含了兜底 和读锁重入检查</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">    HoldCounter rh = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//当前状态</span></span><br><span class="line">        <span class="built_in">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 有写锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//不是当前线程 获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">//有写锁等待 读锁以获取 不用重入获取</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置计数器</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.<span class="keyword">get</span>();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界检查</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            throw new Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 尝试获取 设置计数器</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.<span class="keyword">get</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.<span class="keyword">set</span>(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>如果写锁被其他线程持有，则无法获取读锁，去Aqc中等待。</li>
<li>读写锁都不能超过2^16-1个，所以需要通过ThreadLocal来记录数量</li>
<li>并发读锁获取会到只CAS miss 需要fullTryAcquireShared 来自旋兜底</li>
</ol>
<h3 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">ReleaseShared(<span class="params">int</span> <span class="params">unused</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">    <span class="comment">// 如果第一个读锁是当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader<span class="operator"> == </span>current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="comment">// 并且当前线程只占有1个则取消 否则-1</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount<span class="operator"> == </span><span class="number">1</span>)</span><br><span class="line">            firstReader = null;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取最后一个加读锁的线程</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="comment">// 为null 或者不是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (rh<span class="operator"> == </span>null<span class="operator"> || </span>rh.tid != get<span class="constructor">ThreadId(<span class="params">current</span>)</span>)</span><br><span class="line">            <span class="comment">// 获取当前线程的计数器</span></span><br><span class="line">            rh = readHolds.get<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> count = rh.count;</span><br><span class="line">        <span class="comment">//重新设置计数器</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove<span class="literal">()</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                throw unmatched<span class="constructor">UnlockException()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自旋 设置新的锁计数值。</span></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = get<span class="constructor">State()</span>;</span><br><span class="line">        <span class="built_in">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compare<span class="constructor">AndSetState(<span class="params">c</span>, <span class="params">nextc</span>)</span>)</span><br><span class="line">            <span class="comment">//只有当读写锁都是0的时候，才会唤醒后续节点</span></span><br><span class="line">            return nextc<span class="operator"> == </span><span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="sync-tryAcquire"><a href="#sync-tryAcquire" class="headerlink" title="sync.tryAcquire"></a>sync.tryAcquire</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">    <span class="built_in">int</span> c = get<span class="constructor">State()</span>;</span><br><span class="line">    <span class="built_in">int</span> w = exclusive<span class="constructor">Count(<span class="params">c</span>)</span>;</span><br><span class="line">    <span class="comment">//有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//有写锁 并且不是当前线程占有 则不可以获取</span></span><br><span class="line">        <span class="keyword">if</span> (w<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>current != get<span class="constructor">ExclusiveOwnerThread()</span>)</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 大于最大数 不可再获取</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusive<span class="constructor">Count(<span class="params">acquires</span>)</span> &gt; MAX_COUNT)</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>;</span><br><span class="line">        <span class="comment">// 重入  获取</span></span><br><span class="line">        set<span class="constructor">State(<span class="params">c</span> + <span class="params">acquires</span>)</span>;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非公平锁 write始终为false  尝试获取锁资源</span></span><br><span class="line">    <span class="keyword">if</span> (writer<span class="constructor">ShouldBlock()</span> <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">        !compare<span class="constructor">AndSetState(<span class="params">c</span>, <span class="params">c</span> + <span class="params">acquires</span>)</span>)</span></span><br><span class="line"><span class="pattern-match">        return <span class="literal">false</span>;</span></span><br><span class="line"><span class="pattern-match">    set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    return <span class="literal">true</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<p>说明： 写锁在其他线程占据有锁的情况下不可以加锁。</p>
<h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Release(<span class="params">int</span> <span class="params">releases</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//是否当前线程独占</span></span><br><span class="line">    <span class="keyword">if</span> (!is<span class="constructor">HeldExclusively()</span>)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalMonitorStateException()</span>;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">int</span> nextc = get<span class="constructor">State()</span> - releases;</span><br><span class="line">    <span class="comment">//如果独占锁=0 表示写锁已经释放</span></span><br><span class="line">    boolean free = exclusive<span class="constructor">Count(<span class="params">nextc</span>)</span><span class="operator"> == </span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">//设置null</span></span><br><span class="line">        set<span class="constructor">ExclusiveOwnerThread(<span class="params">null</span>)</span>;</span><br><span class="line">    set<span class="constructor">State(<span class="params">nextc</span>)</span>;</span><br><span class="line">    <span class="comment">//如果无写锁占有 唤醒后续线程</span></span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>ReentrantReadWriteLock 通过在同一个Sync（Aqs）上保存共享节点和独占节点来实现读写锁</p>
<ol>
<li>读写锁的数量分别使用 高16位读锁  低16位写锁 来记录</li>
<li>读锁加锁的时候，会查询写锁数量，以及写锁占有线程，如果写锁数量！=0 并且占有线程不是当前线程，则不可以获取读锁</li>
<li>读锁释放的时候，会判断当前锁的状态，如果当前无锁了，则会唤醒后续节点。</li>
<li>写锁加锁的时候，会判断是否其他线程占有锁，是则不可获取锁</li>
<li>写锁释放的时候，会判断写锁资源是不是已经被当前线程释放完毕，如果释放完毕，则会唤醒sync队列后续线程</li>
</ol>
<p>ReentrantReadWriteLock 问题：由于写锁需要等到所有读锁释放，所以写锁很可能出现饥饿问题。使用公平策略可以得到缓解，但是公平策略可能导致的是线程开销问题，因为即使可以立即获取锁，也要排在队列末尾</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock源码分析</title>
    <url>/post/4b83aa2d.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>ReentrantLock为锁常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。本节就来看看ReentrantLock的实现。</p>
<p>可重入锁：可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例:"></a>使用示例:</h1><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">X</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();  <span class="comment">// block until condition holds</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... method body</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码可以看到 ReentrantLock内部维护了一个AbstractQueuedSynchronized的结构。而AbstractQueuedSynchronized结构我们在 <a href="/post/b6468daf.html" title="&lt;b&gt;Aqs源码解析&lt;&#x2F;b&gt;"><b>Aqs源码解析</b></a> 一文中已经说过了。</p>
<p><img src="../resource/java/Aqs%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>sync的继承关系如下:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/sync%E7%BB%A7%E6%89%BF.jpg" alt=""></p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">    * given fairness policy.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 在创建ReetrantLock的时候可以选择是公平锁还是非公平锁。默认是非公平锁</p>
<p>公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO；<br>非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用 sync 进行锁定</span></span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非公平锁优先尝试抢占 ，不成功在通过Aqs去排队</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公平锁 直接进入Aqs排队</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// acquire会在Aqs中回调tryAcquire</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果当前状态为0 没有被占用</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有其他线程等待资源 尝试直接抢占 优化队列时间</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是当前线程占有资源</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// 设置资源占用数</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平锁逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接抢占</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 判断当前资源占用情况 当前锁此处表示 当前线程占用次数</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: </p>
<ol>
<li>lock的操作都是调用Aqs的acquire方法实现</li>
<li>公平锁和非公平锁的实现仅在于非公平锁会优先尝试占有锁，然后在放入aqs队列，而公平锁是直接放入aqs队列</li>
<li>在进行tryAcquire获取锁的时候，会先看看有没有冲突，其他线程有没有占用，如果没有，则优先尝试直接占用，此为优化项。</li>
</ol>
<h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.<span class="built_in">release</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试释放</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//不是当前线程占有 则报错</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> <span class="built_in">free</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 看看当前资源是否已经无占用</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span> = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>公平锁非公平锁的释放策略一直，主要依赖Aqs结构</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ReentrantLock的源码相对比较简单，主要依赖了AbstractQueuedSynchronized的结构进行的的锁定和解锁操作。AbstractQueuedSynchronized的解析可以查看 <a href="/post/b6468daf.html" title="&lt;b&gt;Aqs源码解析&lt;&#x2F;b&gt;"><b>Aqs源码解析</b></a> 一文</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>LockSupport源码分析</title>
    <url>/post/e62a890b.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Basic thread blocking primitives for creating locks and other synchronization classes.</p>
<p>LockSupport为其他锁类或者同步类提供了基础的阻塞操作。可以说JUC的锁离不开LockSuppott的支持。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> thread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="type">LockSupport</span>.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> public void run() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"in "</span> + getName());</span><br><span class="line">        <span class="type">LockSupport</span>.park();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"继续执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>park unpark 成对出现，一个阻塞，一个解除阻塞。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//底层操作类</span></span><br><span class="line"><span class="keyword">private</span> static final sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">//blocker的偏移地址</span></span><br><span class="line"><span class="keyword">private</span> static final long parkBlockerOffset;</span><br><span class="line"><span class="keyword">private</span> static final long SEED;</span><br><span class="line"><span class="keyword">private</span> static final long PROBE;</span><br><span class="line"><span class="keyword">private</span> static final long SECONDARY;</span><br><span class="line">static &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.<span class="module-access"><span class="module"><span class="identifier">Unsafe</span>.</span></span>get<span class="constructor">Unsafe()</span>;</span><br><span class="line">        Class&lt;?&gt; tk = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">        parkBlockerOffset = <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>objectFieldOffset</span><br><span class="line">            (tk.get<span class="constructor">DeclaredField(<span class="string">"parkBlocker"</span>)</span>);</span><br><span class="line">        SEED = <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>objectFieldOffset</span><br><span class="line">            (tk.get<span class="constructor">DeclaredField(<span class="string">"threadLocalRandomSeed"</span>)</span>);</span><br><span class="line">        PROBE = <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>objectFieldOffset</span><br><span class="line">            (tk.get<span class="constructor">DeclaredField(<span class="string">"threadLocalRandomProbe"</span>)</span>);</span><br><span class="line">        SECONDARY = <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>objectFieldOffset</span><br><span class="line">            (tk.get<span class="constructor">DeclaredField(<span class="string">"threadLocalRandomSecondarySeed"</span>)</span>);</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw <span class="keyword">new</span> <span class="constructor">Error(<span class="params">ex</span>)</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><h3 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void park<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞函数</span></span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    <span class="comment">//阻塞当前线程</span></span><br><span class="line">    Thread t = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">    <span class="comment">//设置block值为blocker</span></span><br><span class="line">    set<span class="constructor">Blocker(<span class="params">t</span>, <span class="params">blocker</span>)</span>;</span><br><span class="line">    <span class="comment">//阻塞</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    set<span class="constructor">Blocker(<span class="params">t</span>, <span class="params">null</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> static void set<span class="constructor">Blocker(Thread <span class="params">t</span>, Object <span class="params">arg</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Even though volatile, hotspot doesn't need a write barrier here.</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>put<span class="constructor">Object(<span class="params">t</span>, <span class="params">parkBlockerOffset</span>, <span class="params">arg</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Object get<span class="constructor">Blocker(Thread <span class="params">t</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t<span class="operator"> == </span>null)</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">NullPointerException()</span>;</span><br><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">UNSAFE</span>.</span></span>get<span class="constructor">ObjectVolatile(<span class="params">t</span>, <span class="params">parkBlockerOffset</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>park()函数是直接调用Unsafe的park方法</li>
<li>blocker的作用通常用来允许监控或者诊断工具识别被阻塞的原因。</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">The three forms <span class="keyword">of</span> &#123;@code park&#125; <span class="keyword">each</span> <span class="keyword">also</span> support a &#123;@code blocker&#125; <span class="keyword">object</span> parameter. This <span class="keyword">object</span> <span class="keyword">is</span> recorded <span class="keyword">while</span> he thread <span class="keyword">is</span> blocked <span class="keyword">to</span> permit monitoring <span class="keyword">and</span> diagnostic tools <span class="keyword">to</span></span><br><span class="line">identify the reasons that threads are blocked</span><br></pre></td></tr></table></figure>

<p>通过 getBlock()方法可以获取blocker的信息.</p>
<p><strong>注意：如果unpark()已经先于park()执行了那么park()不会在阻塞</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Block current thread, <span class="keyword">returning</span> when a balancing</span><br><span class="line">unpark occurs, <span class="keyword">or</span> a balancing unpark has</span><br><span class="line">already occurred, <span class="keyword">or</span> <span class="keyword">the</span> thread <span class="keyword">is</span> interrupted, <span class="keyword">or</span>, <span class="keyword">if</span> <span class="keyword">not</span></span><br><span class="line">absolute <span class="keyword">and</span> <span class="built_in">time</span> <span class="keyword">is</span> <span class="keyword">not</span> zero, <span class="keyword">the</span> <span class="keyword">given</span> <span class="built_in">time</span> nanoseconds have</span><br><span class="line">elapsed, <span class="keyword">or</span> <span class="keyword">if</span> absolute, <span class="keyword">the</span> <span class="keyword">given</span> deadline <span class="keyword">in</span> milliseconds</span><br><span class="line"><span class="keyword">since</span> Epoch has passed, <span class="keyword">or</span> spuriously (i.e., <span class="keyword">returning</span> <span class="keyword">for</span> no</span><br><span class="line"><span class="string">"reason"</span>). Note: This operation <span class="keyword">is</span> <span class="keyword">in</span> <span class="keyword">the</span> Unsafe <span class="built_in">class</span> only</span><br><span class="line">because unpark <span class="keyword">is</span>, so <span class="keyword">it</span> would be strange <span class="keyword">to</span> place <span class="keyword">it</span></span><br><span class="line">elsewhere.</span><br></pre></td></tr></table></figure>

<h3 id="unpark"><a href="#unpark" class="headerlink" title="unpark()"></a>unpark()</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒thread线程</span></span><br><span class="line"><span class="keyword">public</span> static <span class="literal">void</span> unpark(<span class="keyword">Thread</span> <span class="keyword">thread</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">thread</span> != <span class="built_in">null</span>)</span><br><span class="line">        UNSAFE.unpark(<span class="keyword">thread</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LockSupport调用的是unsafe类的基本方法，所以看上去会比较简单。</p>
<p>简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行</p>
<h2 id="park-unpark-和-wait-signal的区别"><a href="#park-unpark-和-wait-signal的区别" class="headerlink" title="park unpark 和 wait signal的区别"></a>park unpark 和 wait signal的区别</h2><ol>
<li>park不需要获取某个对象的锁</li>
<li>因为中断的时候park不会抛出InterruptedException异常，所以需要在park之后自行判断中断状态，然后做额外的处理</li>
<li>park unpark 顺序不需要强依赖，先unpark 后park park可以正常直接往下。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Aqs源码解析</title>
    <url>/post/b6468daf.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于java并发变成来说，java.util.concurrent包毫不夸张的说，占据着核心的地位，而其中 AbstractQueuedSynchronizer 又无疑是核心中的核心，他提供了一个FIFO的队列，可以用于构建锁或者其他相关同步的基础框架。那么接下来我们就分析分析Aqs的源码，了解java 工具锁的构建方式。</p>
<h1 id="Aqs源码分析"><a href="#Aqs源码分析" class="headerlink" title="Aqs源码分析"></a>Aqs源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = <span class="number">-3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/Aqs%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>可以看到，AbstractQueuedSynchronizer内部是一个双向链表的结构，通过双向链表来实现队列。</p>
<p>sync queueu:维护的队列是等待资源的队列。当前线程获取同步状态失败时(即资源冲突，被锁)，同步器会将当前线程以及等待信息构造成一个node节点并加入同步队列中，同时会阻塞当前线程的执行。当同步状态释放的时候，会首先把首节点的线程唤醒，使其再次尝试获取同步状态</p>
<p>condition queue:每个condition维护这一个队列，该队列的作用是维护一个等待signals的队列。我们之前在 <a href="/post/85e75abb.html" title="&lt;b&gt;Thread详解&lt;&#x2F;b&gt;"><b>Thread详解</b></a> 中说过，wait()方法会释放锁，此处的condition就是作用于此。</p>
<p><strong><em>waitStatus状态：</em></strong></p>
<ol>
<li>CANCELLED :取消 线程超时或者被打断 </li>
<li>SIGNAL  :表示当前的节点的后续节点需要执行，当他释放或者取消的时候需要执行 unpark 后续节点的操作</li>
<li>CONDITION  : 在等待队列中 </li>
<li>PROPAGATE ： 释放共享锁的时候，会传递到后面的节点。</li>
</ol>
<details>
<summary><font color='red'>View Code</font></summary>


<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Status field, taking on only </span>the<span class="markdown"> values:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*   </span>SIGNAL:     The successor of this node is (or </span>will<span class="markdown"> soon be)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>blocked (via park), </span>so<span class="markdown"> </span>the<span class="markdown"> current node must</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>unpark its successor when it releases or</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>cancels. To avoid races, acquire methods must</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>first indicate </span>they<span class="markdown"> need </span>a<span class="markdown"> signal,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>then retry </span>the<span class="markdown"> atomic acquire, and then,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>on failure, block.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*   </span>CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>Nodes never leave this state. In particular,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span></span>a<span class="markdown"> thread with cancelled node never again blocks.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*   </span>CONDITION:  This node is currently on </span>a<span class="markdown"> condition queue.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>It </span>will<span class="markdown"> not be used as </span>a<span class="markdown"> sync queue node</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>until transferred, at which time </span>the<span class="markdown"> status</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span></span>will<span class="markdown"> be set to 0. (Use of this value here has</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>nothing to do with </span>the<span class="markdown"> other uses of </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>field, </span>but<span class="markdown"> simplifies mechanics.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*   </span>PROPAGATE:  A releaseShared </span>should<span class="markdown"> be propagated to other</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>nodes. This is set (for head node only) in</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>doReleaseShared to ensure propagation</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>continues, even if other operations have</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*               </span>since intervened.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*   </span>0:          None of </span>the<span class="markdown"> above</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*/</span></span></span><br><span class="line">volatile <span class="built_in">int</span> waitStatus;</span><br></pre></td></tr></table></figure>

</details>





<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数:"></a>核心函数:</h2><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">// lock()函数会调用改方法  以独占模式尝试获取资源</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">// 尝试获取资源，如果失败 则继续调用 acquireQueued 尝试在队列中获取资源。</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(<span class="keyword">Node</span>.<span class="title">EXCLUSIVE</span>), arg))</span><br><span class="line">        　　selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//尝试获取资源，由子类实现</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将节点加入到队列</span><br><span class="line">private <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>) &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), mode);</span><br><span class="line">    //尾节点不为null 则通过compareAndSet来快速设置尾节点,为新增节点</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">pred</span> = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">prev</span> = pred;</span><br><span class="line">        if (compareAndSetTail(pred, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">            pred</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">            return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">    //尾节点为null</span> 或者compareAndSetTail失败，则走正常流程</span><br><span class="line">    enq(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">private</span> <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    //循环中将<span class="keyword">node</span><span class="title">设置为尾节点。</span></span><br><span class="line"><span class="title">    for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">t</span> = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))</span></span><br><span class="line"><span class="title">                tail</span> = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = t;</span><br><span class="line">            if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">                t</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尝试从队列中获取资源</span><br><span class="line">final boolean acquireQueued(final <span class="keyword">Node</span> <span class="title">node</span>, int arg) &#123;</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获取<span class="keyword">node</span><span class="title">的prev</span>节点 前面的节点</span><br><span class="line">            final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">            // 如果p是头节点 则尝试获取资源</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                //头结点获取资源成功，则设置<span class="keyword">node</span><span class="title">为头节点</span></span><br><span class="line"><span class="title">                setHead</span>(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">                p</span>.next = null; // help GC</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // p不是头节点，</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></span><br><span class="line"><span class="title">                parkAndCheckInterrupt</span>())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            //中断  取消获取</span><br><span class="line">            cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">// 获取失败的时候检查更新节点状态</span></span><br><span class="line"><span class="title">private</span> static boolean shouldParkAfterFailedAcquire(<span class="keyword">Node</span> <span class="title">pred</span>, <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    // signal状态 则需要park 阻塞</span><br><span class="line">    if (ws == <span class="keyword">Node</span>.<span class="title">SIGNAL</span>)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    if (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        // &gt;<span class="number">0</span> 表示 CANCELLED 取消的需要被从队列中去除</span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125; else</span> &#123;</span><br><span class="line">        //CONDITION PROPAGATE 先设置为 SIGNAL 尝试获取锁</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//阻塞</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire 函数是上层lock()函数调用的方法。</p>
<p><img src="../resource/java/acquire%E6%96%B9%E6%B3%95.jpg" alt=""></p>
<p>从上面的流程和源码中我们可以发现：</p>
<ol>
<li>acquire 函数的获取有子类决定</li>
<li>一旦进入阻塞队列，只有前驱头结点有权利重新获取资源</li>
<li>阻塞的实现是通过 LockSupport.park实现的</li>
<li>由于是独占资源，所以当前线程获取锁之后，设置本线程为头结点。</li>
</ol>
<h3 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire()"></a>cancelAcquire()</h3><p>上述代码中我们发现，一旦parkAndCheckInterrupt 中的LockSupport被中断，进入了下一步，那么就会调用 cancelAcquire<br>那么我们来看看 cancelAcquire的代码</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">private void cancelAcquire(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    if (<span class="keyword">node</span> <span class="title">== null</span>)</span><br><span class="line">        return;</span><br><span class="line">    <span class="keyword">node</span>.<span class="title">thread</span> = null;</span><br><span class="line"></span><br><span class="line">    // Skip cancelled predecessors</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">pred</span> = <span class="keyword">node</span>.<span class="title">prev</span>;</span><br><span class="line">    //删除所有前面为CANCELLED的节点</span><br><span class="line">    while (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Node</span> <span class="title">predNext</span> = pred.next;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">node</span>.<span class="title">waitStatus</span> = <span class="keyword">Node</span>.<span class="title">CANCELLED</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if (<span class="keyword">node</span> <span class="title">== tail</span> &amp;&amp; compareAndSetTail(<span class="keyword">node</span><span class="title">, pred</span>)) &#123;</span><br><span class="line">        // 如果<span class="keyword">node</span><span class="title">本身是尾节点，则直接删除当前节点 没有需要唤醒的节点了。</span></span><br><span class="line"><span class="title">        compareAndSetNext</span>(pred, predNext, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ws;</span><br><span class="line">        // 前驱节点不是头节点，并且</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == <span class="keyword">Node</span>.<span class="title">SIGNAL</span> ||</span><br><span class="line">                (ws <span class="tag">&lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span></span><br><span class="line"><span class="tag">            pred.thread != null) &#123;</span></span><br><span class="line"><span class="tag">            // 删除掉 node</span></span><br><span class="line"><span class="tag">            Node next = node.next;</span></span><br><span class="line"><span class="tag">            if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span></span><br><span class="line"><span class="tag">                compareAndSetNext(pred, predNext, next);</span></span><br><span class="line"><span class="tag">        &#125; else &#123;</span></span><br><span class="line"><span class="tag">            // 是头结点，或者设置signal失败 尝试唤醒后续节点</span></span><br><span class="line"><span class="tag">            unparkSuccessor(node);</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        node.next = node; // help GC</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">private void unparkSuccessor(Node node) &#123;</span></span><br><span class="line"><span class="tag">    int ws = node.waitStatus;</span></span><br><span class="line"><span class="tag">    if (ws &lt; 0)</span></span><br><span class="line"><span class="tag">       //当前节点小于0 则设置为0 因为当前节点已经结束。</span></span><br><span class="line"><span class="tag">        compareAndSetWaitStatus(node, ws, 0);</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    Node s = node.next;</span></span><br><span class="line"><span class="tag">    // 如果后续节点已经cancel</span></span><br><span class="line"><span class="tag">    if (s == null || s.waitStatus &gt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        //从后往前找最靠前没有cancel的</span><br><span class="line">        for (<span class="keyword">Node</span> <span class="title">t</span> = tail; t != null &amp;&amp; t != <span class="keyword">node</span><span class="title">; t</span> = t.prev)</span><br><span class="line">            if (t.waitStatus <span class="tag">&lt;= 0)</span></span><br><span class="line"><span class="tag">                s = t;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">    if (s != null)</span></span><br><span class="line"><span class="tag">        //唤醒</span></span><br><span class="line"><span class="tag">        LockSupport.unpark(s.thread);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/cancelAcquire%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<p>说明：<strong>一般情况唤醒节点的时候都是直接唤醒后继节点，如果后继节点状态&lt;0或者为null，则从尾节点开始遍历，为什么？</strong></p>
<p>我们可以看下上面的addWaiter中的enq方法：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">private <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    //循环中将<span class="keyword">node</span><span class="title">设置为尾节点。</span></span><br><span class="line"><span class="title">    for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">t</span> = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))</span></span><br><span class="line"><span class="title">                tail</span> = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = t;</span><br><span class="line">            if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">                t</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点插入的时候，是先设置  node.prev=t，然后在进行compareAndSetTail。我们可以知道一个事情，如果尾节点变更了，那么从尾节点查找一定是正常的。</p>
<p>如果从前往后找，可能出现的情况是，尾节点已经变更了，但是却找不到，因为此时尾节点的变更 和 t.next= node 是两步操作。t.next=node 可能没有，导致出现异常情况。</p>
<p>如文中所述：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">An AbstractQueuedSynchronizer queue node <span class="keyword">contains</span> a</span><br><span class="line">next link <span class="keyword">to</span> <span class="keyword">its</span> successor. But because there are no applicable</span><br><span class="line">techniques <span class="keyword">for</span> lock-free atomic insertion <span class="keyword">of</span> double-linked <span class="built_in">list</span></span><br><span class="line">nodes using compareAndSet, this link <span class="keyword">is</span> <span class="keyword">not</span> atomically <span class="keyword">set</span> <span class="keyword">as</span></span><br><span class="line">part <span class="keyword">of</span> insertion; <span class="keyword">it</span> <span class="keyword">is</span> simply assigned:</span><br><span class="line"> pred.next = node;</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">the</span> insertion. This <span class="keyword">is</span> reflected <span class="keyword">in</span> all usages. The next link</span><br><span class="line"><span class="keyword">is</span> treated only <span class="keyword">as</span> an optimized path. If a node's successor <span class="keyword">does</span></span><br><span class="line"><span class="keyword">not</span> appear <span class="keyword">to</span> exist (<span class="keyword">or</span> appears <span class="keyword">to</span> be cancelled) via <span class="keyword">its</span> next field,</span><br><span class="line"><span class="keyword">it</span> <span class="keyword">is</span> always possible <span class="keyword">to</span> start <span class="keyword">at</span> <span class="keyword">the</span> tail <span class="keyword">of</span> <span class="keyword">the</span> <span class="built_in">list</span> <span class="keyword">and</span> traverse</span><br><span class="line">backwards using <span class="keyword">the</span> pred field <span class="keyword">to</span> accurately check <span class="keyword">if</span> there</span><br><span class="line">really <span class="keyword">is</span> one</span><br></pre></td></tr></table></figure>




<h3 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h3><p>release是释放锁资源的函数。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 成功 并且头结点不是canceled 则需要唤醒后继节点。</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ConditionObject-await"><a href="#ConditionObject-await" class="headerlink" title="ConditionObject await()"></a>ConditionObject await()</h3><details>
<summary><font color='red'>View Code</font></summary>


<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 节点清理 删除所有不是condition状态的节点</span><br><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">t</span> = firstWaiter;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">trail</span> = null;</span><br><span class="line">    while (t != null) &#123;</span><br><span class="line">        // 从头结点向后</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">next</span> = t.nextWaiter;</span><br><span class="line">        // 节点不是condition</span><br><span class="line">        if (t.waitStatus != <span class="keyword">Node</span>.<span class="title">CONDITION</span>) &#123;</span><br><span class="line">            // 删除该节点</span><br><span class="line">            t.nextWaiter = null;</span><br><span class="line">            if (trail == null)</span><br><span class="line">               // 重新设置头结点</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            else</span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            if (next == null)</span><br><span class="line">                // 重新设置尾节点</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            // trail 为保存下的节点</span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 节点加入到condition 队列尾部</span><br><span class="line">private <span class="keyword">Node</span> <span class="title">addConditionWaiter</span>() &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">t</span> = lastWaiter;</span><br><span class="line">    // 如果尾节点不是 Condition状态 做节点清理</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != <span class="keyword">Node</span>.<span class="title">CONDITION</span>) &#123;</span><br><span class="line">        // 节点清理</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    // 新创建节点</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), <span class="keyword">Node</span>.<span class="title">CONDITION</span>);</span><br><span class="line">    //尾节点为null， 设置头结点为当前节点</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    else</span></span><br><span class="line">        t.nextWaiter = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    //设置尾节点</span></span><br><span class="line"><span class="title">    lastWaiter</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">// 释放当前节点锁占有的所有锁资源</span></span><br><span class="line"><span class="title">final</span> int fullyRelease(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 当前aqs状态</span><br><span class="line">        int savedState = getState();</span><br><span class="line">        //释放锁资源</span><br><span class="line">        if (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">waitStatus</span> = <span class="keyword">Node</span>.<span class="title">CANCELLED</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 判断sync中是否存在当前节点</span><br><span class="line">private boolean findNodeFromTail(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">t</span> = tail;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (t == <span class="keyword">node</span><span class="title">)</span></span><br><span class="line"><span class="title">            return</span> <span class="literal">true</span>;</span><br><span class="line">        if (t == null)</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断当前节点是否在sync队列中</span><br><span class="line">final boolean isOnSyncQueue(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    //如果<span class="keyword">node</span><span class="title">状态 为CONDITION</span> 或者没有前驱 直接返回<span class="literal">false</span></span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">waitStatus</span> == <span class="keyword">Node</span>.<span class="title">CONDITION</span> || <span class="keyword">node</span>.<span class="title">prev</span> == null)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    // 如果有后继节点 则返回<span class="literal">true</span> 因为只有sync有next</span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">next</span> != null) // If has successor, it must be on queue</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    // 在sync链表中查找当前节点。</span><br><span class="line">    return findNodeFromTail(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">public</span> final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 链表中新增节点</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();</span><br><span class="line">    // 释放所有锁资源</span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    // 判断当前节点是否在sync队列中</span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">        //不在 则阻塞</span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果被signal 唤醒 则会进入到sync队列 需要尝试获取锁资源</span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 因为他被唤醒了，所以他的后面肯定也被唤醒了 清理</span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p>说明：</p>
<ol>
<li>线程调用await方法的时候，会加入到condition的wait链表中</li>
<li>此处佐证了之前的await释放锁的说法，await在被调用的时候会调用fullRelease方法释放占有的所有锁资源信息。</li>
</ol>
<h3 id="ConditionObject-signal"><a href="#ConditionObject-signal" class="headerlink" title="ConditionObject signal()"></a>ConditionObject signal()</h3><details>
<summary><font color='red'>View Code</font></summary>


<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点转换到 sync队列</span></span><br><span class="line">final boolean transfer<span class="constructor">ForSignal(Node <span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置状态为0</span></span><br><span class="line">    <span class="keyword">if</span> (!compare<span class="constructor">AndSetWaitStatus(<span class="params">node</span>, Node.CONDITION, 0)</span>)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 加入到sync 队列中</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="built_in">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前驱节点canceled了，因为sync队列是从前往后获取资源的</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span><span class="operator"> || </span>!compare<span class="constructor">AndSetWaitStatus(<span class="params">p</span>, <span class="params">ws</span>, Node.SIGNAL)</span>)</span><br><span class="line">        <span class="comment">// 继续执行</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LockSupport</span>.</span></span>unpark(node.thread);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行唤醒</span></span><br><span class="line"><span class="keyword">private</span> void <span class="keyword">do</span><span class="constructor">Signal(Node <span class="params">first</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 取消当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter)<span class="operator"> == </span>null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transfer<span class="constructor">ForSignal(<span class="params">first</span>)</span> &amp;&amp;</span><br><span class="line">                (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒</span></span><br><span class="line">public final void signal<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="comment">//非独占锁不可唤醒</span></span><br><span class="line"><span class="keyword">if</span> (!is<span class="constructor">HeldExclusively()</span>)</span><br><span class="line">    throw <span class="keyword">new</span> <span class="constructor">IllegalMonitorStateException()</span>;</span><br><span class="line"><span class="comment">// 唤醒头结点</span></span><br><span class="line">Node first = firstWaiter;</span><br><span class="line"><span class="keyword">if</span> (first != null)</span><br><span class="line">    <span class="keyword">do</span><span class="constructor">Signal(<span class="params">first</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p>说明：</p>
<ol>
<li>signal唤醒，实际是将其放入到sync队列等待重新调度</li>
<li>signal的唤醒是从头结点开始唤醒的</li>
</ol>
<h3 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared()"></a>doAcquireShared()</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public final void acquire<span class="constructor">Shared(<span class="params">int</span> <span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">try</span><span class="constructor">AcquireShared(<span class="params">arg</span>)</span> &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">do</span><span class="constructor">AcquireShared(<span class="params">arg</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void <span class="keyword">do</span><span class="constructor">AcquireShared(<span class="params">int</span> <span class="params">arg</span>)</span> &#123;</span><br><span class="line">    final Node node = add<span class="constructor">Waiter(Node.SHARED)</span>;</span><br><span class="line">    boolean failed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor<span class="literal">()</span>;</span><br><span class="line">            <span class="keyword">if</span> (p<span class="operator"> == </span>head) &#123;</span><br><span class="line">                <span class="built_in">int</span> r = <span class="keyword">try</span><span class="constructor">AcquireShared(<span class="params">arg</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    set<span class="constructor">HeadAndPropagate(<span class="params">node</span>, <span class="params">r</span>)</span>;</span><br><span class="line">                    p.next = null; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        self<span class="constructor">Interrupt()</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (should<span class="constructor">ParkAfterFailedAcquire(<span class="params">p</span>, <span class="params">node</span>)</span> &amp;&amp;</span><br><span class="line">                park<span class="constructor">AndCheckInterrupt()</span>)</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancel<span class="constructor">Acquire(<span class="params">node</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：共享锁，share的模式其实与独占锁模式一直，只是共享锁的tryAcquire返回值表示是否还可以被其他线程获取，如果当前线程获取成功，通过propagate尝试唤醒其他线程。</p>
<h3 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public final boolean release<span class="constructor">Shared(<span class="params">int</span> <span class="params">arg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">try</span><span class="constructor">ReleaseShared(<span class="params">arg</span>)</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span><span class="constructor">ReleaseShared()</span>;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> void <span class="keyword">do</span><span class="constructor">ReleaseShared()</span> &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != null<span class="operator"> &amp;&amp; </span>h != tail) &#123;</span><br><span class="line">                <span class="built_in">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws<span class="operator"> == </span>Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compare<span class="constructor">AndSetWaitStatus(<span class="params">h</span>, Node.SIGNAL, 0)</span>)</span><br><span class="line">                        continue;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unpark<span class="constructor">Successor(<span class="params">h</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws<span class="operator"> == </span><span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compare<span class="constructor">AndSetWaitStatus(<span class="params">h</span>, 0, Node.PROPAGATE)</span>)</span><br><span class="line">                    continue;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h<span class="operator"> == </span>head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>共享锁的调用框架和独占锁很相似，它们最大的不同在于获取锁的逻辑——共享锁可以被多个线程同时持有，而独占锁同一时刻只能被一个线程持有。<br>由于共享锁同一时刻可以被多个线程持有，因此当头节点获取到共享锁时，可以立即唤醒后继节点来争锁，而不必等到释放锁的时候。因此，共享锁触发唤醒后继节点的行为可能有两处，一处在当前节点成功获得共享锁后，一处在当前节点释放共享锁后。</p>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程:"></a>整体流程:</h2><h3 id="独占锁，加锁、解锁"><a href="#独占锁，加锁、解锁" class="headerlink" title="独占锁，加锁、解锁"></a>独占锁，加锁、解锁</h3><p><img src="../resource/java/aqs%E7%8B%AC%E5%8D%A0%E9%94%81%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<p>说明：</p>
<ol>
<li>sync队列用于存放需要等待锁资源的线程节点信息</li>
<li>addWaiter确保队列中头结点始终保留了一个空线程节点信息。</li>
<li>shouldParkAfterFailedAcquire 确保当前节点前无canceled的节点，并且确保park()之前 把 pred的节点设置为 signal。</li>
<li>parkAndCheckInterrupt通过LockSupport进行加锁阻塞</li>
<li>unparkSuccessor释放的时候，是优先考虑next节点，如果next节点不可用，则从尾节点开始向前遍历（防止多线程问题）。</li>
</ol>
<h3 id="condition-await-signal"><a href="#condition-await-signal" class="headerlink" title="condition  await signal"></a>condition  await signal</h3><p><img src="../resource/java/condition%E9%93%BE%E8%A1%A8%E8%BF%87%E7%A8%8B.jpg" alt=""></p>
<p>说明：</p>
<ol>
<li>await其实是释放资源从sync队列中移除</li>
<li>signal唤醒其实是从condition队列中移除，加入到sync队列</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>AbstractQueuedSynchronized 最核心的是一个队列和一个链表，即sync队列 和 condition链表。</p>
<p>sync队列维护了等待锁资源的线程<br>condition链表维护了 await休眠的线程列表</p>
<ol>
<li>当一个节点无法获取锁资源的时候，会被加入到sync队列</li>
<li>每个线程的唤醒操作都是由前一个节点来进行唤醒的</li>
<li>当线程执行await之后，会被从sync队列移除加入到condition链表中</li>
<li>当线程被signal唤醒之后，会被从condition链表移除加入到sync队列中</li>
<li>共享锁和独占锁的实现一直，只是共享锁可以被多个线程同时持有，而独占锁同一时刻只能被一个线程持有</li>
<li>共享锁触发唤醒后继节点的行为可能有两处，一处在当前节点成功获得共享锁后，一处在当前节点释放共享锁后</li>
</ol>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>


<h1 id="参考和引申"><a href="#参考和引申" class="headerlink" title="参考和引申"></a>参考和引申</h1><blockquote>
<p><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a><br><a href="https://segmentfault.com/a/1190000016447307" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016447307</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>JUC</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile详解</title>
    <url>/post/f3607baf.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>volatile关键字可以说是java虚拟机提供的一种最轻量级的同步机制，但是volatile的语义又经常被错误的理解，导致出现预期外的错误，也因此volatile也经常是面试必问的问题，了解volatile变量的语义就显得非常重要。</p>
<h1 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h1><ol>
<li>保证了变量对所有线程的可见性，即当一条线程修改了这个变量的值之后，新值对于对于其他线程来说是可以立即知道的。（实现可见性）</li>
<li>禁止指令重排序功能，（实现有序性）</li>
<li>volatile是不保证变量的原子性的，原子性需要变量自行保证。</li>
</ol>
<h1 id="volatile-的实现原理"><a href="#volatile-的实现原理" class="headerlink" title="volatile 的实现原理"></a>volatile 的实现原理</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>Java代码：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> = new <span class="type">Singleton</span>();//<span class="keyword">instance</span>是volatile变量</span></span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x01a3de1d</span>: movb $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi);</span><br><span class="line"><span class="number">0x01a3de24</span>: lock  addl $<span class="number">0x0</span>,(%esp);</span><br></pre></td></tr></table></figure>

<p>lock 其实是内存屏障，我们之前在  <a href="/post/ab0f6be5.html" title="&lt;b&gt;java并发理论&lt;&#x2F;b&gt;"><b>java并发理论</b></a>  中有说过内存模型通过缓存一致协议和store buffers 以及invalid queue 来进行一致性的控制，由于store buffer 引入了 内存屏障。</p>
<p>此处的lock便是便是利用系统的内存屏障，将处理器中的缓存数据写回到主内存中，并且通知其他本地内存或者缓存失效。</p>
<p>对于java内存模型来说，这种操作相当于对缓存中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作。</p>
<p>对于可见性这条来说，有些任务修改变量对于所有线程可见就以为这是线程安全的，这种说法是错误的，因为<strong>volatile不保证变量的原子性</strong>。 如果一个的操作不是原子的，例如 i++这种，即使用volatile修饰，多线程操作也会出现问题。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">        Thread[] thread = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;thread.length;i++)&#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">                        incrase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)  </span><br><span class="line">            thread[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;thread.length;i++)&#123;</span><br><span class="line">            thread[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子，并发正确的话 其实结果应该是100000，但是实际结果往往小于100000，本质原因是因为i++并不是一个原子的操作，虽然写回到内存中的操作是原子的，但是i++包含了读取，计算 ，写回三个步骤。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><ol>
<li>禁止指令重排序</li>
<li>happen-before原则。</li>
</ol>
<h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>为了性能的优化JMM会在不改变正确语义的情况下，对volatile指令进行重新排序。</p>
<p>JMM 可以通过在特定位置生成内存屏障指令来禁止指令重排序如下：<br><img src="../resource/java/volatile%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C1.jpg" alt=""></p>
<p><img src="../resource/java/volatile%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C2.jpg" alt=""></p>
<h3 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h3><p>在 <a href="/post/ab0f6be5.html" title="&lt;b&gt;java并发理论&lt;&#x2F;b&gt;"><b>java并发理论</b></a> 中，我们说过happen-before的八大原则，其中就包括了volatile的原则：</p>
<p><strong>对一个volatile变量的写，先于对后面对这个变量的读操作</strong></p>
<p>其实现也是通过内存屏障的方式进行的实现。</p>
<h1 id="volatile-应用场景"><a href="#volatile-应用场景" class="headerlink" title="volatile 应用场景"></a>volatile 应用场景</h1><p>要使 volatile 变量提供理想的线程安全，必须具备如下条件：</p>
<ol>
<li>对变量的写，不依赖与当前值</li>
<li>该变量没有包含在其他变量的不变式中。</li>
</ol>
<h2 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    flag = <span class="literal">true</span>;   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123;   </span><br><span class="line">        <span class="comment">// do stuff  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通常来说，这种状态标记的转换，只有一种转换，即false-true，volatile保证了线程可见。不普适false-true-false的多重转换</strong></p>
<h2 id="独立观察"><a href="#独立观察" class="headerlink" title="独立观察"></a>独立观察</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> UserManager &#123;  </span><br><span class="line">    <span class="built_in">public</span> <span class="keyword">volatile</span> String lastUser; //发布的信息  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">public</span> <span class="type">boolean</span> authenticate(String <span class="keyword">user</span>, String <span class="keyword">password</span>) &#123;  </span><br><span class="line">        <span class="type">boolean</span> <span class="keyword">valid</span> = passwordIsValid(<span class="keyword">user</span>, <span class="keyword">password</span>);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">valid</span>) &#123;  </span><br><span class="line">            <span class="keyword">User</span> u = <span class="built_in">new</span> <span class="keyword">User</span>();  </span><br><span class="line">            activeUsers.<span class="keyword">add</span>(u);  </span><br><span class="line">            lastUser = <span class="keyword">user</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">valid</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来记录上一次登陆有用的信息。利用volatile的可见性。</p>
<h2 id="单例模式的优化-双重检查锁"><a href="#单例模式的优化-双重检查锁" class="headerlink" title="单例模式的优化(双重检查锁)"></a>单例模式的优化(双重检查锁)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instace;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;   </span><br><span class="line"><span class="comment">//第一次null检查     </span></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;            </span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;    <span class="comment">//1     </span></span><br><span class="line">        <span class="comment">//第二次null检查       </span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;            <span class="comment">//2  </span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();<span class="comment">//3  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;           </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> instance;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.jianshu.com/p/ccfe24b63d87" target="_blank" rel="noopener">https://www.jianshu.com/p/ccfe24b63d87</a><br><a href="https://www.cnblogs.com/ouyxy/p/7242563.html" target="_blank" rel="noopener">https://www.cnblogs.com/ouyxy/p/7242563.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread详解</title>
    <url>/post/85e75abb.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Thread类用于操作java线程的基础类，本文通过源码来对Thread类的功能以及方法进行分析了解</p>
<h1 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h1><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>            priority;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     daemon = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> Runnable <span class="keyword">target</span>;</span><br><span class="line"><span class="keyword">private</span> ThreadGroup group;</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>name:</strong> 线程名称.用于标识一个线程。创建线程的时候最好能够指定名称，在出现问题的时候有助于排查</p>
<p><strong>priority:</strong> 线程优先级。java线程的调度是抢占式调度，优先级字段让系统能够优先给与时间片执行</p>
<p><strong>daemon:</strong> 是否是后台线程，jvm退出的条件执行了exit()方法或者是所有的非后台线程都退出了。</p>
<p><strong>target:</strong> 需要执行的目标方法。</p>
<p><strong>group:</strong> 线程的分组</p>
<p><strong>threadLocal：</strong> 线程本地变量保存地方。</p>
<p><strong>threadStatus:</strong> 线程状态。<br><img src="../resource/java/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt=""></p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable <span class="keyword">target</span>, String name)</span> </span>&#123;</span><br><span class="line">    init(group, <span class="keyword">target</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> init(ThreadGroup g, Runnable <span class="keyword">target</span>, String name,</span><br><span class="line">                    <span class="keyword">long</span> stackSize) &#123;</span><br><span class="line">    init(g, <span class="keyword">target</span>, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的构造方法都是调用的该方法，无非是参数不同，是否有值的问题。线程的基本参数有3个，<br>threadGroup  target name 分别表示线程组，执行目标，和线程名称</p>
<p>stackSize 可以忽略，其内部注释如下:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    * The requested stack size <span class="keyword">for</span> this thread, <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">the</span> creator did</span><br><span class="line">    * <span class="keyword">not</span> specify a stack size.  It <span class="keyword">is</span> up <span class="keyword">to</span> <span class="keyword">the</span> VM <span class="keyword">to</span> do whatever <span class="keyword">it</span></span><br><span class="line">    * likes <span class="keyword">with</span> this <span class="built_in">number</span>; <span class="keyword">some</span> VMs will ignore <span class="keyword">it</span>.</span><br><span class="line">    */</span><br><span class="line">private long stackSize;</span><br></pre></td></tr></table></figure>

<p>target的使用是对于实现Runnabel接口方式的创建的线程执行的方法。</p>
<h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><h2 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">target</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">target</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处可以印证之前的线程创建方法：</p>
<ol>
<li>继承Thread  重写run方法。 重写run方法后执行的就是run中定义的内容</li>
<li>实现Runnable </li>
</ol>
<h2 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronized加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有NEW状态的线程可以执行    </span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前线程加入到group中。</span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行native方法</span></span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// native方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>run方法只是定义了线程执行的步骤，start方法才是真正启动线程，并且通过native方法启动</strong></p>
<h2 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public<span class="keyword"> final</span> void stop() &#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">   <span class="built_in"> if </span>(security != null) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">       <span class="built_in"> if </span>(this != Thread.currentThread()) &#123;</span><br><span class="line">            security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // A zero status value corresponds to <span class="string">"NEW"</span>, it can't change to</span><br><span class="line">    //<span class="built_in"> not-NEW </span>because we hold the lock.</span><br><span class="line">   <span class="built_in"> if </span>(threadStatus != 0) &#123;</span><br><span class="line">        resume(); // Wake up thread<span class="built_in"> if </span>it was suspended; no-op otherwise</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The VM can handle all thread states</span><br><span class="line">    stop0(new ThreadDeath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stop方法已经被取消了，根据注释中的解释：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">This method is inherently unsafe.  Stopping <span class="keyword">a</span> thread <span class="keyword">with</span>,Thread.<span class="built_in">stop</span> causes <span class="keyword">it</span> <span class="built_in">to</span> unlock all <span class="keyword">of</span> <span class="keyword">the</span> monitors that <span class="keyword">it</span>,has locked (<span class="keyword">as</span> <span class="keyword">a</span> natural consequence <span class="keyword">of</span> <span class="keyword">the</span> unchecked&lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up <span class="keyword">the</span> stack).  If <span class="keyword">any</span> <span class="keyword">of</span> <span class="keyword">the</span> objects previously protected <span class="keyword">by</span> these monitors were <span class="keyword">in</span> <span class="keyword">an</span> inconsistent state, <span class="keyword">the</span> damaged objects become visible <span class="built_in">to</span> other threads, potentially resulting <span class="keyword">in</span> arbitrary behavior.</span><br><span class="line"></span><br><span class="line">Many uses <span class="keyword">of</span> &lt;code&gt;<span class="built_in">stop</span>&lt;/code&gt; should be replaced <span class="keyword">by</span> code that simply  modifies some <span class="built_in">variable</span> <span class="built_in">to</span> indicate that <span class="keyword">the</span> target thread should <span class="built_in">stop</span> running.</span><br></pre></td></tr></table></figure>

<p>stop方法由于会释放之前monitor加锁的变量，导致这些变量可以对其他线程可见，导致结果不可预测。</p>
<p>如果需要停止线程应该使用变量的方式来进行。</p>
<h2 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon()"></a>setDaemon()</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置为守护线程。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//The thread does not lose ownership of any monitors.</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> sleep(<span class="keyword">long</span> <span class="built_in">millis</span>) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sleep(<span class="keyword">long</span> <span class="built_in">millis</span>, <span class="built_in">int</span> nanos)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; <span class="built_in">millis</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">millis</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="built_in">millis</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep 休眠指定时间。交出CPU，让CPU执行其他任务。</p>
<p><strong>注意:sleep 不会释放当前线程持有的锁。</strong></p>
<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait()/notify()/notifyAll()"></a>wait()/notify()/notifyAll()</h2><p>实际上 wait notify notifyAll并不是 Thread的方法，但是其是线程操作的基本方法，并且wait方法经常拿来和sleep方法比较，所以此处也说下这三个方法</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个方法都看不到源码，其均是native的方法</p>
<p>我们来看看wait 的注释：</p>
<details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>Causes </span>the<span class="markdown"> current thread to wait until either another thread invokes </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@link java.lang.Object#notify()&#125; method or </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@link java.lang.Object#notifyAll()&#125; method for this object, or </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>specified amount of time has elapsed.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>The current thread must own this object's monitor.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>This method causes </span>the<span class="markdown"> current thread (call it <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span>) to</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>place itself in </span>the<span class="markdown"> wait set for this object and then to relinquish</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>any and all synchronization claims on this object. Thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>becomes disabled for thread scheduling purposes and lies dormant</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>until one of four things happens:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Some other thread invokes </span>the<span class="markdown"> &#123;@code notify&#125; method for this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>object and thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span> happens to be arbitrarily chosen as</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span></span>the<span class="markdown"> thread to be awakened.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Some other thread invokes </span>the<span class="markdown"> &#123;@code notifyAll&#125; method for this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>object.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Some other thread &#123;@linkplain Thread#interrupt() interrupts&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span>.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>The specified amount of real time has elapsed, </span>more<span class="markdown"> or less.  If</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@code timeout&#125; is zero, however, then real time is not taken into</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>consideration and </span>the<span class="markdown"> thread </span>simply<span class="markdown"> waits until notified.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>The thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span> is then removed from </span>the<span class="markdown"> wait set for this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>object and re-enabled for thread scheduling. It then competes in </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>usual manner with other threads for </span>the<span class="markdown"> right to synchronize on </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>object; once it has gained control of </span>the<span class="markdown"> object, all its</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>synchronization claims on </span>the<span class="markdown"> object </span>are<span class="markdown"> restored to </span>the<span class="markdown"> status quo</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>ante - that is, to </span>the<span class="markdown"> situation as of </span>the<span class="markdown"> time that </span>the<span class="markdown"> &#123;@code wait&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>method was invoked. Thread <span class="xml"><span class="tag">&lt;<span class="name">var</span>&gt;</span></span>T<span class="xml"><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span> then returns from </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>invocation of </span>the<span class="markdown"> &#123;@code wait&#125; method. Thus, on return from </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@code wait&#125; method, </span>the<span class="markdown"> synchronization state of </span>the<span class="markdown"> object and of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>thread &#123;@code T&#125; is exactly as it was when </span>the<span class="markdown"> &#123;@code wait&#125; method</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>was invoked.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>A thread can also wake up without being notified, interrupted, or</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>timing out, </span>a<span class="markdown"> </span>so<span class="markdown">-called <span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span></span>spurious wakeup<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>.  While this </span>will<span class="markdown"> rarely</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>occur in practice, applications must guard against it by testing for</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span></span>the<span class="markdown"> condition that </span>should<span class="markdown"> have caused </span>the<span class="markdown"> thread to be awakened, and</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>continuing to wait if </span>the<span class="markdown"> condition is not satisfied.  In other words,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>waits </span>should<span class="markdown"> always occur in loops, </span>like<span class="markdown"> this one:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *     </span>synchronized (obj) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *         </span>while (&amp;lt;condition does not hold&amp;gt;)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>obj.wait(timeout);</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *         </span>... // Perform action appropriate to condition</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *     </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>(For </span>more<span class="markdown"> information on this topic, see Section 3.2.3 in Doug Lea's</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>"Concurrent Programming in Java (Second Edition)" (Addison-Wesley,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>2000), or Item 50 in Joshua Bloch's "Effective Java Programming</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>Language Guide" (Addison-Wesley, 2001).</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>If </span>the<span class="markdown"> current thread is &#123;@linkplain java.lang.Thread#interrupt()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>interrupted&#125; by any thread before or while it is waiting, then </span>an</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>&#123;@code InterruptedException&#125; is thrown.  This exception is not</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>thrown until </span>the<span class="markdown"> lock status of this object has been restored as</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>described above.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>Note that </span>the<span class="markdown"> &#123;@code wait&#125; method, as it places </span>the<span class="markdown"> current thread</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>into </span>the<span class="markdown"> wait set for this object, unlocks only this object; any</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>other objects on which </span>the<span class="markdown"> current thread may be synchronized remain</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>locked while </span>the<span class="markdown"> thread waits.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>This method </span>should<span class="markdown"> only be called by </span>a<span class="markdown"> thread that is </span>the<span class="markdown"> owner</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>of this object's monitor. See </span>the<span class="markdown"> &#123;@code notify&#125; method for </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>description of </span>the<span class="markdown"> ways in which </span>a<span class="markdown"> thread can become </span>the<span class="markdown"> owner of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span></span>a<span class="markdown"> monitor.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@param      timeout   </span>the<span class="markdown"> maximum time to wait in milliseconds.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@throws  IllegalArgumentException      if </span>the<span class="markdown"> value of timeout is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *               </span>negative.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@throws  IllegalMonitorStateException  if </span>the<span class="markdown"> current thread is not</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *               </span></span>the<span class="markdown"> owner of </span>the<span class="markdown"> object's monitor.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@throws  InterruptedException if any thread interrupted </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>current thread before or while </span>the<span class="markdown"> current thread</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>was waiting for </span>a<span class="markdown"> notification.  The <span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span></span>interrupted</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>status<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> of </span>the<span class="markdown"> current thread is cleared when</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    *             </span>this exception is thrown.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@see        java.lang.Object#notify()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>@see        java.lang.Object#notifyAll()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">   public <span class="keyword">final</span> native <span class="keyword">void</span> wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>

</details>


<p>可以发现：</p>
<ol>
<li>wait是使当前线程休眠，但是当前线程必须有对象的monitor.这个很容易理解，因为 wait是在对象上的，lock.wait()，所以要执行，线程必须先有这个对象的monitor才可以</li>
<li>线程休眠放入等待集合wait set中，并且释放持有的锁，除非被 notify notifyAll interrupt唤醒或者超时</li>
<li><strong>虚假唤醒(spurious wakeup)问题，所以在使用wait的时候建议在循环中使用</strong></li>
<li>如果被interrupt，则会抛出InterruptedException异常。</li>
</ol>
<h3 id="什么是虚假唤醒"><a href="#什么是虚假唤醒" class="headerlink" title="什么是虚假唤醒"></a>什么是虚假唤醒</h3><p>虚假唤醒的问题，要追溯到linux 底层函数</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Spurious wakeup describes a complication <span class="keyword">in</span> <span class="keyword">the</span> use <span class="keyword">of</span> condition variables <span class="keyword">as</span> provided <span class="keyword">by</span> certain multithreading APIs such <span class="keyword">as</span> POSIX Threads <span class="keyword">and</span> <span class="keyword">the</span> Windows API.</span><br><span class="line"></span><br><span class="line">Even <span class="keyword">after</span> a condition variable appears <span class="keyword">to</span> have been signaled <span class="keyword">from</span> a waiting thread's point <span class="keyword">of</span> view, <span class="keyword">the</span> condition <span class="keyword">that</span> was awaited may still be <span class="literal">false</span>. One <span class="keyword">of</span> <span class="keyword">the</span> reasons <span class="keyword">for</span> this <span class="keyword">is</span> a spurious wakeup; <span class="keyword">that</span> <span class="keyword">is</span>, a thread might be awoken <span class="keyword">from</span> <span class="keyword">its</span> waiting state even though no thread signaled <span class="keyword">the</span> condition variable. For correctness <span class="keyword">it</span> <span class="keyword">is</span> necessary, <span class="keyword">then</span>, <span class="keyword">to</span> verify <span class="keyword">that</span> <span class="keyword">the</span> condition <span class="keyword">is</span> indeed <span class="literal">true</span> <span class="keyword">after</span> <span class="keyword">the</span> thread has finished waiting. Because spurious wakeup can happen repeatedly, this <span class="keyword">is</span> achieved <span class="keyword">by</span> waiting inside a loop <span class="keyword">that</span> terminates when <span class="keyword">the</span> condition <span class="keyword">is</span> <span class="literal">true</span>, <span class="keyword">for</span> example:</span><br></pre></td></tr></table></figure>
<p>向POSIX Threads 和Windows API 中 条件变量判断的时候发生的。<br>一个线程可能即使没有接收到唤醒信号也有可能被唤醒，所以在使用await的时候需要在循环中。</p>
<p>虚假唤醒的原因：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">This means that <span class="keyword">when</span> you <span class="keyword">wait</span> <span class="keyword">on</span> a condition <span class="keyword">variable</span>, the <span class="keyword">wait</span> may (occasionally) <span class="keyword">return</span> <span class="keyword">when</span> no thread specifically broadcast <span class="keyword">or</span> signaled that condition <span class="keyword">variable</span>. Spurious wakeups may sound strange, but <span class="keyword">on</span> some multiprocessor systems, making condition wakeup completely predictable might substantially slow <span class="keyword">all</span> condition <span class="keyword">variable</span> operations. The race conditions that cause spurious wakeups should be considered rare</span><br></pre></td></tr></table></figure>


<p>因为在多处理系统中，如果条件唤醒完全可预测，那么会拖累所有的条件变量操作，拖累性能。并且虚假唤醒的情况是比较函件的所以不进行解决。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="built_in">join</span>() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">join</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">join</span>(<span class="keyword">long</span> <span class="built_in">millis</span>)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = <span class="built_in">millis</span> - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join的作用是等待当前线程结束。利用wait方法，主线程通过调用子线程的wait方法，来阻塞主线程，知道子线程退出实发monitor</p>
<h2 id="suspend-resume（）"><a href="#suspend-resume（）" class="headerlink" title="suspend() / resume（）"></a>suspend() / resume（）</h2><p>两个方法已经废弃：<br>原因：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">This <span class="function"><span class="keyword">method</span> <span class="title">has</span> <span class="title">been</span> <span class="title">deprecated</span>, <span class="title">as</span> <span class="title">it</span> <span class="title">is</span> <span class="title">inherently</span> <span class="title">deadlock</span>-<span class="title">prone</span></span></span><br></pre></td></tr></table></figure>
<p>容易应发死锁</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<h2 id="interrupt-interrupted-isInterrupted"><a href="#interrupt-interrupted-isInterrupted" class="headerlink" title="interrupt/interrupted/isInterrupted"></a>interrupt/interrupted/isInterrupted</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">false</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<p>interrupt用于中断一个线程。</p>
<ol>
<li>interrupt不能中断自己</li>
<li>interrupt可以中断被 wait sleep join 阻塞的线程，被中断的线程会抛出InterruptedException异常。</li>
<li>interrupt可以中断IO InterruptibleChannel  阻塞</li>
<li>interrupt可以中断java.nio.channels.Selector阻塞，会唤醒Selector</li>
</ol>
<p>interrupted 获取当前线程是否被中断，并且会清除中断状态，意味着如果连续调用两次，则后面一次肯定会发挥false.</p>
<p>isInterrupted()与interrupted()的区别是 interrupted不会清除中断状态。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>Thread 包含三个主要元素，name threadGroup target</li>
<li>run是线程要执行的函数，start为启动线程</li>
<li>stop/suspend/resume因为并发问题，已经废弃，不要在使用</li>
<li>setDeamon可以设置是否是守护线程</li>
<li>sleep休眠，但不会释放monitor锁</li>
<li>wait释放monitor锁，notify方法唤醒，会有虚假唤醒的问题，开发的时候需要注意</li>
<li>join等待线程结束</li>
<li>yield() 通知CPU放弃当前执行，是否执行其他取决于CPU调度</li>
<li>中断可以中断wait,sleep,join的线程，isInterrupted 和 interrupted的区别是是否清除中断标志。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程概念</title>
    <url>/post/31afbc55.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>并发在面试中基本可以说是必问的一个点，而线程又是并发得以实现的一个重要的点，线程无疑非常的重要，那么本章就来看看线程的基础知识。</p>
<h1 id="线程、进程、协程"><a href="#线程、进程、协程" class="headerlink" title="线程、进程、协程"></a>线程、进程、协程</h1><p>谈到线程，基本都会谈到进程，那么线程进程有都是些什么呢，都有哪些区别，什么又是协程呢？</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p>线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</strong></p>
<p>线程是比进程更轻量的执行单位，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度。</p>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ol>
<li>使用内核线程实现 1:1</li>
<li>使用用户线程实现 1:n</li>
<li>使用用户线程加轻量级进程实现 n:m</li>
</ol>
<p><strong><em>内核线程</em></strong></p>
<p>内核线程（KLT kernel-level thread）是由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器来对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核.</p>
<p><strong><em>轻量级进程(LWP):</em></strong></p>
<p>轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作.首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（UserMode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的</p>
<p>内核线程实现：<br><img src="../resource/java/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.jpg" alt=""></p>
<p>linux 采用的是内核线程的实现方式</p>
<p><strong><em>用户线程:</em></strong></p>
<p>广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程（User Thread，UT）的一种，而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</p>
<p>用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的</p>
<p>用户线程的实现方式</p>
<p><img src="../resource/java/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B.jpg" alt=""></p>
<p>混合线程实现方式：<br><img src="../resource/java/%E6%B7%B7%E5%90%88%E7%BA%BF%E7%A8%8B.jpg" alt=""></p>
<h3 id="java-线程的实现"><a href="#java-线程的实现" class="headerlink" title="java 线程的实现"></a>java 线程的实现</h3><p>JDK1.3开始，主流java虚拟机线程模型都是基于操作系统原生线程模型来实现的，也就是采用的是 1:1的内核线程模型。</p>
<p>例如 HotSpot ，他的每一个java线程都是直接映射到一个操作系统原生线程来实现的，   中间没有额外的间接结构，所以调度全权交由操作系统来决定，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</p>
<h3 id="java-线程的调度"><a href="#java-线程的调度" class="headerlink" title="java 线程的调度"></a>java 线程的调度</h3><ol>
<li>协同式线程调度</li>
<li>抢占式线程调度</li>
</ol>
<p><strong><em>协同式线程调度：</em></strong>线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去</p>
<p><strong><em>抢占式线程调度：</em></strong>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定</p>
<p><strong>Java使用的线程调度方式就是抢占式调度</strong></p>
<h3 id="线程的状态："><a href="#线程的状态：" class="headerlink" title="线程的状态："></a>线程的状态：</h3><p><img src="../resource/java/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt=""></p>
<h3 id="java线程的创建"><a href="#java线程的创建" class="headerlink" title="java线程的创建"></a>java线程的创建</h3><ol>
<li>继承自Thread</li>
<li>实现Runnable</li>
<li>使用Callable和Future</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">"hellow_world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过Runnable创建的线程!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"通过Callable创建的线程!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Callable&lt;String&gt; callable = new MyThread();</span></span><br><span class="line"><span class="comment">//FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(callable);</span></span><br><span class="line"><span class="comment">//new Thread(ft,"threadName").start();</span></span><br></pre></td></tr></table></figure>


<h2 id="协程-纤程-fiber-light-thread"><a href="#协程-纤程-fiber-light-thread" class="headerlink" title="协程(纤程) fiber light-thread"></a>协程(纤程) fiber light-thread</h2><h3 id="为什么需要协程"><a href="#为什么需要协程" class="headerlink" title="为什么需要协程"></a>为什么需要协程</h3><p>前面我们说了，java线程是1：1的内核线程的实现方式，调度方式也是抢占式调度。</p>
<p>但是操作系统的线程实现方式是为了通用性，其需要支持所有类型的并发操作。故而其线程的切换需要进行线程上下文的切换操作，对于一些IO密集型操作，其线程上下文的切换开销也是比较大的，因为线程切换需要响应系统中断，进行保存和恢复现场。</p>
<p>也就出现了协程（coroutine）.</p>
<h3 id="java的实现"><a href="#java的实现" class="headerlink" title="java的实现"></a>java的实现</h3><p>java对于协程的实现方式是 纤程(Fiber)，或者是 light weight thread。</p>
<p>light weight thread 的实现方式是在底层1:1内核线程的基础上，进行封装了轻量级线程的方式来实现，</p>
<p><img src="../resource/java/lightWeightThread.jpg" alt=""></p>
<p>黄色的部分表示的就是新的并发方式 light weight thread。 多个light weight thread 可以共用一个内核级线程</p>
<p>light weight thread 由两部分构成 </p>
<ol>
<li>Continuation  执行过程</li>
<li>Scheduler     调度器</li>
</ol>
<p>执行过程负责维护现场，调度器负责编排所有要执行的代码的执行顺序。<br>其示例如下图:</p>
<p><img src="../resource/java/Fiber%E7%A4%BA%E4%BE%8B.jpeg" alt=""></p>
<h3 id="协程为什么开销小"><a href="#协程为什么开销小" class="headerlink" title="协程为什么开销小"></a>协程为什么开销小</h3><p>要解释这个问题，我们首先要解释什么场景适合使用协程：</p>
<ol>
<li>协程将保存、恢复现场，和调度的工作从操作系统手中拿过来，那么对于一些IO密级性场景，就可以通过简单的先进先出的调度，使用完全无锁调度，调度开销变会减少。</li>
<li>协程更加的轻量，64位Linux上HotSpot的线程栈容量默认是1MB，而一个协程的栈通常在几百个字节到几KB之间。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>java目前都是基于1：1的内核线程实现抢占式调度的线程，该线程的上下文切换，调度等均交由操作系统来进行，而线程阻塞唤醒的调度，很消耗时间。于是便出现了fiber 纤程，在调度以及栈大小上进行优化，目前fibers项目是 project Loom 。 该特性预计会加入的到JVM的原生支持，并且JDK对外的api接口都会进行适配，希望JDK13的时候有望见到。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>&lt;深入理解java虚拟机&gt;</p>
</blockquote>
<blockquote>
<p><a href="https://www.youtube.com/watch?spm=ata.13261165.0.0.7e8d73b6UFWQzK&v=lIq-x_iI-kc" target="_blank" rel="noopener">light weight thread相关介绍</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发理论</title>
    <url>/post/ab0f6be5.html</url>
    <content><![CDATA[<h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p>当我们去网上搜索并发的时候，总是能看到并行，并发并行这两个概念似乎总是不分家。那么我们来看看并发并行都有些什么区别：</p>
<blockquote>
<p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.</p>
</blockquote>
<blockquote>
<p>When an application is capable of executing two tasks virtually at same time, we call it concurrent application.Though here tasks run looks like simultaneously, but essentially they MAY not</p>
</blockquote>
<blockquote>
<p>Parallelism does not require two tasks to exist. It literally physically run parts of tasks OR multiple tasks, at the same time using multi-core infrastructure of CPU, by assigning one core to each task or sub-task.<br>Parallelism requires hardware with multiple processing units, essentially. In single core CPU, you may get concurrency but NOT parallelism.</p>
</blockquote>
<p>百度是这样描述并发的<br>:在操作系统中，并发是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
<p>并行:<br>在操作系统中是指，一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生)</p>
<p>通过上面的描述，其实是可以有一些感觉建立的：</p>
<ol>
<li>并发是对于单cpu上多任务的场景来描述的，并发利用不同的CPU时间片，逻辑上是同时执行多项任务，事实的可能是多任务穿插在不同时间片上顺序执行</li>
<li>并行是有多个cpu核心，不同的任务可以在同一刻同时执行。</li>
<li>实际上对于多核cpu来说，现在的多线程也都是并行执行的。</li>
</ol>
<p><img src="../resource/java/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C.jpg" alt=""></p>
<h1 id="三大特性："><a href="#三大特性：" class="headerlink" title="三大特性："></a>三大特性：</h1><ol>
<li>原子性</li>
<li>可见性</li>
<li>顺序行</li>
</ol>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性指的是一个或者多个操作在CPU执行过程中不被中断的特性。即要不全部执行完成，要不不执行。</p>
<p>a++操作：</p>
<ol>
<li>加载a</li>
<li>+1</li>
<li>结果写入内存，赋值a</li>
</ol>
<p>a=0,如果两个线程同时执行 a++。 我们期望输出2，但是实际上<br><img src="../resource/java/%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98.jpg" alt=""><br>可能得到的结果是 1。 这便是原子性问题</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性指的是当一个线程修改了共享变量后，其他线程能够立即得到修改的值。</p>
<p>线程 1，2 共享同一个变量a, 如果1修改了2看不见，便会导致a变量值的不可预测性。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性指的是程序执行的顺序按照代码的先后顺序执行。</p>
<p>一般来说，处理器为了提高程序的的运行效率，可能会对输入代码进行优化，它不保证程序中各个操作语句的执行先后数据同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行结果的一致性。</p>
<p>如果处理器指令经过重排，单线程下指令重排会保证结果一致性，但是多线程情况下指令重排由于共享变量的存在，可能导致不可预测的结果。</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>了解完并发的基本概念，以及三大特性，我们来看看内存模型，为什么要了解系统的内存模型呢，因为并发的操作，在单核系统上实际上是多个任务穿插执行，多核系统上可能是多个cpu核心同时并行执行多任务。那么了解系统的内存模型，了解cpu，内存的交互就显得至关重要。</p>
<p>我们知道经典的冯洛伊曼体系结构如下：<br><img src="../resource/java/%E5%86%AF%E6%B4%9B%E4%BC%8A%E6%9B%BC%E4%BD%93%E7%B3%BB.png" alt=""></p>
<p>但是又由于存储器(主存)与处理器（CPU）之前的运算速度相差巨大（指数级）,故而，为了解决主存带来的耗时问题，引入了高速缓存。结构如下所示：<br><img src="../resource/java/systemMomery.jpg" alt=""></p>
<h2 id="总线锁定"><a href="#总线锁定" class="headerlink" title="总线锁定"></a>总线锁定</h2><p>现代计算机一般都是多CPU，那么多CPU核心对于主内存中同一个区域的访问就会存在冲突的问题，也就引发了原子性，可见性，一致性等多个问题，那么是如何解决的呢？</p>
<p><strong><em>总线锁:</em></strong>就是使用处理器提供的一个LOCK#信号，当一个处理器总线上输出此信号时，其它处理器的请求将被阻塞住，那么该处理器可以独占共享内存。如此多CPU的操作就变成了单cpu操作，也就没有并发问题了。</p>
<h2 id="缓存锁定和缓存一致性"><a href="#缓存锁定和缓存一致性" class="headerlink" title="缓存锁定和缓存一致性"></a>缓存锁定和缓存一致性</h2><p>由于，我们只需要保证对某个内存地址的操作是原子的即可，但是总线锁把CPU和内存之间的通信锁住了，这使得在锁定期间，其他处理器也不能操作其他内存地址的数据，所以总线锁的开销比较大。目前，处理器在某些场合下使用缓存锁来代替总线索进行优化。</p>
<p><strong><em>缓存锁</em></strong>就是指内存区域如果被缓存在处理器的缓存行中，并且在LOCK#操作期间，那么当它执行操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，其他处理器回写已被锁定的缓存行的数据时，就会使缓存无效。</p>
<h3 id="缓存一致性-MESI"><a href="#缓存一致性-MESI" class="headerlink" title="缓存一致性 MESI"></a>缓存一致性 MESI</h3><p>MESI协议(Modified,Exclusive,Share,Invlid) 用四种标志来区分缓存数据的状态，以此来决定CPU何时把缓存的数据写入到内存，何时从缓存读取数据，何时从内存读取数据。</p>
<p><strong>Modified(修改状态)</strong>:<br>当前缓存数据是有效的,数据还未同步到内存中去,通知其他缓存设置为Invlid</p>
<p><strong>Exclusive(独占状态)</strong>:<br>当前缓存有效，并且只在当前缓存有，数据与内存一致</p>
<p><strong>Share(共享状态)</strong>:<br>所有缓存公有，数据与内存一直</p>
<p><strong>Invalid(无效状态)</strong>:<br>当前缓存无效。</p>
<p>只有当缓存段处于E或M状态时，处理器才能去写它，也就是说只有这两种状态下，处理器是独占这个缓存段的。当处理器想写某个缓存段时，如果它没有独占权，它必须先发送一条“我要独占权”的请求给总线，这会通知其他处理器，把它们拥有的同一缓存段的拷贝失效（如果它们有的话）。只有在获得独占权后，处理器才能开始修改数据——并且此时，这个处理器知道，这个缓存段只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。反之，如果有其他处理器想读取这个缓存段（我们马上能知道，因为我们一直在窥探总线），独占或已修改的缓存段必须先回到“共享”状态。如果是已修改的缓存段，那么还要先把内容回写到内存中。</p>
<p><img src="../resource/java/%E7%8B%AC%E5%8D%A0%E6%B5%81%E7%A8%8B.jpg" alt=""></p>
<p>如上图所示，可以发现，在CPU1失效缓存到CPU0可以修改之间，CPU0只能处于等待状态，这就比较浪费性能了。</p>
<p><strong><em>Store Bufferes和Invalidate Queues</em></strong></p>
<p>基于缓存一致性模型，提出了Store Bufferes 存储缓存的概念。</p>
<p><strong>Store Bufferes 缓存存储</strong>，当处理器需要把修改写入缓存时，然后在写入内存这个过程时，我们处理器不需要等待了。只需要把指数据写入Store Bufferes，然后发生Invalidate消息给其它CPU，然后本CPU就可以去执行其它指令了，等到我们都收所有回复确认Invalidate Acknowledge消息，在把Store Bufferes消息写回缓存修改状态为（M），如果有其它CPU来读，就会刷新到内存，状态变为S。Store Bufferes 的作用是让 CPU 需要写的时候仅仅将其操作交给 Store Buffere，然后继续执行下去，Store Bufferes 在某个时刻就会完成一系列的同步行为。</p>
<p>Store Bufferes 存储缓存 解放了CPU的等待时间，但是如果CPU同时处理的事情比较多，需要失效的缓存数据比较多，那么久会非常占用空间，于是设计出了Invalidate Queues</p>
<p><strong>Invalidate Queues 失效队列：</strong>当别的CPU收到Invalidate消息时，把这个操作加入无效队列，然后快速返回Invalidate Acknowledge消息，让发起者做后续操作，然后Invalidate并不是马上处理，而只是加入了队列，也就是说其实不是立刻让本CPU的缓存数据失效，而是等CPU处理无效队列里的无效消息时。</p>
<p>Store Bufferes和Invalidate Queues 分别从解放本次CPU等待时间，异步话对侧失效操作两个方面对缓存一致性模型进行了优化，也就成为了下面的结构：</p>
<p><img src="../resource/java/%E7%BC%93%E5%AD%98%E9%98%9F%E5%88%97%E5%92%8C%E5%A4%B1%E6%95%88%E9%98%9F%E5%88%97.jpg" alt=""></p>
<p><strong><em>可见性问题：</em></strong></p>
<p>由于Store Buffers和Invalidate Queues的引入，导致CPU的操作变成了最终一致性，而这种最终一致性。而这种最终一致性，会导致在多核处理中，对于有依赖关系的变量修改就变的不可见了：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> foo(<span class="built_in">void</span>)&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> bar(<span class="built_in">void</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU0运行foo，CPU1运行bar。假设序列如下 ：假设cpu1之前运行过其他指令，有a的缓存，无b的缓存</p>
<ol>
<li>CPU0 要修改a ，写入Store Buffer 通知总线要独占，CPU1收到，放入Invalidate queue ,返回确认，CPU0把Store Buffer 内容写入缓存0。</li>
<li>CPU0 要修改b， cpu独占b，直接写入。改为M</li>
<li>CPU1 读取b，此时CPU0监听到，修改为S 回写内存，b==0循环结束</li>
<li>CPU1读取缓存，由于已经有缓存了，但是其缓存队列 Invalidate queue中在等待执行，其顺序没法保证，如果已经失效，能读取到 a=1 如果还没失效，那就是之前缓存中的值。</li>
</ol>
<p>也就失去了修改的可见性。</p>
<p>为了解决这个问题，底层增加了一个内存屏障（memory barrier）的指令：</p>
<p>Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，应用所有已经在存储缓存（store buffer）中的保存的指令。<br>Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先应用所有已经在失效队列中的失效操作的指令</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> foo(<span class="built_in">void</span>)&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_wmb()</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> bar(<span class="built_in">void</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    smp_rmb()</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，之前不走中的4中的问题就不在存在了，因为其a在写入之后，立刻就会执行刷新到缓存，assert(a==1)执行前，会先吧失效队列中的指令执行完毕</p>
<h2 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h2><p>系统内存模型，通过总线锁，缓存锁和缓存一致性协议来保证并发的可靠，那么java内存模型又是怎么做的呢</p>
<p><strong>由于java是跨平台的语言，所以java需要解决不同平台不同操作系统的内存访问的差异，以让java程序在各个平台下都能达到一致的访问效果。故而java需要定义一套模型，让java的并发内存访问操作不会产生歧义。</strong></p>
<p>而java内存模型就是这样的产物。java内存模型主要定义了各种变量的访问规则。其规定所有变量都必须存储在主内存(此处表示虚拟机内存的一部分）中每条线程有自己的工作内存，保存该线程使用变量的工作副本。线程对变量的所有操作都必须在工作内存中完成。如下图所示：</p>
<p><img src="../resource/java/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt=""></p>
<p>当一个线程进行更新的时候会通过线程间通信，让另一个线程从主内存中获取数据:<br><img src="../resource/java/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.jpg" alt=""></p>
<p>我们知道JMM java内存，对于是对于内存模型的抽象话管理，基础的操作都是操作系统调用去完成，故而原子性等特性都遵从于操作系统的指令级原子性，或者有更多的封装。</p>
<p>但是由于编译优化，指令级重排序等问题，会保证程序执行的顺序最终一致，对于单线程来说，没有问题，但是多线程会造成可见性，顺序性问题。</p>
<h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p><strong>java 定义了8种原子性操作</strong></p>
<ol>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。<br>并且 read&amp;load 成对出现， store&amp;write成对出现，以及一些列规则来保证基本的读取和写入的原子性。</li>
</ol>
<h3 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h3><p>java中通过定义了 volatile 关键字，来保证变量新值能立即刷新到主内存中，以及每次使用都从主内存中刷新来保证。</p>
<p>也通过 锁 synchronized 和 final 关键字 来实现。</p>
<h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>java通过定义了happen-before原则来保证有序性。通过该原则我们数据是否存在竞争，线程是否安全。</p>
<ol>
<li><strong>程序次序原则</strong>：在一个线程内，按照控制流，书写在前面的要先于后面的</li>
<li><strong>管程锁定原则</strong>：一个unlock操作先于后面对同一个锁的lock</li>
<li><strong>volatile原则</strong>：对一个volatile变量的写先于后面对这个变量的读</li>
<li><strong>线程启动原则</strong>：Thread的start()先于这个线程的所有操作</li>
<li><strong>线程终止原则</strong>：线程中所有操作都先于线程终止操作   </li>
<li><strong>线程终端原则</strong>：interrupt调用先于被中断代码检测到中断时间</li>
<li><strong>对象终结原则</strong>：对象的初始化完成先于finalize（）的开始</li>
<li><strong>传递性</strong>： a先于b  b先于c 则a先于c</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>本文首先了解了并发和并行的基本概念，然后分别通过系统内存模型，和java内存模型了解了系统内存已经java内存对于并发三大特性的处理。</p>
<p>内存模型 通过总线锁 缓存锁 缓存一致性协议 内存屏障来保障并发的可靠性</p>
<p>java内存模型通过 基础原子性操作  volatile 锁  happen-before原则来保证并发的可靠性</p>
<br/>
<br/>
<br/>
<br/>


<blockquote>
<p><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf" target="_blank" rel="noopener">http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf</a><br><a href="https://blog.51cto.com/14220760/2370118?source=dra" target="_blank" rel="noopener">https://blog.51cto.com/14220760/2370118?source=dra</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发综述</title>
    <url>/post/ebfd7e71.html</url>
    <content><![CDATA[<p><img src="../resource/java/%E5%B9%B6%E5%8F%91.png" alt=""></p>
]]></content>
      <categories>
        <category>java</category>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码分析</title>
    <url>/post/e74dcc0a.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>分析完成了ArrayList和HashMap两个最常用的结构，我们来看看去重集合HashSet的实现方式和源码。</p>
<h1 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a>HashSet源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">HashMap</span>&lt;E,<span class="keyword">Object</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> PRESENT = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;(Math.<span class="built_in">max</span>((<span class="built_in">int</span>) (c.<span class="built_in">size</span>()/<span class="number">.75</span>f) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 HashSet是在内部维护了一个HashMap的对象，而HashMap的数据结构我们之前就有所了解：</p>
<p><img src="../resource/java/HashMap%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数:"></a>重要函数:</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">put</span>(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong>add方法主要利用了HashMap的key不重复的特性</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">remove</span>(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong>remove也是直接调用hashmap的remove方法</p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong>iterator主要复用了HashMap的keySet的遍历方法。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>HashMap源码分析完毕之后，HashSet可以说非常简单，因为HashSet的实现是复用了HashMap的基本特性来实现的，从这里也可以看出来 HashMap对于javaer是多么的重要。 LinkedHashMap 继承自 HashMap实现排序用于lru算法，HashSet利用与HashMap的组合，实现去重集合。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap源码分析</title>
    <url>/post/19c86886.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TreeMap从字面上来说就跟树脱不了干系，既然TreeMap支持排序，那么基本就是二叉树的扩展。接下来就来看看TreeMap的使用，以及内部基础结构。</p>
<h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1    1</span></span><br><span class="line"><span class="comment">        2    1</span></span><br><span class="line"><span class="comment">        3    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">map</span>.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(key +<span class="string">"    "</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; map2 = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> compare(<span class="keyword">String</span> o1, <span class="keyword">String</span> o2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(o2) -<span class="keyword">new</span> Integer(o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3    1</span></span><br><span class="line"><span class="comment">        2    1</span></span><br><span class="line"><span class="comment">        1    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    map2.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(key +<span class="string">"    "</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由实例可以知道，TreeMap是有序的hash表结构，并且支持自定义比较器Comparator进行自定义排序方式。</p>
<h1 id="TreeMap源码分析"><a href="#TreeMap源码分析" class="headerlink" title="TreeMap源码分析"></a>TreeMap源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? super K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> transient <span class="built_in">Entry</span>&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> transient <span class="built_in">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="keyword">class</span> <span class="built_in">Entry</span>&lt;K,V&gt; implements Map.<span class="built_in">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V <span class="keyword">value</span>;</span><br><span class="line">    <span class="built_in">Entry</span>&lt;K,V&gt; left;</span><br><span class="line">    <span class="built_in">Entry</span>&lt;K,V&gt; right;</span><br><span class="line">    <span class="built_in">Entry</span>&lt;K,V&gt; parent;</span><br><span class="line">    boolean color = BLACK;</span><br><span class="line">    <span class="built_in">Entry</span>(K key, V <span class="keyword">value</span>, <span class="built_in">Entry</span>&lt;K,V&gt; parent) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，可以看出来TreeMap的结构是一颗二叉树，root表示根节点，有左子树left,右子树right，父节点parent。熟悉数据结构则可以明白color=BLACK 表示这颗树是一颗红黑树。</p>
<p><img src="../resource/java/TreeMapTree.jpg" alt=""></p>
<p>红黑树的基础知识可以通过 <a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底了解红黑树</a> 进行了解</p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">//设置根节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//此处进行类型检查</span></span><br><span class="line">        compare(<span class="built_in">key</span>, <span class="built_in">key</span>); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(<span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">//cpr 不等于null，使用cpr定义的比较器</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(<span class="built_in">key</span>, t.<span class="built_in">key</span>);</span><br><span class="line">            <span class="comment">//小于放在左子树 ，否则放在右子树</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有定义比较器，则使用默认的比较器 此处进行null检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="built_in">key</span>;</span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="comment">// 循环遍历 小于放在左子树 大于放在又子树</span></span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.<span class="built_in">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到需要放的位置 设置几点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(<span class="built_in">key</span>, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">// 放置完成后进行红黑树的调整。 红黑树调整此处不做介绍。可以去看数据结构的红黑树的介绍</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>TreeMap进行插入数据节点的时候，会进行类型检查和空指针检查</li>
<li>如果未定义比较方法，会使用默认的比较方法</li>
<li>与而插入插入一直，如果小于则查找左子树，如果大于则查找右子树</li>
<li>节点插入树中后会进行红黑树的平衡调整。</li>
</ol>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">       <span class="comment">//使用自定义的比较器获取值</span></span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(<span class="built_in">key</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认比较器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="built_in">key</span>;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">//遍历 二叉树查找过程，小于当前节点找左子树，大于当前节点找右子树</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> cmp = k.compareTo(p.<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义比较器比较</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntryUsingComparator(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        K k = (K) <span class="built_in">key</span>;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历 二叉树查找过程，小于当前节点找左子树，大于当前节点找右子树</span></span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> cmp = cpr.compare(k, p.<span class="built_in">key</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>说明:</strong> 获取key对应的元素相对来说比较简单，就是二叉查找树的查找过程，如果小于当前节点则找左子树，大于当前节点找右子树。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V remove(Object key) &#123;</span><br><span class="line">    <span class="comment">// 找到当前节点</span></span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="built_in">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="literal">void</span> deleteEntry(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class="line">    <span class="comment">// point to successor.</span></span><br><span class="line">    <span class="comment">//左右子节点都为null 则找后继节点与p交换</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="built_in">null</span> &amp;&amp; p.right != <span class="built_in">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有子树，则子树需要与父节点关联</span></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="built_in">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="built_in">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除掉p，链接p的parent 和子树</span></span><br><span class="line">        <span class="comment">// Link replacement to parent</span></span><br><span class="line">        replacement.<span class="keyword">parent</span> = p.<span class="keyword">parent</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="keyword">parent</span> == <span class="built_in">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.left)</span><br><span class="line">            p.<span class="keyword">parent</span>.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.<span class="keyword">parent</span>.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.<span class="keyword">parent</span> = <span class="built_in">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">        <span class="comment">// 红黑树调整</span></span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.<span class="keyword">parent</span> == <span class="built_in">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">        root = <span class="built_in">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="keyword">parent</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.left)</span><br><span class="line">                p.<span class="keyword">parent</span>.left = <span class="built_in">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.right)</span><br><span class="line">                p.<span class="keyword">parent</span>.right = <span class="built_in">null</span>;</span><br><span class="line">            p.<span class="keyword">parent</span> = <span class="built_in">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the successor of the specified Entry, or null if no such.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 找二叉查找树t后继节点</span></span><br><span class="line">static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="built_in">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">    <span class="comment">//找右子树的最小值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="built_in">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="built_in">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.<span class="keyword">parent</span>;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="comment">// 如果t右子树是空并且其是父节点右节点，找这颗右子树的根节点。</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="built_in">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.<span class="keyword">parent</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>删除的操作较为复杂，由于删除操作会进行树的修正，和红黑树的平衡调整，均为红黑树的基本操作，可以通过数据结构红黑树章节来了解。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>红黑树的使用起来比较简单，内部实现说简单也简单，复杂也复杂，主要复杂的点在红黑树的数据结构维护上，排除红黑树的维护操作，TreeMap的结构相对来说比较简单，其主要是利用二叉查找树的特性，通过比较函数来维护一颗二叉查找树，通过二叉查找树来进行排序。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap源码分析</title>
    <url>/post/75655826.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>LinkedHashMap是一种可以有序访问的hash表，其可以按照<strong>插入顺序</strong>或者<strong>访问顺序</strong> 进行排序输出。具体如下，LinkedHashMap按照顺序放入了key为1，2，3的数据，然后遍历输出。插入顺序输出1，2，3.访问顺序会将按照访问次序倒排输出，最近访问的放在最后。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1    1</span></span><br><span class="line"><span class="comment">        2    1</span></span><br><span class="line"><span class="comment">        3    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">map</span>.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(key +<span class="string">"    "</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; map2 = <span class="keyword">new</span> LinkedHashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;(<span class="number">16</span>,<span class="number">0.75</span>,<span class="literal">true</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">put</span>(<span class="string">"3"</span>,<span class="string">"1"</span>);</span><br><span class="line">    map2.<span class="built_in">get</span>(<span class="string">"2"</span>);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1    1</span></span><br><span class="line"><span class="comment">        3    1</span></span><br><span class="line"><span class="comment">        2    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">map</span>.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(key +<span class="string">"    "</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>那么这种结构有什么作用呢？最近使用的放到最后，我们可以很容易的想到一个东西就是LRU,最近最少使用淘汰算法.LinkedListHashMap的按照访问顺序排序的特点刚好符合LRU所需。那么就可以使用LinkedHashMap来实现一个本地的LRU算法。</p>
<h1 id="LinkedHashMap源码分析"><a href="#LinkedHashMap源码分析" class="headerlink" title="LinkedHashMap源码分析"></a>LinkedHashMap源码分析</h1><h2 id="数据结构是一起的基础"><a href="#数据结构是一起的基础" class="headerlink" title="数据结构是一起的基础"></a>数据结构是一起的基础</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap&lt;K</span>,<span class="title">V&gt;</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap&lt;K</span>,<span class="title">V&gt;</span></span></span><br><span class="line"><span class="class">    <span class="title">implements</span> <span class="title">Map&lt;K</span>,<span class="title">V&gt;</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; before, after;</span><br><span class="line">    <span class="type">Entry</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> value, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，LinkedHashMap继承自HashMap,基本机构相同，只是Node节点进行了扩展，增加了before,after指针构建一个双向链表。</p>
<p><img src="../resource/java/LinkedHashMap.jpg" alt=""></p>
<p>其在hashMap的结构基础上增加了用于排序使用的双向链表。故而其基本结构为 数组+链表+红黑树+双向链表</p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><p>不知你是否注意过，在我们进行hashMap源码分析的时候，在putVal,replace，merge等方法的时候，经常出现两个方法 afterNodeAccess和afterNodeInsertion方法，在remove的时候调用了afterNodeRemoval方法，而这三个方法便是实现LinkedHashMap顺序的基础。<br><img src="../resource/java/hashMapAfterAccess.jpg" alt=""></p>
<h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess"></a>afterNodeAccess</h3><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    //只有按照访问顺序排序的时候才更新顺序</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (<span class="attr">last</span> = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; <span class="attr">p</span> =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="attr">b</span> = p.before, <span class="attr">a</span> = p.after;</span><br><span class="line">        //将e的后续设置为<span class="literal">null</span></span><br><span class="line">        p.<span class="attr">after</span> = <span class="literal">null</span>;</span><br><span class="line">        //下面的ifelse相当于解除e的前后关系</span><br><span class="line">        //如果前序节点为<span class="literal">null</span>则设置其为首节点</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">b</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">head</span> = a;</span><br><span class="line">        //否则e的前序节点的后续设置为e原本的后续</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.<span class="attr">after</span> = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.<span class="attr">before</span> = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="attr">last</span> = b;</span><br><span class="line">        //last为<span class="literal">null</span>的话 设置last为p 否则吧原最后节点设置为p</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">last</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">head</span> = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.<span class="attr">before</span> = last;</span><br><span class="line">            last.<span class="attr">after</span> = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">tail</span> = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/AccessChange.jpg" alt=""></p>
<h3 id="afterNodeRemoval"><a href="#afterNodeRemoval" class="headerlink" title="afterNodeRemoval"></a>afterNodeRemoval</h3><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; <span class="attr">p</span> =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, <span class="attr">b</span> = p.before, <span class="attr">a</span> = p.after;</span><br><span class="line">    //删除e的前后指针</span><br><span class="line">    p.<span class="attr">before</span> = p.<span class="attr">after</span> = <span class="literal">null</span>;</span><br><span class="line">    //重新设置指向e的指正</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">b</span> == <span class="literal">null</span>)</span><br><span class="line">        <span class="attr">head</span> = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.<span class="attr">after</span> = a;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">a</span> == <span class="literal">null</span>)</span><br><span class="line">        <span class="attr">tail</span> = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.<span class="attr">before</span> = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion"></a>afterNodeInsertion</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly <span class="built_in">remove</span> eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; <span class="built_in">first</span>;</span><br><span class="line">    //removeEldestEntry 默认<span class="literal">false</span> </span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (<span class="built_in">first</span> = head) != null &amp;&amp; removeEldestEntry(<span class="built_in">first</span>)) &#123;</span><br><span class="line">        K <span class="built_in">key</span> = <span class="built_in">first</span>.<span class="built_in">key</span>;</span><br><span class="line">        removeNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, null, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>该函数为LRU提供了基础函数支持，hashMap在put的时候会调用afterNodeInsertion，如果removeEldestEntry返回true，则在put的时候会删除最老的节点。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>如果是按照访问顺序则get获取之后需要调用afterNodeAccess进行顺序更新。</p>
<h3 id="newNode-amp-LinkedNodeLast"><a href="#newNode-amp-LinkedNodeLast" class="headerlink" title="newNode&amp;LinkedNodeLast"></a>newNode&amp;LinkedNodeLast</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Node&lt;K,V&gt; <span class="keyword">new</span><span class="constructor">Node(<span class="params">int</span> <span class="params">hash</span>, K <span class="params">key</span>, V <span class="params">value</span>, Node&lt;K,V&gt; <span class="params">e</span>)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    link<span class="constructor">NodeLast(<span class="params">p</span>)</span>;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> void link<span class="constructor">NodeLast(LinkedHashMap.Entry&lt;K,V&gt; <span class="params">p</span>)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last<span class="operator"> == </span>null)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>LinkedHashMap重写了hashMap的newNode方法，在创建新的节点的时候，会将节点的before和after指针与tail节点关联上。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>LinkedHashMap 集成自HashMap，基础操作与HashMap相同，LinkedHashMap的实现得益于HashMap在基础操作中的埋点。也就是：afterNodeAccess，afterNodeInsertion和afterNodeRemoval方法。最简单的LUR只需要继承自LinkedListHashMap，重写removeEldestEntry即可。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/post/9749aebd.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>实话说，HashMap作为集合中比较经典的一个类，其在面试中经常会被问到：例如</p>
<ol>
<li>说说HashMap的原理(o(╥﹏╥)o真nm笼统)</li>
<li>HashMap是怎么扩容的呢？</li>
<li>传统HashMap(jdk1.7)的hashMap有什么缺点，如何对其进行优化呢(红黑树)？</li>
<li>那么又了解在实际情况下会进化到红黑树的比例吗？</li>
<li>HashMap是线程安全的吗？不是应该用啥呢….巴拉巴拉 能接一串问题。</li>
</ol>
<p>瞬间就有了继续下去的动力了，💰💰💰💰</p>
<h2 id="为啥需要HashMap呢？"><a href="#为啥需要HashMap呢？" class="headerlink" title="为啥需要HashMap呢？"></a>为啥需要HashMap呢？</h2><p>前面分析了线性表的两种典型结构，ArrayList随机访问线性表，LinkedList顺序访问线性表。但是其都一个缺陷，就是如果需要获取一个对象（比如找叫小波的给我两块钱），那么我就需要遍历这个线性表，先找到这个张三，然后在从他兜里偷两块钱，其时间复杂度无疑是O(n)的</p>
<p>这种情况就需要哈希表出马了，所谓的哈希表，就是k-v结构，例子中k就是小波的名字，v就是小波，那么我找小波就可以通过这种kv结构在O(1)d时间下获取到小波了。性能无疑是非常优越的。</p>
<h2 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h2><p>所谓的哈希表，就是将一个对象，通过一个函数计算出来了这个对象应该在数组中元素的位置那么我们就可以通过数组在O(1)时间复杂度内获取这个对象。而这个函数就是所谓的哈希函数，这个数组和哈希函数整体构成了哈希表的基础组成。</p>
<p><img src="../resource/java/%E5%93%88%E5%B8%8C%E8%A1%A8.jpg" alt=""></p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>什么是hash冲突呢?<br>哈希函数是哈希表中的一个重要组成，但是字符串是无穷的，很难说有一个hash函数生成的key与一个对象能够一对一关联上，也就是说，可能出现两个不同的对象生成同一个key的情况，这就是hash冲突。有了问题就要解决问题，那么如何解决hash冲突呢：</p>
<ol>
<li>开放地址法。冲突了就继续下一个</li>
<li>在hash，冲突了就运行二次hash</li>
<li>拉链法，冲突了就在数组的那个位置在拉个链表出来。</li>
</ol>
<p><img src="../resource/java/hash%E5%86%B2%E7%AA%81.jpg" alt=""></p>
<h1 id="hashMap源码分析"><a href="#hashMap源码分析" class="headerlink" title="hashMap源码分析"></a>hashMap源码分析</h1><p>说完哈希表这种数据结构，以及hash冲突的解决办法。我们来看看HashMap的实现。</p>
<h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"><span class="comment">// 单个元素结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> Node&lt;K,V&gt; <span class="keyword">implements</span> Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// hash值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="keyword">next</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述源码中，我们可以发现，hashMap底层是有数组来做基础支撑，与我们前面说的哈希表一致。hashMap中含有下一个节点的指针，采用的是拉链法解决冲突。基础结构如下图左侧所示：</p>
<p><img src="../resource/java/HashMap%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>左侧便是jdk1.7的结构，有图是jdk1.8进行的优化，增加了红黑树的结构。</p>
<h2 id="增删改查基础操作"><a href="#增删改查基础操作" class="headerlink" title="增删改查基础操作"></a>增删改查基础操作</h2><h3 id="查询-get"><a href="#查询-get" class="headerlink" title="查询 get()"></a>查询 get()</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> h;</span><br><span class="line">    <span class="comment">//key==null 则直接取0，否则hash()取key的hashCode 和 key的hashCode右移16位取异或。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取k = key的 节点</span></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//先hash key 然后通过hash值去获取</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="built_in">int</span> hash, <span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">//拿hash 与数组长度 n-1 取与操作得到的值 就是索引</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="built_in">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果tab[index]的第一个节点hash值相等，并且equals或者为同一个对象，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//如果有下一个节点 则继续向下一个节点找hash or equals的，知道找到或者未找到。</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="built_in">key</span>);</span><br><span class="line">            do &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hash()哈数</strong><br><img src="../resource/java/hashIndex.jpg" alt=""></p>
<p>hash函数的获取方式: 通过key获取key的hashCode。高16位保持不变，低16位于高16位异或的结果作为低16位。</p>
<p><strong>index获取</strong></p>
<p>index是又hash()值与数组大小n-1做 &amp; and运算的结果。为什么这样操作。 首先，这里给出一个信息 HashMap的大小都是2^n次方（稍后变能看到）。那么n-1的二进制变全部都是1， n-1 做and运算，就想当与hash()对size取模。</p>
<p><strong>get</strong><br><img src="../resource/java/hashMapget.jpg" alt=""></p>
<h3 id="增加-修改-put"><a href="#增加-修改-put" class="headerlink" title="增加/修改 put()"></a>增加/修改 put()</h3><details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置k-v</span></span><br><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,</span><br><span class="line">            <span class="built_in">boolean</span> evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果table =null 空 则进行resize扩缩容处理</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果index索引处为null，表示没有发生hash冲突，直接设置值</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 第一个节点就是要找的key，e=p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 第一个节点是红黑树，则从红黑树中找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="built_in">key</span>, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历后面的链表，找到e</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//此处如果链表长度大于阈值，则会进行链表转红黑树处理</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了节点，并且不为空，如果是替换模式 put是，则替换，返回旧节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果大小大于阈值，扩缩容</span></span><br><span class="line">    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<br/>

<p><strong>说明：</strong></p>
<p>通过上面的代码，我们了解到</p>
<ol>
<li>hashMap的put如果存在，则会替换旧值</li>
<li>hashMap阈值则会扩容处理</li>
<li>如果链表长度大于阈值，则会进行链表转红黑树处理。</li>
</ol>
<p>那么：</p>
<ol>
<li>hashMap链表转红黑树的阈值是多少呢</li>
<li>hashMap扩容是怎么进行扩容的呢。</li>
<li>hashMap扩缩容阈值是怎么确定的呢</li>
</ol>
<p><strong><em>1.hashMap链表转红黑树阈值：</em></strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>The bin count threshold for using </span>a<span class="markdown"> tree rather than list for </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>bin.  Bins </span>are<span class="markdown"> converted to trees when adding </span>an<span class="markdown"> element to </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>bin with at least this many nodes. The value must be greater</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>than 2 and </span>should<span class="markdown"> be at least 8 to mesh with assumptions in</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>tree removal about conversion back to plain bins upon</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>shrinkage.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>The bin count threshold for untreeifying </span>a<span class="markdown"> (split) bin during </span>a</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">    * </span>most 6 to mesh with shrinkage detection under removal.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    */</span></span></span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>当链表结构长度超过8 的时候会转化为红黑树，当冲突节点长度小于6的时候，会退化为链表。</p>
<p><strong><em>3.hashMap扩容是怎么进行扩容的呢。</em></strong></p>
<p>来看看扩容的代码:</p>
<br/>
<br/>

<details>
<summary><font color='red'>View Code</font></summary>

<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">public</span> HashMap() &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || <span class="keyword">Float</span>.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 旧的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧的数组长度为旧数组容量 cap</span></span><br><span class="line">    int oldCap = (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : <span class="type">oldTab</span>.length;</span><br><span class="line">    <span class="comment">// 旧阈值为0 如果是new HashMap();</span></span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新容量 新阈值初始为0</span></span><br><span class="line">    int <span class="keyword">new</span><span class="type">Cap</span>, <span class="keyword">new</span><span class="type">Thr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 旧容量有值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧容量已经大于1&gt;&gt;30,则不再进行之后的扩容，直接阈值设置为最大值，返回旧数组。</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容，数组扩容为原来2倍，阈值也变更为原来阈值的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">new</span><span class="type">Cap</span> = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="keyword">new</span><span class="type">Thr</span> = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果容量为0 ，但是阈值有值，第二种构造函数创建，则容量设置为旧的阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;          </span><br><span class="line">        <span class="comment">//都没初始化，则初始化 容量为16 阈值为16*0.75 12    </span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的阈值没有初始化，也就是 oldThr&gt;0的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Thr</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//初始化为 newCap*0.75</span></span><br><span class="line">        float ft = (float)<span class="keyword">new</span><span class="type">Cap</span> * loadFactor;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (<span class="keyword">new</span><span class="type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : <span class="type">Integer</span>.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置阈值</span></span><br><span class="line">    threshold = <span class="keyword">new</span><span class="type">Thr</span>;</span><br><span class="line">    <span class="comment">// 设置新数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">new</span><span class="type">Tab</span> = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="type">Node</span>[<span class="keyword">new</span><span class="type">Cap</span>];</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">    <span class="comment">//如果旧数组不为null，需要数据迁移，为空可以直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧链表中所有元素进行数据迁移</span></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//为null的节点不处理</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//先把旧节点位置的数据清空</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//如果当前位置只有一个元素，则直接设置到新位置处</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                   <span class="comment">// 新位置的计算重新取hash与大小取模</span></span><br><span class="line">                    <span class="keyword">new</span><span class="type">Tab</span>[e.hash &amp; (<span class="keyword">new</span><span class="type">Cap</span> - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, <span class="keyword">new</span><span class="type">Tab</span>, j, oldCap);</span><br><span class="line">                <span class="comment">// 如果是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//遍历链表所有节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//分为两种情况 1. 当前hash超过了旧容量，2 当前哈希没有超过就容量</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 没超过 则放入loTail</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//超过了，则放入hitail</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 处理loTail  改链表位置不变</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理hiTail 该链表位置变为 原oldCap+j</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<br/>

<p>可以发现：</p>
<ol>
<li>hashMap中数组最大容量是 1&gt;&gt;30</li>
<li>hashMap的table扩容是左移一位，扩容为原来的两倍容量</li>
<li>扩容后的处理，扩容后元素需要迁移，由于hashMap的处理中，扩容为原来的两倍，初始化的时候也是2的n次方这种，所以扩容后节点的hash定位index的时候只有 原位置，和j+oldCap这两种。</li>
</ol>
<p>设置容量的初始化: 巧妙的构思将 n之后的位数全部设置为1，然后+1取2的n次方的整数。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">static final <span class="built_in">int</span> tableSizeFor(<span class="built_in">int</span> cap) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    return (<span class="built_in">n</span> &lt; <span class="number">0</span>) ? <span class="number">1</span> <span class="symbol">:</span> (<span class="built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="symbol">:</span> <span class="built_in">n</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../resource/java/hashMapResize.jpg" alt=""></p>
<p><strong><em>为什么hashMap内部的table要设置为2的n次方倍呢？</em></strong></p>
<ol>
<li>hash映射到数组中需要以取模的方式来进行</li>
<li>取模的操作可以映射到 (n-1) &amp; k 上，</li>
<li>如果n为2的n次方，那么n-1二进制上全部为1，那么与k取and运算的时候，k&lt;=n-1则为k,k&gt;n的时候 高位被舍弃</li>
<li>2的n次方的时候，扩容后舍弃的高位还原，那么元素移动的时候就可以轻易计算出来移动后的位置。</li>
</ol>
<p><strong><em>3.hashMap扩缩容阈值是怎么确定的呢</em></strong></p>
<p>从上述的扩容操作中，我们可以知道，扩容阈值始终为容量的 0.75 也就是设置的扩容因子 loadFactory</p>
<h3 id="删除-remove"><a href="#删除-remove" class="headerlink" title="删除 remove()"></a>删除 remove()</h3><details>
<summary>View Code</summary>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, <span class="literal">false</span>, <span class="literal">true</span>)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                            boolean matchValue, boolean movable) &#123;</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab; <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; p; int n, index;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != null) &#123;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; <span class="keyword">node</span> <span class="title">= null</span>, e; K k; V v;</span><br><span class="line">        //找到需要删除的节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">node</span> <span class="title">= p</span>;</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                <span class="keyword">node</span> <span class="title">= ((TreeNode</span><span class="tag">&lt;K,V&gt;</span>)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                //循环链表找到需要的节点</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        <span class="keyword">node</span> <span class="title">= e</span>;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到节点 删除掉该节点。</span><br><span class="line">        if (<span class="keyword">node</span> <span class="title">!= null</span> &amp;&amp; (!matchValue || (v = <span class="keyword">node</span>.<span class="title">value</span>) == value ||</span><br><span class="line">                                (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (<span class="keyword">node</span> <span class="title">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode<span class="tag">&lt;K,V&gt;</span>)<span class="keyword">node</span><span class="title">).removeTreeNode</span>(this, tab, movable);</span><br><span class="line">            else if (<span class="keyword">node</span> <span class="title">== p</span>)</span><br><span class="line">                tab[index] = <span class="keyword">node</span>.<span class="title">next</span>;</span><br><span class="line">            else</span><br><span class="line">                p.next = <span class="keyword">node</span>.<span class="title">next</span>;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">            return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">    return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<br/>
<br/>

<p><strong>说明：</strong><br>删除的操作比较简单，找到节点之后直接移除掉节点就可以了。</p>
<h1 id="使用hashmap需要注意"><a href="#使用hashmap需要注意" class="headerlink" title="使用hashmap需要注意"></a>使用hashmap需要注意</h1><ol>
<li>hashMap是非线程安全的</li>
<li>扩容的操作会遍历所有的元素，并且当元素&gt;0.75cap的时候就会进行扩容，所以在使用的时候，如果能预估容量，最好可以直接设定hashMap的容量，避免扩容处理</li>
<li>equals重写，hashCode一定要进行重写，否则可能导致equals是相同的但是hashCode没有重写导致不同 。因为equals相同，所以我们认为两个对象是一个。但是hashCode不同，会导致其路由到不同的index上，所以如果通过a是找不到我们认为相同的b的。</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>本文首先介绍了哈希表的相关知识，然后通过hashMap的源码，了解了hashMap内部结构和扩容等相关知识。通过上述的分析，我们对于hashMap有了更深刻的理解。但是依旧有很多地方没有涉及，例如红黑树内部的操作，序列化等等操作。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>LinedList源码分析</title>
    <url>/post/2528e072.html</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>如果说ArrayList是随机访问的典型结构，那LinkedList就是典型的顺序访问结构。</p>
<p>在ArrayList的源码分析中我们提到，ArrayList的出现是为了弥补数组大小需要自我管理，避免数组越界等问题，提供了自动扩容的特性，以及数组插入元素删除元素的元素移动管理等等。</p>
<p>那么LinkedList相比于ArrayList又具有哪些优点或者缺点呢？让我们先看看LinkedList的数据结构在来回答这个问题。 </p>
<h1 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a>LinkedList源码解析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><details>

<summary>view code</summary>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">//首节点</span><br><span class="line">transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; first;</span><br><span class="line">//尾节点</span><br><span class="line">transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; last;</span><br><span class="line"></span><br><span class="line">private static class <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; &#123;</span><br><span class="line">   //元素值</span><br><span class="line">    E item; </span><br><span class="line">    //下一个节点</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next;</span><br><span class="line">    //前一个节点</span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Node</span><span class="title">(Node</span><span class="tag">&lt;E&gt;</span> prev, E element, <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p>通过上述源码可以发现，LinkedList内部的结构就如同下图所示的双向链表</p>
<p><img src="../resource/java/LinkedList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>如果所示，在LinkedList的内部维护了一个双向列表，并且分别使用first和last指针指向了双向链表的头部和尾部，如此，便可以从头开始，或者从尾部开始进行查找。 </p>
<p><strong><em>LinkedList的优缺点:</em></strong></p>
<p>既然linkedList是以链表为基础结构的，那边链表的优缺点LinkedList也基本具备。<br>优点： </p>
<ol>
<li>插入删除操作仅仅需要修改对应指针，不在需要移动元素操作。 </li>
<li>大小可无限扩展和缩减，无需进行扩容的相关操作。</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法进行随机访问，需要访问某个位置的节点，只能从头开始遍历。</li>
</ol>
<p>链表的基础操作其实相当麻烦，需要插入一个元素的时候，需要修改前一个节点指针后一个节点指针，那么LinkedList作为链表的封装，又提供了哪些基础函数可以使用呢？</p>
<h2 id="LinkedList重要函数"><a href="#LinkedList重要函数" class="headerlink" title="LinkedList重要函数"></a>LinkedList重要函数</h2><h3 id="link-amp-amp-unLink-方法"><a href="#link-amp-amp-unLink-方法" class="headerlink" title="link* &amp;&amp; unLink* 方法"></a>link* &amp;&amp; unLink* 方法</h3><h4 id="linkFirst-amp-amp-unlinkFirst"><a href="#linkFirst-amp-amp-unlinkFirst" class="headerlink" title="linkFirst &amp;&amp; unlinkFirst"></a>linkFirst &amp;&amp; unlinkFirst</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置e为第一个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> linkFirst(E e) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//设置首个节点为e</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//之前的首节点为null，表示改链表之前未null</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//设置last节点也为e</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否者设置之前的节点的前驱为e</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="keyword">size</span>++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定节点前的所有节点</span></span><br><span class="line"><span class="keyword">private</span> E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; <span class="keyword">next</span> = f.<span class="keyword">next</span>;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.<span class="keyword">next</span> = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//指定节点后的节点设置为首节点</span></span><br><span class="line">    first = <span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="comment">//指定节点后的节点前驱节点设置为null</span></span><br><span class="line">        <span class="keyword">next</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">size</span>--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong><br>上面两个函数，为其他函数例如 addFirst等函数提供了基础操作，主要作用是链表头部插入元素，和链表头部删除元素。</p>
<p>linkFirst:</p>
<p><img src="../resource/java/linkFirst.jpg" alt=""></p>
<p>unlinkFirst:<br><img src="../resource/java/unlinkFirst.jpg" alt=""></p>
<h4 id="剩余link-amp-amp-unlink-函数"><a href="#剩余link-amp-amp-unlink-函数" class="headerlink" title="剩余link* &amp;&amp; unlink* 函数"></a>剩余link* &amp;&amp; unlink* 函数</h4><details>
<summary>view code</summary>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置e为尾节点，为add提供服务</span></span><br><span class="line"><span class="keyword">void</span> linkLast(E e) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.<span class="keyword">next</span> = newNode;</span><br><span class="line">    <span class="keyword">size</span>++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在特定节点前插入节点</span></span><br><span class="line"><span class="keyword">void</span> linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.<span class="keyword">next</span> = newNode;</span><br><span class="line">    <span class="keyword">size</span>++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点后所有节点 用于删除尾节点等</span></span><br><span class="line"><span class="keyword">private</span> E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">size</span>--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除特定节点</span></span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; <span class="keyword">next</span> = x.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = <span class="keyword">next</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>.prev = prev;</span><br><span class="line">        x.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">size</span>--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明：</strong><br>上述所有的link，unlink操作，包含了对于一个链表的最基本插入节点和删除节点操作，提供了对于首、尾、特定节点的插入删除操作的封装，以共用并且简化其他api的复杂度。</p>
<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">Node&lt;E&gt; node(int <span class="meta">index</span>) &#123;</span><br><span class="line">  //优化方案，如果<span class="meta">index</span>在前半部分从前开始搜索，否则从尾节点开始搜索，属于空间换时间的思路</span><br><span class="line">  <span class="meta">if</span> (<span class="meta">index</span> &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">      Node&lt;E&gt; <span class="meta">x</span> = first;</span><br><span class="line">      for (int i = 0; i &lt; <span class="meta">index</span>; i++)</span><br><span class="line">          <span class="meta">x</span> = <span class="meta">x</span>.next;</span><br><span class="line">      <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">  &#125; <span class="meta">else</span> &#123;</span><br><span class="line">    //从尾节点开始搜索</span><br><span class="line">      Node&lt;E&gt; <span class="meta">x</span> = last;</span><br><span class="line">      for (int i = size - 1; i &gt; <span class="meta">index</span>; i--)</span><br><span class="line">          <span class="meta">x</span> = <span class="meta">x</span>.prev;</span><br><span class="line">      <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong><br>node函数，提供了一个搜索特定位置节点的方法，该方法为add(1,e)提供了基础，插入特定位置某个特定元素提供了基础方法</p>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">  link<span class="constructor">Last(<span class="params">e</span>)</span>;</span><br><span class="line">  return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void add<span class="constructor">First(E <span class="params">e</span>)</span> &#123;</span><br><span class="line">  link<span class="constructor">First(<span class="params">e</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void add<span class="constructor">Last(E <span class="params">e</span>)</span> &#123;</span><br><span class="line">  link<span class="constructor">Last(<span class="params">e</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void add(<span class="built_in">int</span> index, E element) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index<span class="operator"> == </span>size)</span><br><span class="line">      link<span class="constructor">Last(<span class="params">element</span>)</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      link<span class="constructor">Before(<span class="params">element</span>, <span class="params">node</span>(<span class="params">index</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> link* 函数上述已经描述过了，add函数均是调用link*还是来实现插入元素的操作。</p>
<h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><details>
<summary>view code</summary>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Inserts all of </span>the<span class="markdown"> elements in </span>the<span class="markdown"> specified collection into this</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>list, starting at </span>the<span class="markdown"> specified position.  Shifts </span>the<span class="markdown"> element</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>currently at that position (if any) and any subsequent elements to</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span></span>the<span class="markdown"> right (increases their indices).  The new elements </span>will<span class="markdown"> appear</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>in </span>the<span class="markdown"> list in </span>the<span class="markdown"> order that </span>they<span class="markdown"> </span>are<span class="markdown"> returned by </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>specified collection's iterator.</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param index index at which to insert </span>the<span class="markdown"> first element</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">*              </span>from </span>the<span class="markdown"> specified collection</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@param c collection containing elements to be added to this list</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@return &#123;@code true&#125; if this list changed as </span>a<span class="markdown"> result of </span>the<span class="markdown"> call</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@throws NullPointerException if </span>the<span class="markdown"> specified collection is null</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*/</span></span></span><br><span class="line">public boolean addAll(<span class="built_in">int</span> index, Collection&lt;? <span class="keyword">extends</span> E&gt; c) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">//将集合转化为数组</span></span><br><span class="line">    <span class="built_in">Object</span>[] a = c.toArray();</span><br><span class="line">    <span class="built_in">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 找到index的节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组 将集合插入到index节点后面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">Object</span> o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置尾节点 或者后面的节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明：</strong> </p>
<p>addAll()函数中，有一个很有意思的点，就是 <strong>Object[] a = c.toArray();</strong> 为什么插入集合元素的时候需要先把集合转化为数组呢？</p>
<p>查看addAll的注释解释，发现也并没有说明这个事情，那么我们去看下toArray()方法是否会有这个解释呢？</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Returns an<span class="built_in"> array </span>containing all of the elements in this collection.</span><br><span class="line">  * If this collection makes any guarantees as to what order its elements</span><br><span class="line">  * are returned by its iterator, this method must<span class="built_in"> return </span>the elements in</span><br><span class="line">  * the same order.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;The returned<span class="built_in"> array </span>will be <span class="string">"safe"</span> in that no references to it are</span><br><span class="line">  * maintained by this collection.  (In other words, this method must</span><br><span class="line">  * allocate a<span class="built_in"> new </span>array even<span class="built_in"> if </span>this collection is backed by an array).</span><br><span class="line">  * The caller is thus free to modify the returned array.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;This method acts as<span class="keyword"> bridge</span> between<span class="built_in"> array-based </span>and collection-based</span><br><span class="line">  * APIs.</span><br><span class="line">  *</span><br><span class="line">  * @return an<span class="built_in"> array </span>containing all of the elements in this collection</span><br><span class="line">  */</span><br><span class="line">Object[] toArray();</span><br></pre></td></tr></table></figure>

<p>根据注释的解释我们可以发现：</p>
<p><strong><em>Collection.toArray()方法的定义上，是提供一个安全的方法，是的获取到的数组可以被自由的修改或者是删除元素,而不会影响到原本的集合</em></strong></p>
<p><strong><em>注意：对于Collection.toArray()进行实现的时候，请务必遵循改原则</em></strong></p>
<p>那么我们在来看一下LinkedList的toArray()方法:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span>[] toArray() &#123;</span><br><span class="line">  <span class="keyword">Object</span>[] result = <span class="keyword">new</span> <span class="keyword">Object</span>[<span class="built_in">size</span>];</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">      result[i++] = x.item;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的我们发现一个事情，就是如果你对这个数组进行了增加删除修改，是不会反应到集合的。但是这个safe是不会包含对象的safe，也就是 <strong><em>集合的对象和数组的对象还是一个对象 如果我们修改了数组中对象的属性，那么原集合中也会有体现</em></strong></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">  <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">unlinkFirst</span><span class="params">(f)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">unlinkLast</span><span class="params">(l)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> 与add类似，remove也是基于link* 函数和node函数进行的封装。<br>并且从上述操作中我们可以发现，删除一个特定位置的节点，对于LinkedList来说时间复杂度为O(n).</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> E <span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">  checkElementIndex(<span class="keyword">index</span>);</span><br><span class="line">  <span class="keyword">return</span> node(<span class="keyword">index</span>).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过上面的增加，删除，查询，我们可以发现对于LinkedList或者说对于链表来说，基础操作都是基于link*  unlink*  node()函数进行的，也就是节点前后添加元素，节点前后删除元素的指针操作，以及查找指定位置元素这个三个基本操作进行的。</p>
<h1 id="额外特性，题外话"><a href="#额外特性，题外话" class="headerlink" title="额外特性，题外话"></a>额外特性，题外话</h1><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function">E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>由于LinkedList采用的双链表的实现方式，add 和 remove 头尾节点非常的方便，并且耗时为O(1)，时间复杂度极低，故而LinkedList同样还可以作为栈或者队列来使用， pop push 操作构成了先进后出的栈结构， poll add 变成了先进先出的队列结构。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/post/3fb8877a.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><!-- 为什么需要ArrayList，ArrayList 解决了什么问题? -->

<p>在进入源码分析前，先让我们想一个问题：</p>
<p><em>ArrayList作为一个随机访问(RandomAccess)的类，其基本操作几乎与数组一致，但是对于任何一门计算机语言来说，数组基本都是内置的基础结构，那么既然有了数组，为什么还需要ArrayList这样的数据结构呢？</em></p>
<!-- 因为自动扩容 -->

<p>从ArrayList的注释的第一句话，我们就可以找到上面问题的答案，那就是 </p>
<blockquote>
<p>Resizable-array implementation of the List interface</p>
</blockquote>
<p><strong><em>Resizable-array 大小可调整 即自动扩容</em></strong> </p>
<p>数组作为一个基本的结构，其操作是非常简单的，但是其缺点也是非常明显的，那就是数组的大小是最开始就申请好的，一旦数据数目超过了数组大小，就会有数组越界风险。 那么对于一些我们无法提前知道数据个数的场景，比如用户购物车的场景，用户随时可以增加商品.</p>
<p>而ArrayList的自动扩容恰好弥补该缺陷，开发者无需考虑数组越界的风险，增加商品的时候直接add即可，由ArrayList来进行动态调整。</p>
<p>那么ArrayList又是如何进行resizable呢？这就需要进入源码的世界了</p>
<h1 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h1><h2 id="数据结构是一切的基础"><a href="#数据结构是一切的基础" class="headerlink" title="数据结构是一切的基础"></a>数据结构是一切的基础</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The<span class="built_in"> array </span>buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this<span class="built_in"> array </span>buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/%E6%95%B0%E7%BB%84.jpg" alt=""></p>
<p>ArrayList的内部依旧采用的数组(elementData存储元素)的数据结构，并且类型是Object，由于java中所有类都继承自Object，故而ArrayList实质可以存储所有类型。</p>
<h2 id="什么时候扩容？"><a href="#什么时候扩容？" class="headerlink" title="什么时候扩容？"></a>什么时候扩容？</h2><p>对于RandomAccess 随机访问的集合结构来说，最终要的接口无疑是 get，set，add 方法了。</p>
<p>首先来看get方法(如下code)：对于get/set来说，是无需关心扩容问题的，只要没有越界，那么这个数据就肯定存在，故而仅仅检查了越界问题就直接返回了数组中的Index位置的元素（或者设置数组index位置的元素）</p>
<details>
<summary>View Code</summary>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> E <span class="keyword">get</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> elementData(<span class="keyword">index</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> private <span class="type">void</span> range<span class="keyword">Check</span>(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= size)</span><br><span class="line">         throw <span class="built_in">new</span> IndexOutOfBoundsException(outOfBoundsMsg(<span class="keyword">index</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">public</span> E <span class="keyword">set</span>(<span class="type">int</span> <span class="keyword">index</span>, E element) &#123;</span><br><span class="line">     range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">     E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line">     elementData[<span class="keyword">index</span>] = element;</span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</details>

<br/>
<br/>

<p><strong><em>add方法：</em></strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保容量足够</span></span><br><span class="line">    ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>); </span><br><span class="line">    elementData[<span class="built_in">size</span>++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前数空数组，则取size+1和默认值的最大值，否则取size+1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.<span class="built_in">max</span>(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果 当前需求的最小容量 比内部的数组长度大 则表示内部数组已经存放不了 此时便需要进行扩容处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，ArrayList在进行add操作的时候会先确保当前容量是否足够，如果不足变回调用grow方法进行扩容。</p>
<p><strong>结论：</strong><br>此时，便可以得出结论，当ArrayList在进行add操作的时候，如果所需要的数量大于当前ArrayList内部数组elementData的长度的时候，由于elementData已经存放不下，此时便需要进行扩容。</p>
<h2 id="怎么扩容？"><a href="#怎么扩容？" class="headerlink" title="怎么扩容？"></a>怎么扩容？</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void grow(int minCapacity) &#123;</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的 1.5倍</span></span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新容量比需求容量小，则新容量直接设置为需要的容量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量比 默认最大数值大 Integer.MAX_VALUE-8,则判断需要的是否超过MAX_ARRAY_SIZE，超过取最大，否则取MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">Capacity</span> = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 进行原数组复制，扩容。</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :<span class="type"></span></span><br><span class="line"><span class="type">        MAX_ARRAY_SIZE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../resource/java/ArrayList%E6%89%A9%E5%AE%B9.jpg" alt=""></p>
<p><strong><em>示例：</em></strong><br><img src="../resource/java/ArrayList%E6%89%A9%E5%AE%B9%E7%A4%BA%E4%BE%8B.jpg" alt=""></p>
<p>总结：</p>
<ol>
<li>ArrayList的扩容是以原容量的1.5倍为基础。</li>
<li>扩容的过程中会进行越界检查。</li>
<li><strong><em>如果需求容量大于原容量的1.5倍，则会直接扩容到需求容量。</em></strong>所以当我们多次通过addAll进行新增元素（并且新增元素比较多的时候）的时候，是否可以调用ensureCapacity()方法手动扩容，以避免addAll的多次频繁扩容。</li>
</ol>
<h2 id="其他重要函数"><a href="#其他重要函数" class="headerlink" title="其他重要函数"></a>其他重要函数</h2><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><details>
<summary>view Code</summary>

<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">     <span class="comment">//越界检查</span></span><br><span class="line">      rangeCheck(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">      modCount++; </span><br><span class="line">      <span class="comment">//设置值</span></span><br><span class="line">      E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line">      <span class="comment">//不需要移动的数组元素</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">         <span class="comment">//移动删除元素后面的所有元素</span></span><br><span class="line">          System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//设置为null，当数组为null的时候利于GC回收</span></span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>; </span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong> remove方法进行了越界检查，由于数组的特性，remove后需要将remove掉的位置之后的所有元素向前移动，以保证remove后ArrayList还是保持其基本操作不变。</p>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><details>
<summary>view Code</summary>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> indexOf(Object o) &#123;</span><br><span class="line">      <span class="comment">//空进行特殊处理</span></span><br><span class="line">       <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//其余部分均使用equals判断</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong> indexOf查找位置的方法，对于null进行了==号比较，对于普通元素都使用的equals方法进行比较</p>
<h3 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h3><details>
<summary>view Code</summary>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> new SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subList构造函数</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">                int offset, int fromIndex, int toIndex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">            <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="keyword">set</span>(int index, E e) &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明:</strong> 使用数组的时候，有时候我们会使用subList方法去构建一个子视图，通过subList方法，我们可以发现，子方法的所有操作都是针对于原ArrayList中的数组的，<strong><em>故而在子视图上进行的任何修改都会反映到原ArrayList对象中</em></strong></p>
<!-- 总结 -->
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>ArrayList的出现，为用户提供了一种自维护的数组数据结构，用户不需要再考虑越界，数组扩容，插入元素数组的元素移动等操作。</li>
<li>ArrayList内部依旧是通过数组的数据结构实现的。</li>
<li>ArrayList的自动扩容机制是通过数组复制实现的，扩容操作是在新增元素的时候进行容量检查，进行扩容</li>
<li>ArrayList的扩容默认容量是原容量的1.5倍，如果新增元素量大于1.5倍原容量，则会直接扩容到新增元素后需要的大小。</li>
<li>ArrayList的subList子视图方法，进行修改操作的时候是直接反映到原ArrayList中的。</li>
</ol>
<p>ArrayList具有随机读写的优点，对于特定位置的元素获取修改等操作可以有O(1)的复杂度，但是却在插入删除中间元素等操作的时候，需要进行大量元素移动的操作，效率低下O(n)。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合框架详解</title>
    <url>/post/82f1582a.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  作为java程序员，java集合在开发过程中使用的非常频繁，例如 ArrayList,HashMap，基本可以说在每一个项目中都会有。但是却又很少去了解其底层原理。所以准备对java集合框架源码进行探究，梳理集合框架数据结构和设计原理。 此次梳理希望能实现下面的目标：<br>      &emsp; 1. 温故而知新，对于java底层知识的回顾。<br>      &emsp; 2. 了解涉及思想，提升代码设计水平。<br>      &emsp; 3. 了解底层设计，能够以最恰当的方式使用java的集合 </p>
<h1 id="梳理线路"><a href="#梳理线路" class="headerlink" title="梳理线路"></a>梳理线路</h1><p><img src="../resource/java/java%E9%9B%86%E5%90%88.png" alt=""></p>
<h1 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h1><p><img src="../resource/java/javaCollection.jpeg" alt="图片源于百度"></p>
<center><font size=1>注明：图片源于百度</font></center>  
<br/>

<p>总结：</p>
<ol>
<li>6大顶层接口:Collection ,Iterator,Map,List,Set,Queue</li>
<li>5大抽象类 AbstractCollection,AbstractList,AbstractSet,AbstractMap,AbstractSeqentialList.</li>
<li>10个一级实现类</li>
<li>两个功能接口：Comparable,Comparator</li>
<li>两大工具类: Collections,Arrays</li>
</ol>
<h1 id="基础接口-类概览"><a href="#基础接口-类概览" class="headerlink" title="基础接口/类概览"></a>基础接口/类概览</h1><p><img src="../resource/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%8E%A5%E5%8F%A3%E6%A2%B3%E7%90%86.png" alt=""></p>
<h1 id="重要接口说明"><a href="#重要接口说明" class="headerlink" title="重要接口说明"></a>重要接口说明</h1><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><details>
<summary>View Code</summary>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    E next();</span><br><span class="line">   <span class="built_in"> default </span>void <span class="builtin-name">remove</span>() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明</strong></p>
<ol>
<li>iterator接口定义迭代器的基本操作,主要方法 hasNext(),next().</li>
</ol>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>除了Map接口，其他的接口都继承自Collection接口，并且由于java多态的特性，Interface i1 = new Immplements() 。 此时该对象i1调用的方法必须是接口中所有的，故而对于Collection接口就必须要有个了解。</p>
<details>
<summary>View Code</summary>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean contains(Object o);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    boolean <span class="builtin-name">add</span>(E e);</span><br><span class="line">    boolean <span class="builtin-name">remove</span>(Object o);</span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line">   <span class="built_in"> default </span>boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line">    void clear();</span><br><span class="line">    boolean equals(Object o);</span><br><span class="line">    int hashCode();</span><br><span class="line">    @Override</span><br><span class="line">   <span class="built_in"> default </span>Spliterator&lt;E&gt; spliterator() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>Stream&lt;E&gt; stream() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">   <span class="built_in"> default </span>Stream&lt;E&gt; parallelStream() &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明：</strong></p>
<ol>
<li>作为集合顶层接口的Collection 定义了对于一个集合最普遍的操作，增，删，判空，转数组，判断包含等等基本操作。</li>
<li>集合继承了Iterable接口，包含了 iterator方法，对于集合来说，需要可遍历集合中所有元素</li>
</ol>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><details>
<summary>View Code</summary>

<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">interface</span> <span class="type">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean containsKey(<span class="type">Object</span> key);</span><br><span class="line">    boolean containsValue(<span class="type">Object</span> value);</span><br><span class="line">    V get(<span class="type">Object</span> key);</span><br><span class="line">    V put(K key, V value);</span><br><span class="line">    V remove(<span class="type">Object</span> key);</span><br><span class="line">    <span class="built_in">void</span> putAll(<span class="type">Map</span>&lt;? extends K, ? extends V&gt; m);</span><br><span class="line">    <span class="built_in">void</span> clear();</span><br><span class="line">    <span class="type">Set</span>&lt;K&gt; keySet();</span><br><span class="line">    <span class="type">Collection</span>&lt;V&gt; values();</span><br><span class="line">    <span class="type">Set</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">    <span class="keyword">interface</span> <span class="type">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        V setValue(V value);</span><br><span class="line">        boolean equals(<span class="type">Object</span> o);</span><br><span class="line">        <span class="built_in">int</span> hashCode();</span><br><span class="line">        public <span class="keyword">static</span> &lt;K extends <span class="type">Comparable</span>&lt;? super K&gt;, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K,V&gt;&gt; comparingByKey() <span class="meta">&#123;...&#125;</span></span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V extends <span class="type">Comparable</span>&lt;? super V&gt;&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K,V&gt;&gt; comparingByValue() &#123; ... &#125;</span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; comparingByKey(<span class="type">Comparator</span>&lt;? super K&gt; cmp) <span class="meta">&#123;...&#125;</span></span><br><span class="line">        public <span class="keyword">static</span> &lt;K, V&gt; <span class="type">Comparator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;K, V&gt;&gt; comparingByValue(<span class="type">Comparator</span>&lt;? super V&gt; cmp) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    boolean equals(<span class="type">Object</span> o);</span><br><span class="line">    <span class="built_in">int</span> hashCode();</span><br><span class="line">    default V getOrDefault(<span class="type">Object</span> key, V defaultValue) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="built_in">void</span> forEach(<span class="type">BiConsumer</span>&lt;? super K, ? super V&gt; action) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="built_in">void</span> replaceAll(<span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; function) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V putIfAbsent(K key, V value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default boolean remove(<span class="type">Object</span> key, <span class="type">Object</span> value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default boolean replace(K key, V oldValue, V newValue) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V replace(K key, V value) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V computeIfAbsent(K key,</span><br><span class="line">            <span class="type">Function</span>&lt;? super K, ? extends V&gt; mappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V computeIfPresent(K key,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V compute(K key,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super K, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default V merge(K key, V value,</span><br><span class="line">            <span class="type">BiFunction</span>&lt;? super V, ? super V, ? extends V&gt; remappingFunction) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>说明:</strong></p>
<ol>
<li>通用集合都是单值，Map是 kv 双值，故而Map的接口与Collection的接口会有很大的区别，这也是其他集合接口均集成Collection而Map不继承的原因</li>
<li>Map的基础操作依赖于Entry，外层是对于Entry的Set集合视图。</li>
<li>Map接口定义Map类型的基本增加，删除，判断，清空，大小等方法</li>
</ol>
<h2 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable&amp;Comparator"></a>Comparable&amp;Comparator</h2><details>
<summary>View Code</summary>

<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">interface</span> <span class="type">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> compareTo(T var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">interface</span> <span class="type">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">int</span> compare(T o1, T o2);</span><br><span class="line"></span><br><span class="line">    boolean equals(<span class="type">Object</span> obj);</span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; reversed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Collections</span>.reverseOrder(this);</span><br><span class="line">    &#125;</span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparing(<span class="type">Comparator</span>&lt;? super T&gt; other) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default &lt;U&gt; <span class="type">Comparator</span>&lt;T&gt; thenComparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor,</span><br><span class="line">            <span class="type">Comparator</span>&lt;? super U&gt; keyComparator)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default &lt;U extends <span class="type">Comparable</span>&lt;? super U&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; thenComparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">    <span class="meta">&#123;... &#125;</span></span><br><span class="line"><span class="meta">    default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) &#123;...&#125;</span></span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparingLong(<span class="type">ToLongFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    default <span class="type">Comparator</span>&lt;T&gt; thenComparingDouble(<span class="type">ToDoubleFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T extends <span class="type">Comparable</span>&lt;? super T&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; reverseOrder() <span class="meta">&#123;...&#125;</span></span><br><span class="line">    @<span class="type">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    public <span class="keyword">static</span> &lt;T extends <span class="type">Comparable</span>&lt;? super T&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; naturalOrder() <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; nullsFirst(<span class="type">Comparator</span>&lt;? super T&gt; comparator) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; nullsLast(<span class="type">Comparator</span>&lt;? super T&gt; comparator) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T, U&gt; <span class="type">Comparator</span>&lt;T&gt; comparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor,</span><br><span class="line">            <span class="type">Comparator</span>&lt;? super U&gt; keyComparator)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T, U extends <span class="type">Comparable</span>&lt;? super U&gt;&gt; <span class="type">Comparator</span>&lt;T&gt; comparing(</span><br><span class="line">            <span class="type">Function</span>&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">    <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingInt(<span class="type">ToIntFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingLong(<span class="type">ToLongFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span>&lt;T&gt; <span class="type">Comparator</span>&lt;T&gt; comparingDouble(<span class="type">ToDoubleFunction</span>&lt;? super T&gt; keyExtractor) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><strong>说明:</strong></p>
<ol>
<li>Comparable与Comparator都是用作定义可排序和排序方式的接口，主要区别Comparable是内比较，用作当前对象和其他对象比较，COmparator是外比较，用于两个对象进行比较。</li>
</ol>
<h2 id="Collections-amp-Arrays"><a href="#Collections-amp-Arrays" class="headerlink" title="Collections&amp;Arrays"></a>Collections&amp;Arrays</h2><p>Collections：主要包含了集合的各种通用方法，例如，排序，拷贝，乱序，反序，查找，替换等等。Arrays类，主要是数组的基本操作，包含了各种排序搜索填充等基本操作</p>
<h2 id="equals-amp-hashCode"><a href="#equals-amp-hashCode" class="headerlink" title="equals &amp; hashCode"></a>equals &amp; hashCode</h2><p>HaseCode 和 equals方法是两个基础方法，其定义在Object.java类中，这两个方法定义了java中判断两个对象是否相等的方法。 </p>
<p>为什么会有equals方法呢，java中== 比较的是对象的内存地址，也就是说判断两个对象是否是统一个对象(<a href="https://blog.csdn.net/AlbenXie/article/details/88921344" target="_blank" rel="noopener">此处存在一个面试题，就是String的不同创建方式的==比较。涉及String常量词的概念</a>)，但是很多时候，比较统一对象是否是同一个对象并不是我们所需要的。所以便出现了equals方法，可以自定义两个对象是否相同。 </p>
<p><strong><em>注意：由于hashMap的比较中即使用了equals也是用到了hashCode所以对于一个对象，如果重写了equals一定要重写hashCode，以免在散列表等等场景下出现异常的情况</em></strong></p>
<p>Object规范规定：</p>
<ol>
<li>在统一个java执行程序中，如果一个对象的equals方法没有发生变更，那么无论调动多少次hashCode方法，始终返回同一个值</li>
<li>如果两个对象的equals()相同，那么两个对象的hashCode()必须返回相同的值</li>
<li>如果两个对象equals不同，那么并不要求一定不能返回两个相同的hashCode。但是不equal的两个值产生不同的hashCode可以有效的提升散列表的性能（此处参见hashMap的源码分析）。</li>
</ol>
<p>equals相等，hashCode必须相同。 equals不同，hashCode可以相同，但是建议不同。应为相同的hashCode多了之后，可能会让hashMap退化成链表结构。</p>
<details>
<summary>原文注释</summary>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>a<span class="markdown"> hash code value for </span>the<span class="markdown"> object. This method is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>supported for </span>the<span class="markdown"> benefit of hash tables </span>such<span class="markdown"> as those provided by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>&#123;@link java.util.HashMap&#125;.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>The general contract of &#123;@code hashCode&#125; is:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>Whenever it is invoked on </span>the<span class="markdown"> same object </span>more<span class="markdown"> than once during</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span></span>an<span class="markdown"> execution of </span>a<span class="markdown"> Java application, </span>the<span class="markdown"> &#123;@code hashCode&#125; method</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>must consistently return </span>the<span class="markdown"> same integer, provided no information</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>used in &#123;@code equals&#125; comparisons on </span>the<span class="markdown"> object is modified.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>This integer need not remain consistent from one execution of </span>an</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>application to another execution of </span>the<span class="markdown"> same application.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>If two objects </span>are<span class="markdown"> equal according to </span>the<span class="markdown"> &#123;@code equals(Object)&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>method, then calling </span>the<span class="markdown"> &#123;@code hashCode&#125; method on each of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span></span>the<span class="markdown"> two objects must produce </span>the<span class="markdown"> same integer result.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span>It is <span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>not<span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span> required that if two objects </span>are<span class="markdown"> unequal</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>according to </span>the<span class="markdown"> &#123;@link java.lang.Object#equals(java.lang.Object)&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>method, then calling </span>the<span class="markdown"> &#123;@code hashCode&#125; method on each of </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>two objects must produce distinct integer results.  However, </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>programmer </span>should<span class="markdown"> be aware that producing distinct integer results</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     *     </span>for unequal objects may improve </span>the<span class="markdown"> performance of hash tables.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>As much as is reasonably practical, </span>the<span class="markdown"> hashCode method defined by</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>class &#123;@code Object&#125; does return distinct integers for distinct</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>objects. (This is typically implemented by converting </span>the<span class="markdown"> internal</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>address of </span>the<span class="markdown"> object into </span>an<span class="markdown"> integer, </span>but<span class="markdown"> this implementation</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>technique is not required by </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Java&amp;trade; programming language.)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return  </span>a<span class="markdown"> hash code value for this object.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see     java.lang.Object#equals(java.lang.Object)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@see     java.lang.System#identityHashCode</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public native <span class="built_in">int</span> hashCode();</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>java</category>
        <category>java集合</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>资源清单</title>
    <url>/post/71d60cd0.html</url>
    <content><![CDATA[<h1 id="建站："><a href="#建站：" class="headerlink" title="建站："></a>建站：</h1><ul>
<li>主站点:      <a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li>
<li>next主题:    <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></li>
<li>标签云:      <a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md</a></li>
<li>文件唯一id节点:<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a></li>
<li>百度收录: <a href="https://zhuanlan.zhihu.com/p/111773896" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/111773896</a></li>
</ul>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ul>
<li>ppt教程:<a href="https://www.bilibili.com/video/av54211804?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av54211804?p=1</a></li>
</ul>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>ppt</tag>
        <tag>收藏夹</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
</search>
